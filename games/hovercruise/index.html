<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HoverCruise - Neon Racing</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; font-family: 'Arial Black', Impact, sans-serif; }
        /* Explicit emoji font support for flags and icons */
        .flag, .car-emoji, [class*="emoji"] { 
            font-family: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Android Emoji", "EmojiOne Color", sans-serif;
        }
        #game-container { width: 100vw; height: 100vh; }
        
        #hud {
            position: fixed;
            top: 0; left: 0; right: 0;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 100;
            pointer-events: none;
        }
        
        .hud-left, .hud-right, .hud-center { display: flex; flex-direction: column; gap: 5px; }
        .hud-center { align-items: center; }
        .hud-right { align-items: flex-end; }
        
        .hud-box {
            background: linear-gradient(180deg, rgba(0,0,0,0.9), rgba(15,15,25,0.85));
            border: 2px solid rgba(255,255,255,0.15);
            padding: 8px 20px;
            border-radius: 8px;
            backdrop-filter: blur(12px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.05);
        }
        
        #time-box { 
            border-color: rgba(255,220,0,0.6); 
            color: #ffd700; 
            font-size: 2.2rem; 
            text-shadow: 0 0 20px #ffd700;
            transition: all 0.3s ease-out;
        }
        #time-box.warning { 
            animation: timePulse 0.4s ease-in-out infinite;
            border-color: rgba(255,50,50,0.8);
            color: #ff4444;
        }
        @keyframes timePulse { 
            0%, 100% { 
                text-shadow: 0 0 20px #f44, 0 0 40px rgba(255,0,0,0.5);
                transform: scale(1);
            }
            50% { 
                text-shadow: 0 0 40px #f00, 0 0 80px rgba(255,0,0,0.8);
                transform: scale(1.05);
            }
        }
        
        #speed-box { 
            border-color: rgba(0,255,255,0.4); 
            color: #0ff; 
            font-size: 2rem; 
            text-shadow: 0 0 15px #0ff, 0 0 30px rgba(0,255,255,0.3);
            min-width: 120px;
        }
        #speed-box span { font-size: 0.75rem; opacity: 0.7; margin-left: 4px; }
        
        #country-box { 
            border-color: rgba(255,136,0,0.5); 
            color: #f90; 
            font-size: 1rem; 
            text-align: center;
            min-width: 100px;
        }
        #country-box .flag { font-size: 1.6rem; line-height: 1.2; }
        
        #checkpoint-box { 
            border-color: rgba(255,136,0,0.4); 
            color: #fa0; 
            font-size: 0.95rem;
            text-shadow: 0 0 10px rgba(255,136,0,0.4);
        }
        #score-box { 
            border-color: rgba(255,0,255,0.4); 
            color: #f0f; 
            font-size: 1.4rem; 
            text-shadow: 0 0 15px #f0f, 0 0 30px rgba(255,0,255,0.3);
            min-width: 100px;
        }
        
        #boost-container { margin-top: 5px; }
        #boost-label { color: #999; font-size: 0.65rem; letter-spacing: 3px; margin-bottom: 3px; text-transform: uppercase; }
        #boost-bar {
            width: 200px; height: 14px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9), rgba(20,20,20,0.85));
            border: 2px solid rgba(255,136,0,0.4);
            border-radius: 7px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 0 rgba(255,255,255,0.05);
        }
        #boost-fill {
            height: 100%;
            background: linear-gradient(90deg, #e55, #f80, #fd0, #fff);
            box-shadow: 0 0 20px #f80, inset 0 2px 0 rgba(255,255,255,0.3);
            transition: width 0.1s ease-out;
            border-radius: 4px;
        }
        
        #announcer {
            position: fixed;
            top: 38%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            color: #fff;
            text-shadow: 
                0 0 30px #f80, 
                0 0 60px #f60, 
                0 0 100px rgba(255,136,0,0.5),
                4px 4px 0 #000,
                -1px -1px 0 rgba(255,255,255,0.3);
            z-index: 150;
            opacity: 0;
            transition: opacity 0.15s ease-out, transform 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
            text-align: center;
            letter-spacing: 2px;
        }
        #announcer.show { 
            opacity: 1; 
            transform: translate(-50%, -50%) scale(1.08);
            animation: announcerPop 0.3s ease-out;
        }
        @keyframes announcerPop {
            0% { transform: translate(-50%, -50%) scale(0.8); }
            60% { transform: translate(-50%, -50%) scale(1.12); }
            100% { transform: translate(-50%, -50%) scale(1.08); }
        }
        
        #start-screen {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(255,100,0,0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(0,150,255,0.06) 0%, transparent 50%),
                linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 50%, #0a1a2a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            overflow-y: auto;
            padding: 20px;
        }
        #start-screen.hidden { display: none; }
        
        #start-screen h1 {
            font-size: 4rem;
            background: linear-gradient(180deg, #fff 0%, #ff8800 50%, #ff4400 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(3px 3px 0 #000) drop-shadow(0 0 30px #f80);
            margin-bottom: 5px;
        }
        #start-screen h2 {
            font-size: 1.3rem;
            color: #0ff;
            margin-bottom: 25px;
            letter-spacing: 15px;
            text-shadow: 0 0 20px #0ff;
        }
        
        .section-title {
            color: #777;
            font-size: 0.8rem;
            letter-spacing: 4px;
            margin: 20px 0 12px;
            text-transform: uppercase;
            font-weight: normal;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .car-select {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .car-option {
            background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
            border: 2px solid rgba(255,255,255,0.15);
            padding: 12px 18px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease-out;
            text-align: center;
            color: #fff;
            min-width: 100px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .car-option:hover {
            border-color: rgba(255,136,0,0.6);
            background: linear-gradient(180deg, rgba(255,136,0,0.2), rgba(255,68,0,0.08));
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 8px 20px rgba(255,100,0,0.25);
        }
        .car-option.selected {
            border-color: #f80;
            background: linear-gradient(180deg, rgba(255,136,0,0.35), rgba(255,68,0,0.15));
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,136,0,0.4), 0 6px 16px rgba(0,0,0,0.3);
        }
        .car-option .car-emoji { font-size: 2.2rem; }
        .car-option .car-name { font-size: 0.8rem; margin-top: 5px; }
        .car-option .car-stat { font-size: 0.65rem; margin-top: 3px; opacity: 0.7; }
        
        .country-select {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
            max-width: 600px;
        }
        .country-option {
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: 2px solid rgba(255,255,255,0.12);
            padding: 8px 14px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease-out;
            text-align: center;
            color: #fff;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }
        .country-option:hover {
            border-color: rgba(0,255,255,0.5);
            background: linear-gradient(180deg, rgba(0,255,255,0.12), rgba(0,200,255,0.05));
            transform: scale(1.08) translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,200,255,0.2);
        }
        .country-option.selected {
            border-color: #0ff;
            background: linear-gradient(180deg, rgba(0,255,255,0.2), rgba(0,200,255,0.08));
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0,255,255,0.35), 0 4px 12px rgba(0,0,0,0.25);
        }
        .country-option .flag { font-size: 1.8rem; }
        .country-option .name { font-size: 0.7rem; margin-top: 3px; }
        
        .controls-info {
            color: #666;
            font-size: 0.75rem;
            margin: 18px 0;
            text-align: center;
            line-height: 2;
            letter-spacing: 0.5px;
        }
        .controls-info span { 
            color: #f90; 
            font-weight: bold;
            padding: 2px 6px;
            background: rgba(255,136,0,0.15);
            border-radius: 4px;
            margin: 0 2px;
        }
        
        .btn {
            background: linear-gradient(180deg, #ff9911 0%, #ff6600 50%, #ee4400 100%);
            border: none;
            padding: 18px 70px;
            font-size: 1.6rem;
            color: #fff;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 
                0 6px 0 #aa2200, 
                0 12px 30px rgba(255,68,0,0.5),
                inset 0 2px 0 rgba(255,255,255,0.25);
            transition: all 0.12s ease-out;
            margin-top: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .btn:hover { 
            transform: translateY(-3px); 
            box-shadow: 
                0 9px 0 #aa2200, 
                0 18px 40px rgba(255,68,0,0.6),
                inset 0 2px 0 rgba(255,255,255,0.25);
        }
        .btn:active { 
            transform: translateY(4px); 
            box-shadow: 0 2px 0 #aa2200, inset 0 2px 0 rgba(255,255,255,0.2); 
        }
        .btn-small { padding: 12px 40px; font-size: 1.1rem; }
        
        #leaderboard {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, rgba(10,10,20,0.98), rgba(0,0,0,0.95));
            border: 3px solid rgba(255,136,0,0.7);
            border-radius: 16px;
            padding: 28px;
            z-index: 250;
            min-width: 360px;
            display: none;
            box-shadow: 0 20px 60px rgba(0,0,0,0.7), 0 0 40px rgba(255,100,0,0.15);
        }
        #leaderboard.show { display: block; animation: leaderboardIn 0.3s ease-out; }
        @keyframes leaderboardIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        #leaderboard h2 { 
            color: #f90; 
            text-align: center; 
            margin-bottom: 18px; 
            font-size: 1.5rem;
            text-shadow: 0 0 15px rgba(255,150,0,0.5);
            letter-spacing: 2px;
        }
        #leaderboard table { width: 100%; border-collapse: collapse; }
        #leaderboard th, #leaderboard td { padding: 10px 8px; text-align: left; color: #ddd; }
        #leaderboard th { 
            color: #888; 
            font-size: 0.75rem; 
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.1); 
        }
        #leaderboard tr:nth-child(even) { background: rgba(255,255,255,0.03); }
        #leaderboard tr:hover { background: rgba(255,136,0,0.1); }
        #leaderboard .rank { color: #f90; width: 35px; font-weight: bold; }
        #leaderboard .score { color: #fd0; text-align: right; text-shadow: 0 0 8px rgba(255,200,0,0.4); }
        #leaderboard .close-btn {
            position: absolute;
            top: 12px;
            right: 16px;
            color: #666;
            cursor: pointer;
            font-size: 1.6rem;
            transition: all 0.2s;
            line-height: 1;
        }
        #leaderboard .close-btn:hover { color: #fff; transform: scale(1.1); }
        
        .leaderboard-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: linear-gradient(180deg, rgba(255,136,0,0.25), rgba(255,100,0,0.15));
            border: 2px solid rgba(255,136,0,0.6);
            color: #f90;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.2s ease-out;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }
        .leaderboard-btn:hover { 
            background: linear-gradient(180deg, rgba(255,136,0,0.4), rgba(255,100,0,0.25));
            border-color: #fa0;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(255,100,0,0.25);
        }
        
        #game-over {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: 
                radial-gradient(ellipse at center, rgba(50,0,0,0.3) 0%, transparent 70%),
                rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
        }
        #game-over.hidden { display: none; }
        #game-over h1 { 
            font-size: 3.5rem; 
            color: #f55; 
            margin-bottom: 20px; 
            text-shadow: 0 0 40px #f44, 0 0 80px rgba(255,68,68,0.5), 4px 4px 0 #000; 
            letter-spacing: 4px;
        }
        #game-over .stats { 
            color: #ddd; 
            font-size: 1.2rem; 
            margin-bottom: 20px; 
            line-height: 2.2; 
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        #game-over .stats span { color: #fd0; text-shadow: 0 0 10px rgba(255,200,0,0.5); }
        #game-over .new-record { 
            color: #0f0; 
            font-size: 1.5rem; 
            margin-bottom: 15px; 
            animation: recordPulse 0.6s ease-in-out infinite alternate;
            text-shadow: 0 0 20px rgba(0,255,0,0.6);
        }
        @keyframes recordPulse { 
            0% { transform: scale(1); opacity: 0.9; }
            100% { transform: scale(1.08); opacity: 1; }
        }
        
        #name-input {
            background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(20,20,30,0.5));
            border: 2px solid rgba(255,136,0,0.6);
            color: #fff;
            padding: 14px 22px;
            font-size: 1.2rem;
            font-family: inherit;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 15px;
            width: 260px;
            outline: none;
            transition: all 0.2s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3), inset 0 2px 4px rgba(0,0,0,0.2);
        }
        #name-input:focus {
            border-color: #f90;
            box-shadow: 0 0 20px rgba(255,136,0,0.4), 0 4px 12px rgba(0,0,0,0.3), inset 0 2px 4px rgba(0,0,0,0.2);
        }
        #name-input::placeholder { color: #666; opacity: 1; }
        
        #minimap {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 140px;
            height: 140px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9), rgba(10,15,25,0.85));
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            z-index: 100;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
        }
        #minimap canvas { width: 100%; height: 100%; border-radius: 10px; }
        
        #debug-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border-radius: 5px;
            z-index: 200;
            pointer-events: none;
            display: none; /* Hidden by default for polished look */
        }
        
        #vignette {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 49;
            box-shadow: inset 0 0 120px rgba(0,0,0,0.4), inset 0 0 250px rgba(0,0,0,0.2);
        }
        
        #speed-lines {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.2s ease-out;
            background: 
                radial-gradient(ellipse at center, transparent 20%, rgba(0,0,0,0.35) 100%),
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    transparent 3px,
                    rgba(255,255,255,0.03) 3px,
                    rgba(255,255,255,0.03) 4px
                );
        }
        #speed-lines.active { opacity: 1; }
        
        /* Motion Blur Overlay - radial blur effect at high speeds */
        #motion-blur {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 48;
            opacity: 0;
            transition: opacity 0.15s ease-out;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(0,0,0,0.5) 100%);
        }
        
        /* Chromatic aberration container for boost effect */
        #game-container.chromatic-boost {
            filter: url(#chromatic-aberration);
        }
        
        /* Speed distortion effect - slight blur at extreme speeds */
        #game-container.speed-distort {
            filter: blur(0.5px);
        }
        
        /* Combined effects during boost */
        #game-container.chromatic-boost.speed-distort {
            filter: blur(0.5px) url(#chromatic-aberration);
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <h1>üõ∏ HOVERCRUISE</h1>
        <h2>GLOBAL RACING</h2>
        
        <button class="leaderboard-btn" onclick="showLeaderboard()">üèÜ LEADERBOARD</button>
        
        <div class="section-title">SELECT YOUR HOVERCRAFT</div>
        <div class="car-select">
            <div class="car-option selected" data-car="sports" onclick="selectCar(this)">
                <div class="car-emoji">üõ∏</div>
                <div class="car-name">PHANTOM X</div>
                <div class="car-stat" style="color:#0f0">‚ö° TOP SPEED</div>
            </div>
            <div class="car-option" data-car="muscle" onclick="selectCar(this)">
                <div class="car-emoji">üõ∏</div>
                <div class="car-name">NOVA BURST</div>
                <div class="car-stat" style="color:#ff0">üöÄ ACCELERATION</div>
            </div>
            <div class="car-option" data-car="suv" onclick="selectCar(this)">
                <div class="car-emoji">üõ∏</div>
                <div class="car-name">FLUX RIDER</div>
                <div class="car-stat" style="color:#f80">üõ°Ô∏è HANDLING</div>
            </div>
            <div class="car-option" data-car="truck" onclick="selectCar(this)">
                <div class="car-emoji">üõ∏</div>
                <div class="car-name">TITAN FORCE</div>
                <div class="car-stat" style="color:#f00">üí™ POWER</div>
            </div>
            <div class="car-option" data-car="exotic" onclick="selectCar(this)">
                <div class="car-emoji">üõ∏</div>
                <div class="car-name">NEBULA PRIME</div>
                <div class="car-stat" style="color:#0ff">‚ú® BALANCED</div>
            </div>
        </div>
        
        <div class="section-title">CHOOSE STARTING COUNTRY</div>
        <div class="country-select">
            <div class="country-option selected" data-country="usa" onclick="selectCountry(this)">
                <div class="flag">üá∫üá∏</div>
                <div class="name">USA</div>
            </div>
            <div class="country-option" data-country="japan" onclick="selectCountry(this)">
                <div class="flag">üáØüáµ</div>
                <div class="name">JAPAN</div>
            </div>
            <div class="country-option" data-country="germany" onclick="selectCountry(this)">
                <div class="flag">üá©üá™</div>
                <div class="name">GERMANY</div>
            </div>
            <div class="country-option" data-country="brazil" onclick="selectCountry(this)">
                <div class="flag">üáßüá∑</div>
                <div class="name">BRAZIL</div>
            </div>
            <div class="country-option" data-country="australia" onclick="selectCountry(this)">
                <div class="flag">üá¶üá∫</div>
                <div class="name">AUSTRALIA</div>
            </div>
            <div class="country-option" data-country="uae" onclick="selectCountry(this)">
                <div class="flag">üá¶üá™</div>
                <div class="name">UAE</div>
            </div>
            <div class="country-option" data-country="uk" onclick="selectCountry(this)">
                <div class="flag">üá¨üáß</div>
                <div class="name">UK</div>
            </div>
            <div class="country-option" data-country="italy" onclick="selectCountry(this)">
                <div class="flag">üáÆüáπ</div>
                <div class="name">ITALY</div>
            </div>
            <div class="country-option" data-country="egypt" onclick="selectCountry(this)">
                <div class="flag">üá™üá¨</div>
                <div class="name">EGYPT</div>
            </div>
        </div>
        
        <div class="controls-info">
            <span>‚ÜëW</span> Gas ¬∑ <span>‚ÜìS</span> Brake ¬∑ <span>‚Üê‚ÜíAD</span> Steer ¬∑ <span>SPACE</span> Nitro
        </div>
        
        <button class="btn" onclick="startGame()">START RACE</button>
    </div>
    
    <div id="leaderboard">
        <span class="close-btn" onclick="hideLeaderboard()">√ó</span>
        <h2>üèÜ TOP RACERS</h2>
        <table>
            <thead><tr><th class="rank">#</th><th>Name</th><th>Country</th><th class="score">Score</th></tr></thead>
            <tbody id="leaderboard-body"></tbody>
        </table>
    </div>
    
    <div id="game-over" class="hidden">
        <h1>TIME'S UP!</h1>
        <div class="new-record" id="new-record" style="display:none">üéâ NEW HIGH SCORE! üéâ</div>
        <div class="stats">
            Final Score: <span id="final-score">0</span><br>
            Distance: <span id="final-distance">0</span> miles<br>
            Cars Passed: <span id="final-passed">0</span><br>
            Countries Visited: <span id="final-countries">0</span>
        </div>
        <input type="text" id="name-input" placeholder="Enter your name" maxlength="12">
        <br>
        <button class="btn btn-small" onclick="submitScore()">SAVE SCORE</button>
        <button class="btn btn-small" onclick="restartGame()" style="background:linear-gradient(180deg,#666,#444);box-shadow:0 6px 0 #222;">SKIP</button>
    </div>
    
    <div id="game-container"></div>
    <div id="vignette"></div>
    <div id="speed-lines"></div>
    <div id="motion-blur"></div>
    
    <!-- SVG filter for chromatic aberration effect during boost -->
    <svg style="position: absolute; width: 0; height: 0;">
        <defs>
            <filter id="chromatic-aberration">
                <feColorMatrix type="matrix" result="red_" values="1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0" />
                <feOffset in="red_" dx="2" dy="0" result="red" />
                <feColorMatrix type="matrix" in="SourceGraphic" result="blue_" values="0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0" />
                <feOffset in="blue_" dx="-2" dy="0" result="blue" />
                <feBlend mode="screen" in="red" in2="blue" />
            </filter>
        </defs>
    </svg>
    
    <div id="hud">
        <div class="hud-left">
            <div class="hud-box" id="time-box">60</div>
            <div class="hud-box" id="checkpoint-box">CHECKPOINT: 500m</div>
            <div id="boost-container">
                <div id="boost-label">NITRO</div>
                <div id="boost-bar"><div id="boost-fill" style="width:100%"></div></div>
            </div>
        </div>
        <div class="hud-center">
            <div class="hud-box" id="country-box">
                <div class="flag">üá∫üá∏</div>
                <div>USA</div>
            </div>
        </div>
        <div class="hud-right">
            <div class="hud-box" id="score-box">‚òÖ 0</div>
            <div class="hud-box" id="speed-box">0 <span>MPH</span></div>
            <div class="hud-box" id="sound-toggle" onclick="toggleSound()" style="cursor:pointer;font-size:20px;padding:4px 10px;">üîä</div>
        </div>
    </div>
    
    <div id="announcer"></div>
    <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
    <div id="debug-info">Loading...</div>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        let scene, camera, renderer, sunLight;
        let playerCar;
        let traffic = [], roadSegments = [], scenery = [], particles = [];
        let gameRunning = false;
        let score = 0, time = 65, distance = 0, carsPassed = 0, topSpeed = 0, countriesVisited = 1; // Tuned: 65s starting time (was 60)
        let speed = 0, maxSpeed = 200, accel = 80, handling = 0.025;
        let steering = 0, playerX = 0;
        let boost = 100, isBoosting = false;
        let isAccel = false, isBrake = false, isLeft = false, isRight = false;
        
        // === WEIGHT TRANSFER PHYSICS ===
        let weightTransferPitch = 0;  // -1 (nose up/squat) to 1 (nose down/dive)
        let weightTransferRoll = 0;   // -1 (left lean) to 1 (right lean)
        let gripFactor = 1.0;         // 1.0 = full grip, lower = sliding
        
        let lastRoadZ = 0;
        let checkpointDist = 500;
        let clock = new THREE.Clock();
        let selectedCar = 'sports';
        let selectedCountry = 'usa';
        let currentCountry = 'usa';
        let crashCooldown = 0, screenShake = 0;
        let playerRecoveryTime = 0; // Reduced control after collision
        let visitedCountries = new Set();
        let roadCurve = 0, roadCurveTarget = 0; // For curving roads
        let mtFuji = null; // Background Mt. Fuji for Japan
        let clouds = []; // Background clouds
        let backgroundMountains = []; // Distant mountains for depth
        let checkpointGates = []; // Checkpoint gate structures
        let nextCheckpointSpawn = 400; // Distance to spawn next checkpoint gate
        let weatherParticles = []; // Atmosphere particles (dust, rain, sakura)
        let citySilhouettes = []; // Distant city skylines
        let iconicLandmarks = []; // Country-specific iconic structures
        let animatedWindmills = []; // Spinning windmills for countryside
        
        // Crash reaction system - tracks active wreck sites for traffic avoidance
        let crashSites = []; // { x, z, time } - active crashes traffic should react to
        
        // Emergency vehicle system
        let emergencyVehicles = []; // Active emergency vehicles with sirens
        
        // === AUDIO SYSTEM ===
        let audioContext = null;
        let audioInitialized = false;
        let engineOscillator = null;
        let engineGain = null;
        let engineFilter = null;
        let audioMuted = false;
        let lastEmergencySpawn = 0; // Distance since last emergency spawn
        
        // === PERFORMANCE OPTIMIZATION SYSTEMS ===
        
        // Geometry Cache - reuse common geometries instead of creating new ones
        const geometryCache = {
            // Wheel geometries (most commonly created)
            wheelCylinder: null,      // Standard wheel
            wheelCylinderLarge: null, // SUV/Pickup wheel
            hubcap: null,
            
            // Light geometries
            headlightSphere: null,
            taillightBox: null,
            
            // Common shapes
            unitBox: null,
            unitSphere: null,
            
            // Initialize on first use
            init() {
                if (this.wheelCylinder) return; // Already initialized
                
                this.wheelCylinder = new THREE.CylinderGeometry(0.44, 0.44, 0.28, 24);
                this.wheelCylinderLarge = new THREE.CylinderGeometry(0.52, 0.52, 0.35, 24);
                this.hubcap = new THREE.CylinderGeometry(0.25, 0.25, 0.05, 16);
                this.headlightSphere = new THREE.SphereGeometry(0.08, 8, 6);
                this.taillightBox = new THREE.BoxGeometry(0.04, 0.16, 0.22);
                this.unitBox = new THREE.BoxGeometry(1, 1, 1);
                this.unitSphere = new THREE.SphereGeometry(1, 12, 8);
            }
        };
        
        // Material Pool - reuse common materials
        const materialPool = {
            // Car body colors (pre-created for common colors)
            bodyMaterials: {},
            
            // Shared static materials
            glass: null,
            chrome: null,
            trim: null,
            wheel: null,
            headlight: null,
            taillight: null,
            
            init() {
                if (this.glass) return; // Already initialized
                
                this.glass = new THREE.MeshStandardMaterial({ 
                    color: 0x224466, metalness: 0.9, roughness: 0.1,
                    transparent: true, opacity: 0.7
                });
                this.chrome = new THREE.MeshStandardMaterial({ 
                    color: 0xaaaaaa, metalness: 1.0, roughness: 0.15 
                });
                this.trim = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
                this.wheel = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
                this.headlight = new THREE.MeshStandardMaterial({ 
                    color: 0xffffee, emissive: 0xffffcc, emissiveIntensity: 2.5, roughness: 0.2
                });
                this.taillight = new THREE.MeshStandardMaterial({ 
                    color: 0xff2200, emissive: 0xff1100, emissiveIntensity: 2.0, roughness: 0.3
                });
                
                // Pre-create common body colors
                const commonColors = [0xff0000, 0x0066ff, 0xffcc00, 0x00cc44, 0xff4400, 
                                      0xcc00cc, 0x00cccc, 0xffffff, 0x222222, 0x884400];
                commonColors.forEach(color => {
                    this.bodyMaterials[color] = new THREE.MeshStandardMaterial({ 
                        color, metalness: 0.7, roughness: 0.25 
                    });
                });
            },
            
            getBodyMaterial(color) {
                if (this.bodyMaterials[color]) return this.bodyMaterials[color];
                // Create and cache new color
                this.bodyMaterials[color] = new THREE.MeshStandardMaterial({ 
                    color, metalness: 0.7, roughness: 0.25 
                });
                return this.bodyMaterials[color];
            }
        };
        
        // Traffic Car Object Pool - recycle car objects
        const trafficCarPool = {
            available: [],    // Cars ready to be reused
            maxPoolSize: 30,  // Maximum cars to keep in pool
            
            // Get a car from pool or create new one
            acquire(color, style) {
                let car;
                
                // Try to reuse from pool
                if (this.available.length > 0) {
                    car = this.available.pop();
                    // Reset car state
                    this.resetCar(car, color);
                } else {
                    // Create new car
                    car = createCivilianCar(color, style);
                    car.userData.pooled = true;
                    car.userData.carStyle = style;
                }
                
                car.visible = true;
                return car;
            },
            
            // Return car to pool for reuse
            release(car) {
                if (!car.userData.pooled) {
                    // Not a pooled car, just remove normally
                    scene.remove(car);
                    return;
                }
                
                if (this.available.length < this.maxPoolSize) {
                    // Hide and store for reuse
                    car.visible = false;
                    car.position.set(0, -100, -1000); // Move off-screen
                    
                    // Reset state flags
                    car.userData.passed = false;
                    car.userData.crashed = false;
                    car.userData.spinOut = false;
                    car.userData.laneChanging = false;
                    car.userData.hasYielded = false;
                    
                    this.available.push(car);
                } else {
                    // Pool is full, remove from scene
                    scene.remove(car);
                }
            },
            
            // Reset car for reuse (change color if needed)
            resetCar(car, newColor) {
                // Reset userData
                car.userData.passed = false;
                car.userData.crashed = false;
                car.userData.spinOut = false;
                car.userData.laneChanging = false;
                car.userData.laneChangeProgress = 0;
                car.userData.laneChangeTimer = 2 + Math.random() * 8;
                car.userData.hasYielded = false;
                car.userData.yieldCheckTimer = 0;
                car.userData.blinkerPhase = 0;
                
                // Reset rotation
                car.rotation.y = Math.PI / 2;
                car.rotation.z = 0;
                car.rotation.x = 0;
                
                // Update body color if different (traverse main body meshes)
                // For now, reuse as-is - color change would require material swaps
            }
        };
        
        // DOM Update Cache - avoid redundant DOM writes
        // Includes defensive checks to prevent errors if DOM elements are missing
        const hudCache = {
            speed: -1,
            score: -1,
            time: -1,
            checkpoint: '',
            boost: -1,
            
            updateSpeed(value) {
                const rounded = Math.floor(value);
                if (rounded !== this.speed) {
                    this.speed = rounded;
                    const el = document.getElementById('speed-box');
                    if (el) el.innerHTML = rounded + ' <span>MPH</span>';
                }
            },
            
            updateScore(value) {
                if (value !== this.score) {
                    this.score = value;
                    const el = document.getElementById('score-box');
                    if (el) el.textContent = '‚òÖ ' + value;
                }
            },
            
            updateTime(value) {
                const rounded = Math.ceil(value);
                if (rounded !== this.time) {
                    this.time = rounded;
                    const el = document.getElementById('time-box');
                    if (el) {
                        el.textContent = rounded;
                        el.classList.toggle('warning', value < 10);
                    }
                }
            },
            
            updateCheckpoint(text) {
                if (text !== this.checkpoint) {
                    this.checkpoint = text;
                    const el = document.getElementById('checkpoint-box');
                    if (el) el.textContent = text;
                }
            },
            
            updateBoost(value) {
                const rounded = Math.round(value);
                if (rounded !== this.boost) {
                    this.boost = rounded;
                    const el = document.getElementById('boost-fill');
                    if (el) el.style.width = rounded + '%';
                }
            },
            
            reset() {
                this.speed = -1;
                this.score = -1;
                this.time = -1;
                this.checkpoint = '';
                this.boost = -1;
            }
        };
        
        // Optimized array cleanup - in-place removal to avoid creating new arrays
        function cleanupArray(arr, condition, onRemove) {
            let writeIndex = 0;
            for (let i = 0; i < arr.length; i++) {
                if (condition(arr[i])) {
                    // Keep this element
                    if (writeIndex !== i) {
                        arr[writeIndex] = arr[i];
                    }
                    writeIndex++;
                } else {
                    // Remove this element
                    if (onRemove) onRemove(arr[i]);
                }
            }
            arr.length = writeIndex; // Truncate array
        }
        
        // Track segment elevation for smooth transitions
        let lastSegmentElevation = 0;
        let lastSegmentBanking = 0;
        let lastSegmentWidth = 24;
        
        // Road surface tracking for smooth transitions
        let currentSurface = 'asphalt';
        let targetSurface = 'asphalt';
        let currentRoadWidth = 24;
        let targetRoadWidth = 24;
        
        // === END PERFORMANCE OPTIMIZATION SYSTEMS ===
        
        // Track features
        let elevation = 0, elevationTarget = 0, banking = 0;
        let trackSection = 0, sectionDistance = 0;
        let landmarks = [];
        let playerAirborne = false, airTime = 0, verticalVelocity = 0;
        
        const countries = {
            usa: { 
                name: 'PACIFIC THUNDER', flag: 'üá∫üá∏',
                skyTop: 0x1e90ff, skyBot: 0x87ceeb, fog: 0x88bbdd, fogDensity: 0.003,
                ground: 0x228b22, road: 0x2a2a2a, barrier: 0x888888,
                sceneryType: 'american', ambient: 0x8899aa,
                // Road surface properties
                roadType: 'highway', roadRoughness: 0.85, roadWear: 0.3, roadCracks: true,
                // Lighting - bright California sunshine
                sunColor: 0xfffaee, sunIntensity: 1.5, sunPos: { x: 30, y: 50, z: -30 },
                ambientColor: 0x8899aa, ambientIntensity: 0.5
            },
            japan: { 
                name: 'JAPAN', flag: 'üáØüáµ',
                skyTop: 0x5a8adb, skyBot: 0xd4c4e8, fog: 0xeeddee, fogDensity: 0.004,
                ground: 0x2a4a2a, road: 0x222222, barrier: 0xdd4422,
                sceneryType: 'tokyo', ambient: 0xccbbdd,
                roadType: 'city', roadRoughness: 0.75, roadWear: 0.2, roadCracks: false,
                // Lighting - soft morning light with sakura pink tint
                sunColor: 0xffeedd, sunIntensity: 1.3, sunPos: { x: 40, y: 40, z: -20 },
                ambientColor: 0xccbbdd, ambientIntensity: 0.55
            },
            germany: { 
                name: 'GERMANY', flag: 'üá©üá™',
                skyTop: 0x4a6fa5, skyBot: 0x8faabe, fog: 0x8faabe, fogDensity: 0.006,
                ground: 0x355e3b, road: 0x1a1a1a, barrier: 0x666666,
                sceneryType: 'european', ambient: 0x9999aa,
                // Autobahn - pristine, smooth, dark asphalt
                roadType: 'autobahn', roadRoughness: 0.6, roadWear: 0.05, roadCracks: false,
                // Lighting - cool overcast Central European
                sunColor: 0xddddee, sunIntensity: 1.0, sunPos: { x: 20, y: 45, z: -25 },
                ambientColor: 0x99aabb, ambientIntensity: 0.6
            },
            brazil: { 
                name: 'BRAZIL', flag: 'üáßüá∑',
                skyTop: 0x00bfff, skyBot: 0x87ceeb, fog: 0x90ee90, fogDensity: 0.008,
                ground: 0x228b22, road: 0x3a3a2a, barrier: 0xdaa520,
                sceneryType: 'tropical', ambient: 0xaaffaa,
                roadType: 'coastal', roadRoughness: 0.8, roadWear: 0.4, roadCracks: true,
                // Lighting - intense tropical sun, slightly golden
                sunColor: 0xfffadd, sunIntensity: 1.7, sunPos: { x: 10, y: 70, z: -15 },
                ambientColor: 0xaaffbb, ambientIntensity: 0.5
            },
            australia: { 
                name: 'AUSTRALIA', flag: 'üá¶üá∫',
                skyTop: 0xff8c00, skyBot: 0xffd700, fog: 0xdeb887, fogDensity: 0.006,
                ground: 0xcd853f, road: 0x2a2a2a, barrier: 0x8b4513,
                sceneryType: 'outback', ambient: 0xffcc88,
                // Outback - rough, sun-bleached, patchy repairs
                roadType: 'outback', roadRoughness: 0.95, roadWear: 0.7, roadCracks: true,
                // Lighting - harsh outback sun, orange tint, late afternoon
                sunColor: 0xffdd88, sunIntensity: 1.8, sunPos: { x: 50, y: 35, z: -40 },
                ambientColor: 0xddaa66, ambientIntensity: 0.45
            },
            uae: { 
                name: 'UAE', flag: 'üá¶üá™',
                skyTop: 0x0a1628, skyBot: 0x1a3a5c, fog: 0x1a2a3a, fogDensity: 0.004,
                ground: 0xf4d03f, road: 0x111111, barrier: 0xffd700,
                sceneryType: 'dubai', ambient: 0x334455,
                // Dubai - pristine black, glossy, premium
                roadType: 'premium', roadRoughness: 0.5, roadWear: 0.0, roadCracks: false,
                // Lighting - dramatic sunset/dusk, purple-orange sky
                sunColor: 0xff8844, sunIntensity: 1.3, sunPos: { x: 80, y: 15, z: -50 },
                ambientColor: 0x5566bb, ambientIntensity: 0.45
            },
            uk: { 
                name: 'UK', flag: 'üá¨üáß',
                skyTop: 0x5a6a7a, skyBot: 0x8a9aaa, fog: 0x9aaabb, fogDensity: 0.012,
                ground: 0x2a4a2a, road: 0x2a2a2a, barrier: 0xdc143c,
                sceneryType: 'british', ambient: 0x8899aa,
                roadType: 'motorway', roadRoughness: 0.8, roadWear: 0.35, roadCracks: true,
                // Lighting - overcast, diffuse, moody British grey with rain
                sunColor: 0xbbbbcc, sunIntensity: 0.75, sunPos: { x: 15, y: 60, z: -20 },
                ambientColor: 0x8899aa, ambientIntensity: 0.7
            },
            italy: { 
                name: 'ITALY', flag: 'üáÆüáπ',
                skyTop: 0x4169e1, skyBot: 0x87ceeb, fog: 0xffe4b5, fogDensity: 0.005,
                ground: 0x6b8e23, road: 0x2a2a2a, barrier: 0xffffff,
                sceneryType: 'mediterranean', ambient: 0xffffdd,
                roadType: 'coastal', roadRoughness: 0.75, roadWear: 0.25, roadCracks: false,
                // Lighting - warm Mediterranean golden hour
                sunColor: 0xffeebb, sunIntensity: 1.4, sunPos: { x: 45, y: 40, z: -35 },
                ambientColor: 0xddcc99, ambientIntensity: 0.5
            },
            egypt: { 
                name: 'EGYPT', flag: 'üá™üá¨',
                skyTop: 0xffd700, skyBot: 0xffa500, fog: 0xdaa520, fogDensity: 0.007,
                ground: 0xdaa520, road: 0x3a3020, barrier: 0xd4af37,
                sceneryType: 'desert', ambient: 0xffeeaa,
                // Desert road - sand-dusted, weathered
                roadType: 'desert', roadRoughness: 0.9, roadWear: 0.5, roadCracks: true,
                // Lighting - intense desert sun, yellow-white, harsh shadows
                sunColor: 0xffffcc, sunIntensity: 2.0, sunPos: { x: 5, y: 75, z: -10 },
                ambientColor: 0xddcc88, ambientIntensity: 0.4
            }
        };
        
        // CAR STATS - Tuned for arcade-style responsive handling
        // maxSpeed: Higher values for that exhilarating speed feeling
        // accel: Punchy acceleration for immediate response
        // handling: Higher = sharper steering (was way too low before)
        const carStats = {
            sports: { maxSpeed: 290, accel: 140, handling: 0.055, color: 0xff0000 },   // Fast & nimble
            muscle: { maxSpeed: 260, accel: 180, handling: 0.042, color: 0x0044cc },   // Raw power, decent handling
            suv: { maxSpeed: 220, accel: 120, handling: 0.065, color: 0x006633 },      // Best handling, lower speed
            truck: { maxSpeed: 210, accel: 160, handling: 0.048, color: 0x444444 },    // Powerful, balanced
            exotic: { maxSpeed: 280, accel: 155, handling: 0.052, color: 0xff8800 }    // Balanced premium
        };
        
        // Helper to safely dispose of Three.js objects to prevent memory leaks
        function disposeObject(obj) {
            if (!obj) return;
            
            // Recursively dispose children first
            if (obj.children && obj.children.length > 0) {
                // Create a copy of children array since we're modifying it
                const children = [...obj.children];
                children.forEach(child => disposeObject(child));
            }
            
            // Dispose geometry
            if (obj.geometry) {
                obj.geometry.dispose();
            }
            
            // Dispose material(s)
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach(mat => {
                        if (mat.map) mat.map.dispose();
                        if (mat.lightMap) mat.lightMap.dispose();
                        if (mat.bumpMap) mat.bumpMap.dispose();
                        if (mat.normalMap) mat.normalMap.dispose();
                        if (mat.specularMap) mat.specularMap.dispose();
                        if (mat.envMap) mat.envMap.dispose();
                        mat.dispose();
                    });
                } else {
                    if (obj.material.map) obj.material.map.dispose();
                    if (obj.material.lightMap) obj.material.lightMap.dispose();
                    if (obj.material.bumpMap) obj.material.bumpMap.dispose();
                    if (obj.material.normalMap) obj.material.normalMap.dispose();
                    if (obj.material.specularMap) obj.material.specularMap.dispose();
                    if (obj.material.envMap) obj.material.envMap.dispose();
                    obj.material.dispose();
                }
            }
        }
        
        // Helper to safely remove and dispose an object from scene
        function removeAndDispose(obj) {
            if (!obj) return;
            scene.remove(obj);
            disposeObject(obj);
        }
        
        function init() {
            // Initialize performance optimization systems
            geometryCache.init();
            materialPool.init();
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 11); // Zoomed out view
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            createLighting();
            setCountry('usa');
            
            // Preload GLTF car model
            loadGLTFCar().then(() => {
                createPlayerCar();
            });
            
            // Just use flat road segments (removed duplicate tube track)
            generateInitialRoad();
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('keydown', onKeyDown); // Fallback
            window.addEventListener('keyup', onKeyUp);     // Fallback
            window.addEventListener('resize', onResize);
            setupTouchControls(); // Mobile support
            
            loadLeaderboard();
            animate();
        }
        
        function createLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            
            sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(30, 50, -30);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 10;
            sunLight.shadow.camera.far = 300;
            sunLight.shadow.camera.left = -80;
            sunLight.shadow.camera.right = 80;
            sunLight.shadow.camera.top = 80;
            sunLight.shadow.camera.bottom = -80;
            scene.add(sunLight);
            
            const fill = new THREE.DirectionalLight(0x4466aa, 0.3);
            fill.position.set(-30, 20, 30);
            scene.add(fill);
        }
        
        function setCountry(countryId) {
            currentCountry = countryId;
            const c = countries[countryId];
            
            // FUTURISTIC NIGHT SKY WITH STARS
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            if (countryId === 'japan') {
                // JAPAN - Van Gogh Starry Night style with pink stars
                // Swirly dark blue background
                const grad = ctx.createLinearGradient(0, 0, 0, 512);
                grad.addColorStop(0, '#0a0520');
                grad.addColorStop(0.3, '#1a1040');
                grad.addColorStop(0.6, '#2a2060');
                grad.addColorStop(1, '#1a1535');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 512, 512);
                
                // Draw swirly patterns (Van Gogh style)
                ctx.strokeStyle = 'rgba(60, 80, 150, 0.4)';
                ctx.lineWidth = 8;
                for (let i = 0; i < 12; i++) {
                    const cx = Math.random() * 512;
                    const cy = Math.random() * 350;
                    const radius = 30 + Math.random() * 60;
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 3; a += 0.1) {
                        const r = radius + a * 8;
                        const x = cx + Math.cos(a) * r;
                        const y = cy + Math.sin(a) * r;
                        if (a === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // More swirls in lighter blue
                ctx.strokeStyle = 'rgba(100, 120, 200, 0.3)';
                ctx.lineWidth = 5;
                for (let i = 0; i < 8; i++) {
                    const cx = Math.random() * 512;
                    const cy = Math.random() * 300;
                    ctx.beginPath();
                    for (let a = 0; a < Math.PI * 2.5; a += 0.1) {
                        const r = 20 + a * 10;
                        const x = cx + Math.cos(a) * r;
                        const y = cy + Math.sin(a) * r;
                        if (a === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                // Pink/magenta stars
                for (let i = 0; i < 80; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 400;
                    const size = 1 + Math.random() * 4;
                    const colors = ['#ff66aa', '#ff88cc', '#ffaadd', '#ff44aa', '#ff99bb'];
                    ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                    // Add glow
                    if (size > 2) {
                        ctx.fillStyle = 'rgba(255, 150, 200, 0.3)';
                        ctx.beginPath();
                        ctx.arc(x, y, size * 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Big glowing moon/star
                ctx.fillStyle = 'rgba(255, 200, 230, 0.4)';
                ctx.beginPath();
                ctx.arc(380, 80, 50, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ffeeff';
                ctx.beginPath();
                ctx.arc(380, 80, 25, 0, Math.PI * 2);
                ctx.fill();
                
            } else {
                // Default - Night sky with stars
                const grad = ctx.createLinearGradient(0, 0, 0, 512);
                grad.addColorStop(0, '#050510');
                grad.addColorStop(0.5, '#0a0a20');
                grad.addColorStop(1, '#151530');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 512, 512);
                
                // Stars
                for (let i = 0; i < 150; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 450;
                    const size = Math.random() * 2;
                    const brightness = 0.5 + Math.random() * 0.5;
                    ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Brighter stars with glow
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * 512;
                    const y = Math.random() * 350;
                    ctx.fillStyle = 'rgba(200, 220, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            scene.background = new THREE.CanvasTexture(canvas);
            scene.fog = new THREE.FogExp2(0x0a0a15, 0.004); // Dark fog for night
            
            document.getElementById('country-box').innerHTML = `<div class="flag">${c.flag}</div><div>${c.name}</div>`;
            
            // Remove old Mt. Fuji if exists (with disposal)
            if (mtFuji) {
                removeAndDispose(mtFuji);
                mtFuji = null;
            }
            
            // Remove old clouds (with disposal to prevent memory leaks)
            clouds.forEach(cloud => removeAndDispose(cloud));
            clouds = [];
            
            // Add ocean for coastal tracks (USA)
            if (countryId === 'usa') {
                const oceanGeo = new THREE.PlaneGeometry(800, 800);
                const oceanMat = new THREE.MeshStandardMaterial({ 
                    color: 0x006994,
                    metalness: 0.3,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.9
                });
                const ocean = new THREE.Mesh(oceanGeo, oceanMat);
                ocean.rotation.x = -Math.PI / 2;
                ocean.position.set(200, -5, -200);
                scene.add(ocean);
                clouds.push(ocean); // Reuse clouds array for cleanup
            }
            
            // Add clouds
            const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9 });
            for (let i = 0; i < 15; i++) {
                const cloudGroup = new THREE.Group();
                
                // Cloud made of multiple spheres
                for (let j = 0; j < 5; j++) {
                    const puff = new THREE.Mesh(
                        new THREE.SphereGeometry(8 + Math.random() * 10, 8, 8),
                        cloudMat
                    );
                    puff.position.set(
                        (Math.random() - 0.5) * 20,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 10
                    );
                    cloudGroup.add(puff);
                }
                
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 400,
                    50 + Math.random() * 30,
                    -100 - Math.random() * 200
                );
                scene.add(cloudGroup);
                clouds.push(cloudGroup);
            }
            
            // Add Mt. Fuji for Japan
            if (countryId === 'japan') {
                mtFuji = new THREE.Group();
                
                // Main mountain
                const mountainMat = new THREE.MeshStandardMaterial({ color: 0x4a5568, flatShading: true });
                const mountain = new THREE.Mesh(
                    new THREE.ConeGeometry(80, 60, 8),
                    mountainMat
                );
                mountain.position.set(0, 30, -250);
                mtFuji.add(mountain);
                
                // Snow cap
                const snowMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const snowCap = new THREE.Mesh(
                    new THREE.ConeGeometry(35, 20, 8),
                    snowMat
                );
                snowCap.position.set(0, 50, -250);
                mtFuji.add(snowCap);
                
                // Snow detail
                const snow2 = new THREE.Mesh(
                    new THREE.ConeGeometry(45, 15, 8),
                    snowMat
                );
                snow2.position.set(0, 42, -250);
                mtFuji.add(snow2);
                
                scene.add(mtFuji);
            }
            
            // Create background mountains for depth
            createBackgroundMountains();
            
            // Create weather/atmosphere particles
            createWeatherParticles();
            
            // Clear old iconic landmarks (with disposal)
            iconicLandmarks.forEach(l => removeAndDispose(l));
            iconicLandmarks = [];
            
            // Clear old windmills (with disposal)
            animatedWindmills.forEach(w => removeAndDispose(w));
            animatedWindmills = [];
            
            // === COUNTRY-SPECIFIC LIGHTING ===
            // Apply sun color, position, and intensity based on country atmosphere
            if (sunLight && c.sunColor !== undefined) {
                sunLight.color.setHex(c.sunColor);
                sunLight.intensity = c.sunIntensity || 1.5;
                if (c.sunPos) {
                    sunLight.position.set(c.sunPos.x, c.sunPos.y, c.sunPos.z);
                }
            }
            
            // Update ambient light for country atmosphere
            const ambientLights = scene.children.filter(child => child.isAmbientLight);
            ambientLights.forEach(light => {
                if (c.ambientColor !== undefined) {
                    light.color.setHex(c.ambientColor);
                    light.intensity = c.ambientIntensity || 0.5;
                }
            });
            
            // Adjust renderer tone mapping exposure for atmosphere
            if (renderer) {
                if (countryId === 'uk') {
                    renderer.toneMappingExposure = 0.9; // Moody, overcast
                } else if (countryId === 'uae') {
                    renderer.toneMappingExposure = 1.0; // Dramatic dusk
                } else if (countryId === 'egypt' || countryId === 'australia') {
                    renderer.toneMappingExposure = 1.4; // Harsh bright sun
                } else {
                    renderer.toneMappingExposure = 1.2; // Standard
                }
            }
        }
        
        function selectCar(el) {
            document.querySelectorAll('.car-option').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            selectedCar = el.dataset.car;
        }
        
        function selectCountry(el) {
            document.querySelectorAll('.country-option').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            selectedCountry = el.dataset.country;
        }
        
        // Smooth car with bezier curves and high-def wheels
        function createWedgeCar(color) {
            const carGroup = new THREE.Group();
            
            // --- 1. THE BODY (With Bezier curves for smooth lines) ---
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.lineTo(4.5, 0);     // Bottom
            shape.lineTo(4.5, 1.4);   // Trunk Back
            shape.lineTo(3.5, 1.4);   // Trunk Deck
            shape.bezierCurveTo(3.5, 1.4, 3.0, 2.2, 2.5, 2.2);  // Curved rear window
            shape.lineTo(1.2, 2.2);   // Roof
            shape.bezierCurveTo(1.2, 2.2, 0.5, 1.5, 0, 0.8);    // Curved windshield
            shape.lineTo(0, 0);       // Nose
            
            const extrudeSettings = {
                steps: 1,
                depth: 2.4,           // Car Width
                bevelEnabled: true,   // Rounds the sharp edges
                bevelThickness: 0.2,
                bevelSize: 0.2,
                bevelSegments: 4      // Smoothness of the round edge
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Shiny Car Paint Material
            const bodyMat = new THREE.MeshStandardMaterial({
                color: color || 0xff0000,
                roughness: 0.2,       // Shiny
                metalness: 0.6        // Metallic reflection
            });
            
            const carMesh = new THREE.Mesh(geometry, bodyMat);
            carMesh.position.set(-2.2, 0.5, -1.2);  // Center it
            carMesh.castShadow = true;
            carGroup.add(carMesh);
            
            // Headlights
            const headlightMat = new THREE.MeshBasicMaterial({ color: 0xffffdd });
            [-0.8, 0.8].forEach(z => {
                const hl = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 12), headlightMat);
                hl.position.set(-2.2, 1.0, z);
                carGroup.add(hl);
            });
            
            // Taillights
            const taillightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            [-0.8, 0.8].forEach(z => {
                const tl = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.25, 0.5), taillightMat);
                tl.position.set(2.3, 1.4, z);
                carGroup.add(tl);
            });
            
            // --- 2. THE WHEELS (High Definition - 32 segments) ---
            const wheelGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.5, 32);
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            
            // Hubcap (shiny center)
            const capGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.52, 16);
            const capMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 1.0 });
            
            // Store wheel references for animation
            carGroup.userData.wheels = [];
            carGroup.userData.wheelRadius = 0.6;
            
            function addWheel(x, z, isFront) {
                // Create wheel group for rotation
                const wheelGroup = new THREE.Group();
                wheelGroup.position.set(x, 0.6, z);
                wheelGroup.userData.isFront = isFront;
                
                // Tire
                const w = new THREE.Mesh(wheelGeo, wheelMat);
                w.rotation.x = Math.PI / 2;
                w.castShadow = true;
                wheelGroup.add(w);
                
                // Hubcap
                const c = new THREE.Mesh(capGeo, capMat);
                c.rotation.x = Math.PI / 2;
                wheelGroup.add(c);
                
                carGroup.add(wheelGroup);
                carGroup.userData.wheels.push(wheelGroup);
            }
            
            addWheel(-1.4, 1.6, true);    // Front Right
            addWheel(-1.4, -1.6, true);   // Front Left
            addWheel(1.6, 1.6, false);    // Rear Right
            addWheel(1.6, -1.6, false);   // Rear Left
            
            return carGroup;
        }
        
        const carColorValues = {
            sports: 0xff0000,
            muscle: 0x0044cc,
            suv: 0x006633,
            truck: 0x444444,
            exotic: 0xff8800
        };
        
        let gltfCarModel = null;
        let gltfLoader = null;
        let coloredCarTextures = {}; // Store colored texture variants
        const carColors = ['red', 'blue', 'green', 'yellow', 'orange', 'purple', 'teal'];
        
        function loadGLTFCar() {
            return new Promise((resolve) => {
                try {
                    gltfLoader = new THREE.GLTFLoader();
                    const textureLoader = new THREE.TextureLoader();
                    
                    // Load colored texture variants for NPC cars
                    carColors.forEach(color => {
                        textureLoader.load(
                            `/monster-truck/models/textures/Murphy92_${color}_baseColor.jpeg`,
                            (texture) => {
                                texture.flipY = false; // GLTF textures don't flip
                                coloredCarTextures[color] = texture;
                                console.log(`Loaded ${color} car texture`);
                            },
                            undefined,
                            (err) => console.log(`Could not load ${color} texture`)
                        );
                    });
                    
                    gltfLoader.load('/monster-truck/models/scene.gltf', 
                        (gltf) => {
                            gltfCarModel = gltf.scene;
                            
                            // Scale the cop car appropriately
                            gltfCarModel.scale.set(0.8, 0.8, 0.8);
                            
                            // Enable shadows on all meshes
                            gltfCarModel.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            console.log('GLTF cop car loaded successfully!');
                            resolve(gltfCarModel);
                        },
                        (progress) => {
                            console.log('Loading car:', Math.round(progress.loaded / progress.total * 100) + '%');
                        },
                        (error) => {
                            console.error('GLTF load error:', error);
                            resolve(null);
                        }
                    );
                } catch (e) {
                    console.error('GLTFLoader not available:', e);
                    resolve(null);
                }
            });
        }
        
        function createPlayerCar() {
            if (playerCar) scene.remove(playerCar);
            
            const stats = carStats[selectedCar];
            maxSpeed = stats.maxSpeed;
            accel = stats.accel;
            handling = stats.handling;
            
            // Try to use GLTF model, fallback to wedge car
            if (gltfCarModel) {
                playerCar = gltfCarModel.clone();
                playerCar.scale.set(1.0, 1.0, 1.0);
                playerCar.rotation.x = 0;
                playerCar.rotation.z = 0;
                // GLTF model faces +X, we want it facing -Z (away from camera)
                // Math.PI/2 = 90¬∞, shows back of car (taillights toward camera)
                playerCar.rotation.y = Math.PI / 2;
                playerCar.position.set(0, 0.7, 0); // Raised for hover effect
                
                // Hide wheels and add hover pads
                playerCar.traverse((child) => {
                    if (child.isMesh && child.name && child.name.toLowerCase().includes('wheel')) {
                        child.visible = false;
                    }
                    if (child.isMesh && child.name && child.name.toLowerCase().includes('tire')) {
                        child.visible = false;
                    }
                });
                
                // Add hover pads (glowing anti-gravity emitters)
                const hoverGlowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.8 
                });
                const hoverCoreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const hoverPadMat = new THREE.MeshStandardMaterial({ 
                    color: 0x222233, 
                    metalness: 0.8, 
                    roughness: 0.3 
                });
                
                // Hover pad positions (relative to car, which faces +X originally)
                const hoverPositions = [
                    { x: -1.8, y: -0.3, z: 0.8 },   // Front left
                    { x: -1.8, y: -0.3, z: -0.8 },  // Front right
                    { x: 1.5, y: -0.3, z: 0.8 },    // Rear left
                    { x: 1.5, y: -0.3, z: -0.8 }    // Rear right
                ];
                
                hoverPositions.forEach(pos => {
                    // Hover pad housing
                    const padGeo = new THREE.CylinderGeometry(0.35, 0.4, 0.15, 16);
                    const pad = new THREE.Mesh(padGeo, hoverPadMat);
                    pad.position.set(pos.x, pos.y, pos.z);
                    playerCar.add(pad);
                    
                    // Outer glow ring
                    const ringGeo = new THREE.TorusGeometry(0.32, 0.04, 8, 24);
                    const ring = new THREE.Mesh(ringGeo, hoverGlowMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.set(pos.x, pos.y - 0.08, pos.z);
                    playerCar.add(ring);
                    
                    // Inner glow core
                    const coreGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 16);
                    const core = new THREE.Mesh(coreGeo, hoverCoreMat);
                    core.position.set(pos.x, pos.y - 0.1, pos.z);
                    playerCar.add(core);
                });
                
                // Underside glow effect
                const underglowGeo = new THREE.PlaneGeometry(3.5, 1.8);
                const underglowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const underglow = new THREE.Mesh(underglowGeo, underglowMat);
                underglow.rotation.x = Math.PI / 2;
                underglow.position.set(0, -0.4, 0);
                playerCar.add(underglow);
            } else {
                // Create epic hovercraft spaceship racer
                playerCar = new THREE.Group();
                const shipColor = carColorValues[selectedCar] || 0x00aaff;
                
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: shipColor, 
                    metalness: 0.9, 
                    roughness: 0.1 
                });
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const hotGlowMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff4400, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const darkMat = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a15, 
                    metalness: 0.8, 
                    roughness: 0.2 
                });
                const chromeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    metalness: 1.0, 
                    roughness: 0.05 
                });
                const accentMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff3300, 
                    emissive: 0xff2200,
                    emissiveIntensity: 0.8,
                    metalness: 0.5, 
                    roughness: 0.3 
                });
                
                // Main hull - aggressive angular shape
                const hullGeo = new THREE.CylinderGeometry(1.4, 2.0, 0.4, 6);
                const hull = new THREE.Mesh(hullGeo, bodyMat);
                hull.rotation.y = Math.PI / 6;
                hull.position.set(0, 0.55, 0);
                playerCar.add(hull);
                
                // Lower hull extension
                const lowerHullGeo = new THREE.CylinderGeometry(1.8, 1.6, 0.25, 6);
                const lowerHull = new THREE.Mesh(lowerHullGeo, darkMat);
                lowerHull.rotation.y = Math.PI / 6;
                lowerHull.position.set(0, 0.35, 0);
                playerCar.add(lowerHull);
                
                // Cockpit canopy - fighter jet style
                const canopyGeo = new THREE.SphereGeometry(0.55, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.6);
                const canopyMat = new THREE.MeshStandardMaterial({ 
                    color: 0x001133, 
                    metalness: 0.98, 
                    roughness: 0.01,
                    transparent: true,
                    opacity: 0.7
                });
                const canopy = new THREE.Mesh(canopyGeo, canopyMat);
                canopy.position.set(-0.4, 0.75, 0);
                canopy.scale.set(1.3, 0.8, 1);
                playerCar.add(canopy);
                
                // Canopy frame
                const frameGeo = new THREE.TorusGeometry(0.48, 0.03, 8, 24);
                const frame = new THREE.Mesh(frameGeo, chromeMat);
                frame.position.set(-0.4, 0.72, 0);
                frame.rotation.x = Math.PI / 2;
                frame.scale.set(1.3, 1, 0.8);
                playerCar.add(frame);
                
                // Front nose removed for cleaner look
                
                // Side fins - simple flat wings
                [-1, 1].forEach(side => {
                    // Simple flat wing
                    const wingGeo = new THREE.BoxGeometry(1.5, 0.06, 0.8);
                    const wing = new THREE.Mesh(wingGeo, bodyMat);
                    wing.position.set(0, 0.5, side * 1.3);
                    playerCar.add(wing);
                    
                    // Wing edge glow
                    const edgeGeo = new THREE.BoxGeometry(1.6, 0.04, 0.02);
                    const edge = new THREE.Mesh(edgeGeo, glowMat);
                    edge.position.set(0, 0.52, side * 1.7);
                    playerCar.add(edge);
                });
                
                // Rear engine block removed for cleaner look
                
                // NITRO FLAMES - positioned at back center of ship
                playerCar.userData.nitroFlames = [];
                const flameGroup = new THREE.Group();
                flameGroup.visible = false;
                
                // Single large flame from center back
                // Fire layers - white hot core
                const coreGeo = new THREE.CylinderGeometry(0.15, 0.08, 1.5, 8);
                const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.95 });
                const core = new THREE.Mesh(coreGeo, coreMat);
                core.rotation.x = Math.PI / 2;
                core.position.set(0, 0.55, 2.0);
                flameGroup.add(core);
                
                // Yellow flame layer
                const yellowGeo = new THREE.CylinderGeometry(0.25, 0.12, 2.0, 8);
                const yellowMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.85 });
                const yellow = new THREE.Mesh(yellowGeo, yellowMat);
                yellow.rotation.x = Math.PI / 2;
                yellow.position.set(0, 0.55, 2.3);
                flameGroup.add(yellow);
                
                // Orange flame layer
                const orangeGeo = new THREE.CylinderGeometry(0.35, 0.18, 2.5, 8);
                const orangeMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.75 });
                const orange = new THREE.Mesh(orangeGeo, orangeMat);
                orange.rotation.x = Math.PI / 2;
                orange.position.set(0, 0.55, 2.6);
                flameGroup.add(orange);
                
                // Red outer flame
                const redGeo = new THREE.CylinderGeometry(0.45, 0.25, 3.0, 8);
                const redMat = new THREE.MeshBasicMaterial({ color: 0xff2200, transparent: true, opacity: 0.6 });
                const red = new THREE.Mesh(redGeo, redMat);
                red.rotation.x = Math.PI / 2;
                red.position.set(0, 0.55, 3.0);
                flameGroup.add(red);
                
                // Outer glow
                const glowOuterGeo = new THREE.CylinderGeometry(0.55, 0.3, 3.5, 8);
                const glowOuterMat = new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.35 });
                const glowOuter = new THREE.Mesh(glowOuterGeo, glowOuterMat);
                glowOuter.rotation.x = Math.PI / 2;
                glowOuter.position.set(0, 0.55, 3.4);
                flameGroup.add(glowOuter);
                
                playerCar.add(flameGroup);
                playerCar.userData.nitroFlames.push(flameGroup);
                
                // Hover pads with pulsing glow
                const hoverPositions = [
                    { x: -1.3, z: 0.9 },
                    { x: -1.3, z: -0.9 },
                    { x: 1.0, z: 0.9 },
                    { x: 1.0, z: -0.9 }
                ];
                hoverPositions.forEach(pos => {
                    // Hover housing
                    const housingGeo = new THREE.CylinderGeometry(0.25, 0.3, 0.15, 12);
                    const housing = new THREE.Mesh(housingGeo, darkMat);
                    housing.position.set(pos.x, 0.25, pos.z);
                    playerCar.add(housing);
                    
                    // Glow ring
                    const ringGeo = new THREE.TorusGeometry(0.28, 0.05, 8, 20);
                    const ring = new THREE.Mesh(ringGeo, glowMat);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.set(pos.x, 0.18, pos.z);
                    playerCar.add(ring);
                });
                
                // Racing stripes (glowing)
                const stripeGeo = new THREE.BoxGeometry(4, 0.02, 0.08);
                [-0.35, 0.35].forEach(z => {
                    const stripe = new THREE.Mesh(stripeGeo, accentMat);
                    stripe.position.set(-0.5, 0.76, z);
                    playerCar.add(stripe);
                });
                
                // Underglow effect
                const underglowGeo = new THREE.CircleGeometry(1.7, 24);
                const underglowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                const underglow = new THREE.Mesh(underglowGeo, underglowMat);
                underglow.rotation.x = Math.PI / 2;
                underglow.position.set(0, 0.2, 0);
                playerCar.add(underglow);
                
                // Position for racing
                playerCar.rotation.y = Math.PI;
                playerCar.position.set(0, 0.35, 0);
            }
            
            scene.add(playerCar);
        }
        
        // Curved track with CatmullRom spline
        let trackCurve = null;
        let trackMesh = null;
        
        function createCruisinTrack() {
            // Define track waypoints with elevation changes
            trackCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),           // Start
                new THREE.Vector3(0, 0, -150),        // Straightaway
                new THREE.Vector3(30, 8, -300),       // Gentle climb + curve
                new THREE.Vector3(80, 15, -450),      // Peak of hill
                new THREE.Vector3(50, 5, -600),       // Downhill
                new THREE.Vector3(-30, 0, -750),      // Left turn
                new THREE.Vector3(-80, -5, -900),     // Dip
                new THREE.Vector3(-50, 0, -1050),     // Recovery
                new THREE.Vector3(0, 5, -1200),       // Back center
                new THREE.Vector3(40, 10, -1350),     // Another hill
                new THREE.Vector3(0, 0, -1500),       // Continue...
            ]);
            trackCurve.closed = false;
            
            // Create road mesh with TubeGeometry
            const geometry = new THREE.TubeGeometry(trackCurve, 300, 12, 8, false);
            
            // Road texture with stripes
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Asphalt
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, 256, 256);
            
            // Edge lines (white)
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(10, 0, 8, 256);
            ctx.fillRect(238, 0, 8, 256);
            
            // Center dashes (yellow)
            ctx.fillStyle = '#ffcc00';
            for (let y = 0; y < 256; y += 40) {
                ctx.fillRect(120, y, 16, 25);
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 100);
            
            const material = new THREE.MeshStandardMaterial({
                map: tex,
                side: THREE.DoubleSide,
                roughness: 0.8
            });
            
            trackMesh = new THREE.Mesh(geometry, material);
            trackMesh.scale.set(1, 0.05, 1); // Flatten the tube to make it a road
            trackMesh.receiveShadow = true;
            
            return trackMesh;
        }
        
        // Create asphalt texture with grain/variation (cached per country for performance)
        let asphaltTextureCache = {};
        let roadMaterialCache = {};  // Cache road materials per country
        
        // Shared static materials for road markings (created once, reused everywhere)
        let sharedRoadMaterials = null;
        function getSharedRoadMaterials() {
            if (sharedRoadMaterials) return sharedRoadMaterials;
            
            sharedRoadMaterials = {
                // NEON CYAN edge lines - bright glow
                white: new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.95
                }),
                // NEON MAGENTA center dashes - hot pink glow
                yellow: new THREE.MeshBasicMaterial({ 
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.95
                }),
                // NEON BLUE rumble strip
                red: new THREE.MeshBasicMaterial({ 
                    color: 0x0066ff,
                    transparent: true,
                    opacity: 0.9
                }),
                // NEON PURPLE rumble strip
                curbWhite: new THREE.MeshBasicMaterial({ 
                    color: 0x8800ff,
                    transparent: true,
                    opacity: 0.9
                }),
                // Dark posts with glow accent
                post: new THREE.MeshStandardMaterial({ 
                    color: 0x222233,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.3
                }),
                // Neon orange reflector
                reflector: new THREE.MeshBasicMaterial({ 
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.95
                })
            };
            return sharedRoadMaterials;
        }
        
        // Cache terrain/shoulder materials per country
        let terrainMaterialCache = {};
        function getTerrainMaterials(countryId) {
            const cid = countryId || currentCountry;
            if (terrainMaterialCache[cid]) return terrainMaterialCache[cid];
            
            const desertCountries = ['uae', 'egypt', 'australia'];
            const tropicalCountries = ['brazil'];
            
            // FUTURISTIC terrain - dark with neon grid feel
            let terrainColor = 0x1a1a2e; // Dark blue-black
            const shoulderColor = 0x252540; // Slightly lighter dark
            
            terrainMaterialCache[cid] = {
                ground: new THREE.MeshStandardMaterial({ color: terrainColor, roughness: 1 }),
                shoulder: new THREE.MeshStandardMaterial({ color: shoulderColor, roughness: 1 })
            };
            return terrainMaterialCache[cid];
        }
        
        // Get cached road material for a country (texture + roughness)
        function getRoadMaterial(countryId) {
            const cid = countryId || currentCountry;
            if (roadMaterialCache[cid]) return roadMaterialCache[cid];
            
            // FUTURISTIC ROAD - clean white/light gray with slight glow
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xe8e8f0,
                roughness: 0.3,
                metalness: 0.4,
                emissive: 0x111122,
                emissiveIntensity: 0.1
            });
            roadMaterialCache[cid] = mat;
            return mat;
        }
        
        // Cobblestone texture for Italian village sections
        let cobblestoneTextureCache = null;
        function getCobblestoneTexture() {
            if (cobblestoneTextureCache) return cobblestoneTextureCache;
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Base stone color
            ctx.fillStyle = '#706050';
            ctx.fillRect(0, 0, 256, 256);
            
            // Draw cobblestones in a pattern
            const stoneColors = ['#5a4a3a', '#6b5b4b', '#7a6a5a', '#8a7a6a', '#554433'];
            const stoneSize = 18;
            const gap = 3;
            
            for (let y = 0; y < 256; y += stoneSize + gap) {
                const offset = ((y / (stoneSize + gap)) % 2) * (stoneSize / 2); // Brick pattern offset
                for (let x = -stoneSize; x < 256 + stoneSize; x += stoneSize + gap) {
                    const sx = x + offset + (Math.random() - 0.5) * 3;
                    const sy = y + (Math.random() - 0.5) * 3;
                    const sw = stoneSize + (Math.random() - 0.5) * 4;
                    const sh = stoneSize + (Math.random() - 0.5) * 4;
                    
                    // Stone fill
                    ctx.fillStyle = stoneColors[Math.floor(Math.random() * stoneColors.length)];
                    ctx.beginPath();
                    ctx.roundRect(sx, sy, sw, sh, 4);
                    ctx.fill();
                    
                    // Stone highlight (top-left)
                    ctx.fillStyle = 'rgba(255,255,255,0.15)';
                    ctx.beginPath();
                    ctx.roundRect(sx, sy, sw * 0.4, sh * 0.3, 2);
                    ctx.fill();
                    
                    // Stone shadow (bottom-right)
                    ctx.fillStyle = 'rgba(0,0,0,0.25)';
                    ctx.beginPath();
                    ctx.roundRect(sx + sw * 0.5, sy + sh * 0.6, sw * 0.5, sh * 0.4, 2);
                    ctx.fill();
                }
            }
            
            // Add mortar lines (dark gaps between stones)
            ctx.strokeStyle = '#2a2015';
            ctx.lineWidth = gap;
            for (let y = 0; y < 256; y += stoneSize + gap) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(256, y);
                ctx.stroke();
            }
            
            // Add some wear/dirt patches
            ctx.fillStyle = 'rgba(40,30,20,0.2)';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.ellipse(Math.random() * 256, Math.random() * 256, 15 + Math.random() * 20, 10 + Math.random() * 15, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(3, 4);
            cobblestoneTextureCache = texture;
            return texture;
        }
        
        // Cobblestone material (cached)
        let cobblestoneMaterialCache = null;
        function getCobblestoneMaterial() {
            if (cobblestoneMaterialCache) return cobblestoneMaterialCache;
            cobblestoneMaterialCache = new THREE.MeshStandardMaterial({
                map: getCobblestoneTexture(),
                roughness: 0.95,
                metalness: 0.0
            });
            return cobblestoneMaterialCache;
        }
        
        // Bridge deck material with expansion joints
        let bridgeDeckTextureCache = null;
        function getBridgeDeckTexture() {
            if (bridgeDeckTextureCache) return bridgeDeckTextureCache;
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Steel deck plate base (blue-gray)
            ctx.fillStyle = '#3a4550';
            ctx.fillRect(0, 0, 256, 256);
            
            // Add steel texture grain
            const imageData = ctx.getImageData(0, 0, 256, 256);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = Math.floor(Math.random() * 15) - 7;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
                data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Diamond plate pattern (anti-slip texture)
            ctx.fillStyle = 'rgba(100,120,140,0.4)';
            for (let y = 0; y < 256; y += 12) {
                for (let x = 0; x < 256; x += 12) {
                    const ox = (y % 24 === 0) ? 0 : 6;
                    ctx.beginPath();
                    ctx.moveTo(x + ox, y);
                    ctx.lineTo(x + ox + 4, y + 4);
                    ctx.lineTo(x + ox, y + 8);
                    ctx.lineTo(x + ox - 4, y + 4);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Expansion joints (dark lines across the road)
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 120, 256, 6);  // Horizontal expansion joint
            ctx.fillRect(0, 240, 256, 6);  // Another joint
            
            // Joint sealant (rubber strip in center)
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 122, 256, 2);
            ctx.fillRect(0, 242, 256, 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 3);
            bridgeDeckTextureCache = texture;
            return texture;
        }
        
        // Bridge deck material (cached)
        let bridgeDeckMaterialCache = null;
        function getBridgeDeckMaterial() {
            if (bridgeDeckMaterialCache) return bridgeDeckMaterialCache;
            bridgeDeckMaterialCache = new THREE.MeshStandardMaterial({
                map: getBridgeDeckTexture(),
                roughness: 0.7,
                metalness: 0.4
            });
            return bridgeDeckMaterialCache;
        }
        
        // Bridge railing materials (cached)
        let bridgeRailingMaterials = null;
        function getBridgeRailingMaterials() {
            if (bridgeRailingMaterials) return bridgeRailingMaterials;
            bridgeRailingMaterials = {
                steel: new THREE.MeshStandardMaterial({ color: 0xcc4400, metalness: 0.7, roughness: 0.3 }),
                cable: new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.4 })
            };
            return bridgeRailingMaterials;
        }
        
        // Cliff wall materials (cached)
        let cliffMaterialsCache = null;
        function getCliffMaterials() {
            if (cliffMaterialsCache) return cliffMaterialsCache;
            cliffMaterialsCache = {
                cliff: new THREE.MeshStandardMaterial({ 
                    color: 0x6b5b4b, 
                    roughness: 0.95,
                    flatShading: true 
                }),
                rock: new THREE.MeshStandardMaterial({ 
                    color: 0x7a6a5a, 
                    roughness: 0.9,
                    flatShading: true 
                })
            };
            return cliffMaterialsCache;
        }
        
        function getAsphaltTexture(countryId) {
            const cid = countryId || currentCountry;
            if (asphaltTextureCache[cid]) return asphaltTextureCache[cid];
            
            const c = countries[cid];
            const roadType = c.roadType || 'highway';
            const roadWear = c.roadWear || 0.3;
            const roadCracks = c.roadCracks !== false;
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;  // Higher resolution for detail
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            // Base asphalt color varies by road type
            let baseR, baseG, baseB;
            if (roadType === 'autobahn') {
                // German autobahn - dark, pristine charcoal
                baseR = 28; baseG = 28; baseB = 32;
            } else if (roadType === 'premium') {
                // Dubai - jet black, fresh
                baseR = 18; baseG = 18; baseB = 20;
            } else if (roadType === 'outback') {
                // Australia - sun-bleached gray-brown
                baseR = 55; baseG = 50; baseB = 45;
            } else if (roadType === 'desert') {
                // Egypt - sand-tinted, dusty
                baseR = 58; baseG = 52; baseB = 40;
            } else {
                // Standard highway
                baseR = 42; baseG = 42; baseB = 42;
            }
            
            ctx.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            ctx.fillRect(0, 0, 256, 256);
            
            // Add noise/grain - intensity varies by road roughness
            const noiseIntensity = Math.floor(20 * (c.roadRoughness || 0.8));
            const imageData = ctx.getImageData(0, 0, 256, 256);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = Math.floor(Math.random() * noiseIntensity * 2) - noiseIntensity;
                data[i] = Math.max(0, Math.min(255, data[i] + noise));
                data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
                data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
            }
            ctx.putImageData(imageData, 0, 0);
            
            // Add aggregate specks (more on rough roads)
            const aggregateCount = Math.floor(30 + roadWear * 80);
            ctx.fillStyle = `rgba(${baseR+40},${baseG+40},${baseB+35},0.4)`;
            for (let i = 0; i < aggregateCount; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const size = 1 + Math.random() * (2 + roadWear);
                ctx.fillRect(x, y, size, size);
            }
            
            // Add cracks for worn roads
            if (roadCracks && roadWear > 0.2) {
                ctx.strokeStyle = `rgba(15,15,15,${0.3 + roadWear * 0.4})`;
                ctx.lineWidth = 1;
                const crackCount = Math.floor(roadWear * 8);
                for (let i = 0; i < crackCount; i++) {
                    ctx.beginPath();
                    let x = Math.random() * 256;
                    let y = Math.random() * 256;
                    ctx.moveTo(x, y);
                    // Jagged crack path
                    for (let j = 0; j < 4 + Math.random() * 6; j++) {
                        x += (Math.random() - 0.5) * 25;
                        y += 8 + Math.random() * 15;
                        ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
            }
            
            // Add tar repair patches for worn roads (Outback specialty!)
            if (roadWear > 0.4) {
                const patchCount = Math.floor((roadWear - 0.3) * 10);
                for (let i = 0; i < patchCount; i++) {
                    // Dark tar patch
                    ctx.fillStyle = `rgba(20,20,22,${0.5 + Math.random() * 0.3})`;
                    const px = Math.random() * 230;
                    const py = Math.random() * 230;
                    const pw = 8 + Math.random() * 25;
                    const ph = 15 + Math.random() * 40;
                    
                    // Irregular patch shape
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(px + pw + (Math.random()-0.5)*8, py + (Math.random()-0.5)*5);
                    ctx.lineTo(px + pw + (Math.random()-0.5)*10, py + ph + (Math.random()-0.5)*8);
                    ctx.lineTo(px + (Math.random()-0.5)*8, py + ph + (Math.random()-0.5)*5);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            
            // Add oil stains for city/highway roads
            if (roadType === 'city' || roadType === 'highway' || roadType === 'motorway') {
                ctx.fillStyle = 'rgba(25,25,30,0.25)';
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.ellipse(
                        50 + Math.random() * 150,
                        50 + Math.random() * 150,
                        5 + Math.random() * 15,
                        3 + Math.random() * 8,
                        Math.random() * Math.PI,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Add sand drift for desert roads
            if (roadType === 'desert' || roadType === 'outback') {
                ctx.fillStyle = `rgba(${baseR+30},${baseG+25},${baseB+10},0.2)`;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const sx = Math.random() * 256;
                    const sy = Math.random() * 256;
                    ctx.ellipse(sx, sy, 20 + Math.random() * 30, 5 + Math.random() * 10, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Tire marks (subtle, for realism)
            ctx.strokeStyle = `rgba(${baseR-10},${baseG-10},${baseB-8},0.15)`;
            ctx.lineWidth = 3;
            for (let i = 0; i < 2; i++) {
                ctx.beginPath();
                const tx = 60 + i * 80 + (Math.random() - 0.5) * 20;
                ctx.moveTo(tx, 0);
                ctx.bezierCurveTo(
                    tx + (Math.random()-0.5)*15, 80,
                    tx + (Math.random()-0.5)*15, 180,
                    tx + (Math.random()-0.5)*10, 256
                );
                ctx.stroke();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 3);
            asphaltTextureCache[cid] = texture;
            return texture;
        }
        
        function createRoadSegment() {
            const segLen = 35;
            const c = countries[currentCountry];
            const segZ = lastRoadZ - segLen / 2; // Center of this segment
            
            // Capture current elevation for this segment - all elements share it
            // Use lerp from last segment for smoother visual continuity
            const rawElevation = elevation * 0.1;
            const segmentElevation = lastSegmentElevation + (rawElevation - lastSegmentElevation) * 0.7;
            lastSegmentElevation = segmentElevation; // Track for next segment
            
            // Calculate banking - smooth transition from previous segment
            // This prevents jarring banking discontinuities at section boundaries
            const rawBankAngle = banking * Math.sign(roadCurve) * Math.min(1, Math.abs(roadCurve) * 1.5);
            const bankAngle = lastSegmentBanking + (rawBankAngle - lastSegmentBanking) * 0.6;
            lastSegmentBanking = bankAngle; // Track for next segment
            
            // Road width with smooth segment-to-segment continuity
            // Prevents visible seams when width changes rapidly
            const rawWidth = currentRoadWidth;
            const roadW = lastSegmentWidth + (rawWidth - lastSegmentWidth) * 0.5;
            lastSegmentWidth = roadW; // Track for next segment
            const halfRoad = roadW / 2;
            const edgeLineOffset = halfRoad - 1; // 1 unit inside road edge
            const laneOffset = halfRoad / 2 - 0.5; // Lane markers at quarter width
            const curbOffset = halfRoad; // Rumble strips at edge
            
            // === CLASSIC CRUISIN' USA ROAD ===
            // Select material based on current surface type
            // Uses targetSurface (what we're transitioning TO) for new segments
            // This ensures segments ahead of player match the section we're entering
            let roadMat;
            const activeSurface = targetSurface; // Use target for forward consistency
            if (activeSurface === 'cobblestone') {
                roadMat = getCobblestoneMaterial();
            } else if (activeSurface === 'bridge') {
                roadMat = getBridgeDeckMaterial();
            } else {
                roadMat = getRoadMaterial(currentCountry);
            }
            const road = new THREE.Mesh(new THREE.PlaneGeometry(roadW, segLen, 1, 4), roadMat);
            road.rotation.x = -Math.PI / 2;
            road.rotation.z = bankAngle;
            road.position.set(0, segmentElevation, segZ);
            road.receiveShadow = true;
            road.userData.baseX = 0;
            road.userData.baseY = segmentElevation;
            road.userData.segmentElevation = segmentElevation;
            road.userData.banking = bankAngle;
            road.userData.spawnCurve = roadCurve;  // Remember curve at spawn
            road.userData.isRoadSurface = true; // Flag for vertex curving
            road.userData.segLen = segLen;
            scene.add(road);
            roadSegments.push(road);
            
            // === ROAD MARKINGS (surface-dependent) ===
            // Skip traditional lane markings on special surfaces:
            // - Bridges use different marking systems (reflective studs, not paint)
            // - Cobblestone roads in villages don't have modern lane markings
            const sharedMats = getSharedRoadMaterials();
            const showStandardMarkings = activeSurface !== 'bridge' && activeSurface !== 'cobblestone';
            
            if (showStandardMarkings) {
                // === WHITE EDGE LINES (solid, reflective) ===
                // Use distinct Y offsets to prevent z-fighting between markings
                // Bright white with slight emissive for reflective road paint effect
                const whiteMat = sharedMats.white;
                const edgeLineY = segmentElevation + 0.03;
                [-edgeLineOffset, edgeLineOffset].forEach(offset => {
                    const line = new THREE.Mesh(new THREE.PlaneGeometry(0.8, segLen, 1, 4), whiteMat); // NEON - extra wide
                    line.rotation.x = -Math.PI / 2;
                    line.rotation.z = bankAngle;
                    line.position.set(offset, edgeLineY, segZ);
                    line.userData.baseX = offset;
                    line.userData.baseY = edgeLineY;
                    line.userData.segmentElevation = segmentElevation;
                    line.userData.banking = bankAngle;
                    line.userData.isRoadSurface = true; // vertex warp like road
                    scene.add(line);
                    roadSegments.push(line);
                });
                
                // === NEON CHEVRON BOOST LINES (propulsion effect) ===
                // Different color per country
                const chevronColors = {
                    usa: 0x00ffff,      // Cyan
                    japan: 0xff66aa,    // Pink
                    germany: 0xffaa00,  // Orange
                    uk: 0x00ff66,       // Green
                    brazil: 0xffff00,   // Yellow
                    uae: 0xff00ff,      // Magenta
                    australia: 0xff6600, // Orange-red
                    france: 0x6699ff,   // Light blue
                    italy: 0x00ff99,    // Mint
                    egypt: 0xffcc00     // Gold
                };
                const chevronColor = chevronColors[currentCountry] || 0x00ffaa;
                const chevronMat = new THREE.MeshBasicMaterial({ 
                    color: chevronColor, 
                    transparent: true, 
                    opacity: 0.85,
                    side: THREE.DoubleSide
                });
                const boostLineSpacing = 12;
                const boostLineCount = Math.floor(segLen / boostLineSpacing);
                
                for (let i = 0; i < boostLineCount; i++) {
                    const lineZ = segZ + segLen/2 - i * boostLineSpacing - boostLineSpacing/2;
                    const lineY = segmentElevation + 0.04;
                    
                    // Row of chevrons across the road >>>>>
                    const numChevrons = 8;
                    const chevronWidth = (halfRoad * 2 - 4) / numChevrons;
                    
                    for (let c = 0; c < numChevrons; c++) {
                        const xPos = -halfRoad + 2 + c * chevronWidth + chevronWidth/2;
                        
                        // Create triangle shape (‚ñ∂)
                        const shape = new THREE.Shape();
                        const w = chevronWidth * 0.5;
                        const h = 1.5;
                        shape.moveTo(-w, h/2);    // Top left
                        shape.lineTo(w, 0);       // Right point
                        shape.lineTo(-w, -h/2);  // Bottom left
                        shape.closePath();
                        
                        const chevron = new THREE.Mesh(
                            new THREE.ShapeGeometry(shape),
                            chevronMat
                        );
                        chevron.rotation.x = -Math.PI / 2;
                        chevron.rotation.z = bankAngle;
                        chevron.position.set(xPos, lineY, lineZ);
                        chevron.userData.baseX = xPos;
                        chevron.userData.baseY = lineY;
                        chevron.userData.segmentElevation = segmentElevation;
                        chevron.userData.banking = bankAngle;
                        scene.add(chevron);
                        roadSegments.push(chevron);
                    }
                }
            }
            
            // === NATURAL TERRAIN (not bright yellow!) ===
            // Use cached terrain materials for performance (varies by country type)
            // Skip terrain on bridge sections (bridges are elevated over water/void)
            const terrainMats = getTerrainMaterials(currentCountry);
            const groundMat = terrainMats.ground;
            const shoulderMat = terrainMats.shoulder;
            
            if (activeSurface !== 'bridge') {
                // Inner shoulder strip - positioned OUTSIDE road edge to avoid z-fighting
                // Use dynamic positioning based on road width to stay just outside
                // CRITICAL: Y offset must be large enough to prevent z-fighting with road surface
                const shoulderWidth = 8;  // Narrower shoulder
                const shoulderOffset = halfRoad + shoulderWidth/2 + 0.5; // Just outside road edge
                const shoulderY = segmentElevation - 0.15; // Well below road surface to prevent z-fighting
                [-shoulderOffset, shoulderOffset].forEach(offset => {
                    const shoulder = new THREE.Mesh(new THREE.PlaneGeometry(shoulderWidth, segLen, 1, 4), shoulderMat);
                    shoulder.rotation.x = -Math.PI / 2;
                    shoulder.rotation.z = bankAngle;
                    shoulder.position.set(offset, shoulderY, segZ);
                    shoulder.receiveShadow = true;
                    shoulder.userData.baseX = offset;
                    shoulder.userData.baseY = shoulderY;
                    shoulder.userData.segmentElevation = segmentElevation;
                    shoulder.userData.banking = bankAngle;
                    shoulder.userData.isRoadSurface = true; // vertex warp like road
                    scene.add(shoulder);
                    roadSegments.push(shoulder);
                });
                
                // Main terrain panels - positioned OUTSIDE shoulder, never under road
                // This prevents z-fighting/color bleeding onto road surface
                const terrainWidth = 60;
                const terrainOffset = halfRoad + shoulderWidth + terrainWidth/2; // Beyond shoulder
                const terrainY = segmentElevation - 0.25; // Well below road and shoulder
                for (let offset of [-terrainOffset, terrainOffset]) {
                    const ground = new THREE.Mesh(new THREE.PlaneGeometry(terrainWidth, segLen), groundMat);
                    ground.rotation.x = -Math.PI / 2;
                    ground.position.set(offset, terrainY, segZ);
                    ground.receiveShadow = true;
                    ground.userData.baseX = offset;
                    ground.userData.baseY = terrainY;
                    ground.userData.segmentElevation = segmentElevation;
                    scene.add(ground);
                    roadSegments.push(ground);
                }
                
                // Far terrain panels for horizon fill
                const farTerrainOffset = halfRoad + shoulderWidth + terrainWidth + 50;
                for (let offset of [-farTerrainOffset, farTerrainOffset]) {
                    const farGround = new THREE.Mesh(new THREE.PlaneGeometry(100, segLen), groundMat);
                    farGround.rotation.x = -Math.PI / 2;
                    farGround.position.set(offset, terrainY - 0.1, segZ);
                    farGround.receiveShadow = true;
                    farGround.userData.baseX = offset;
                    farGround.userData.baseY = terrainY - 0.1;
                    farGround.userData.segmentElevation = segmentElevation;
                    scene.add(farGround);
                    roadSegments.push(farGround);
                }
            }
            
            // === RED/WHITE RUMBLE STRIPS (Cruisin' USA style curbs) ===
            // Skip standard rumble strips on bridge sections (use bridge railings instead)
            const redMat = sharedMats.red;
            const curbWhiteMat = sharedMats.curbWhite;
            // Use stripe width that divides segment evenly (35 / 1.4 = 25 stripes exactly)
            const stripeWidth = 1.4;
            const stripeCount = Math.round(segLen / stripeWidth);
            const actualStripeWidth = segLen / stripeCount; // Ensure perfect fit
            
            if (activeSurface !== 'bridge') {
                [-curbOffset, curbOffset].forEach(side => {
                    for (let i = 0; i < stripeCount; i++) {
                        const mat = (i % 2 === 0) ? redMat : curbWhiteMat;
                        const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, actualStripeWidth), mat);
                        const stripeZ = segZ + segLen/2 - i * actualStripeWidth - actualStripeWidth/2;
                        stripe.rotation.z = bankAngle; // Bank with road
                        stripe.position.set(side, segmentElevation + 0.075, stripeZ);
                        stripe.userData.baseX = side;
                        stripe.userData.baseY = segmentElevation + 0.075;
                        stripe.userData.segmentElevation = segmentElevation;
                        stripe.userData.banking = bankAngle; // Enable dynamic banking updates
                        scene.add(stripe);
                        roadSegments.push(stripe);
                    }
                });
            }
            
            // === BRIDGE RAILINGS AND CABLES ===
            // Add iconic suspension bridge railings when on bridge surface
            if (activeSurface === 'bridge') {
                const bridgeMats = getBridgeRailingMaterials();
                
                // Steel railing posts (vertical supports every segment)
                [-curbOffset - 0.5, curbOffset + 0.5].forEach(side => {
                    // Vertical post
                    const post = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 2.5, 0.2),
                        bridgeMats.steel
                    );
                    post.position.set(side, segmentElevation + 1.25, segZ);
                    post.userData.baseX = side;
                    post.userData.baseY = segmentElevation + 1.25;
                    post.userData.segmentElevation = segmentElevation;
                    post.castShadow = true;
                    scene.add(post);
                    roadSegments.push(post);
                    
                    // Top rail (horizontal)
                    const topRail = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.1, segLen),
                        bridgeMats.steel
                    );
                    topRail.position.set(side, segmentElevation + 2.4, segZ);
                    topRail.userData.baseX = side;
                    topRail.userData.baseY = segmentElevation + 2.4;
                    topRail.userData.segmentElevation = segmentElevation;
                    scene.add(topRail);
                    roadSegments.push(topRail);
                    
                    // Mid rail
                    const midRail = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.08, segLen),
                        bridgeMats.steel
                    );
                    midRail.position.set(side, segmentElevation + 1.5, segZ);
                    midRail.userData.baseX = side;
                    midRail.userData.baseY = segmentElevation + 1.5;
                    midRail.userData.segmentElevation = segmentElevation;
                    scene.add(midRail);
                    roadSegments.push(midRail);
                });
                
                // Suspension cables (visible above road every few segments)
                if (Math.random() < 0.15) {
                    [-curbOffset - 2, curbOffset + 2].forEach(side => {
                        // Vertical cable from deck to main cable
                        const cable = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.06, 0.06, 15, 6),
                            bridgeMats.cable
                        );
                        cable.position.set(side, segmentElevation + 7.5, segZ);
                        cable.userData.baseX = side;
                        cable.userData.baseY = segmentElevation + 7.5;
                        cable.userData.segmentElevation = segmentElevation;
                        scene.add(cable);
                        roadSegments.push(cable);
                    });
                }
            }
            
            // === OCCASIONAL ROADSIDE POSTS (subtle, not blocky walls) ===
            // Skip on bridge sections (railings replace posts)
            if (activeSurface !== 'bridge' && Math.random() < 0.25) {
                const postOffset = halfRoad + 4; // Just outside road edge
                [-postOffset, postOffset].forEach(side => {
                    // Small reflector post
                    const post = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 1.2, 6), sharedMats.post);
                    const postZ = segZ + (Math.random() - 0.5) * segLen * 0.6;
                    post.position.set(side, segmentElevation + 0.6, postZ);
                    post.userData.baseX = side;
                    post.userData.baseY = segmentElevation + 0.6;
                    post.userData.segmentElevation = segmentElevation;
                    scene.add(post);
                    roadSegments.push(post);
                    
                    // Orange reflector on top
                    const reflector = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.08), sharedMats.reflector);
                    reflector.position.set(side, segmentElevation + 1.1, postZ);
                    reflector.userData.baseX = side;
                    reflector.userData.baseY = segmentElevation + 1.1;
                    reflector.userData.segmentElevation = segmentElevation;
                    scene.add(reflector);
                    roadSegments.push(reflector);
                });
            }
            
            // Country-specific scenery - positioned well away from road to prevent clipping
            // Skip scenery on bridge sections
            const sceneryChance = (c.sceneryType === 'tokyo' || c.sceneryType === 'dubai') ? 0.8 : 0.6;
            if (activeSurface !== 'bridge' && Math.random() < sceneryChance) {
                // Near roadside scenery (trees, etc) - positioned relative to road width
                const nearSceneryDist = halfRoad + 8;
                [-nearSceneryDist, nearSceneryDist].forEach(side => {
                    if (Math.random() < 0.35) return;
                    const obj = createScenery(c.sceneryType);
                    // Push scenery away from road with random offset AWAY from road
                    const offsetDir = side > 0 ? 1 : -1;
                    const objX = side + offsetDir * (5 + Math.random() * 10);
                    obj.position.set(objX, 0, segZ + (Math.random() - 0.5) * segLen * 0.8);
                    obj.userData.baseX = objX;
                    obj.userData.spawnCurve = roadCurve;
                    scene.add(obj);
                    scenery.push(obj);
                });
                
                // Mid-distance scenery
                const midSceneryDist = halfRoad + 25;
                [-midSceneryDist, midSceneryDist].forEach(side => {
                    if (Math.random() < 0.5) return;
                    const obj = createScenery(c.sceneryType);
                    const offsetDir = side > 0 ? 1 : -1;
                    const objX = side + offsetDir * (Math.random() * 15);
                    obj.position.set(objX, 0, segZ + (Math.random() - 0.5) * segLen * 0.8);
                    obj.userData.baseX = objX;
                    obj.userData.spawnCurve = roadCurve;
                    scene.add(obj);
                    scenery.push(obj);
                });
                
                // Extra buildings for cities (further back)
                if (c.sceneryType === 'tokyo' || c.sceneryType === 'dubai') {
                    const farSceneryDist = halfRoad + 40;
                    [-farSceneryDist, farSceneryDist].forEach(side => {
                        if (Math.random() < 0.4) return;
                        const obj = createScenery(c.sceneryType);
                        const objX = side + (Math.random() - 0.5) * 12;
                        obj.position.set(objX, 0, segZ + (Math.random() - 0.5) * segLen * 0.8);
                        obj.userData.baseX = objX;
                        obj.userData.spawnCurve = roadCurve;
                        scene.add(obj);
                        scenery.push(obj);
                    });
                }
            }
            
            // Billboards (occasional, American style) - only for american/outback/desert
            if ((c.sceneryType === 'american' || c.sceneryType === 'outback' || c.sceneryType === 'desert') && Math.random() < 0.08) {
                const side = Math.random() > 0.5 ? 25 : -25;
                const billboard = createBillboard();
                billboard.position.set(side, 0, segZ);
                billboard.rotation.y = side > 0 ? -0.3 : 0.3; // Angle toward road
                billboard.userData.baseX = side;
                billboard.userData.spawnCurve = roadCurve;
                scene.add(billboard);
                scenery.push(billboard);
            }
            
            // Mile markers (every ~100 meters) - skip on bridge
            if (activeSurface !== 'bridge' && Math.random() < 0.03) {
                const markerSide = halfRoad + 4;
                const marker = createMileMarker(Math.floor(distance + 50));
                marker.position.set(markerSide, 0, segZ);
                marker.userData.baseX = markerSide;
                marker.userData.spawnCurve = roadCurve;
                scene.add(marker);
                scenery.push(marker);
            }
            
            // Country-specific road signs (all countries get signs; american also gets billboards)
            if (activeSurface !== 'bridge' && Math.random() < 0.06) {
                const signDist = halfRoad + 6;
                const side = Math.random() > 0.5 ? signDist : -signDist;
                const countrySign = createCountrySign(c.sceneryType);
                if (countrySign.children.length > 0) { // Only add if sign was created
                    countrySign.position.set(side, segmentElevation, segZ);
                    countrySign.rotation.y = side > 0 ? -0.2 : 0.2;
                    countrySign.userData.baseX = side;
                    countrySign.userData.spawnCurve = roadCurve;
                    countrySign.userData.baseY = segmentElevation;
                    countrySign.userData.segmentElevation = segmentElevation;
                    scene.add(countrySign);
                    scenery.push(countrySign);
                }
            }
            
            // Ground vegetation clusters (adds visual interest near roadside) - skip on bridge
            if (activeSurface !== 'bridge' && Math.random() < 0.4) {
                const vegDist = halfRoad + 5;
                [-vegDist, vegDist].forEach(side => {
                    if (Math.random() < 0.5) return;
                    const vegetation = createGroundVegetation(c.sceneryType);
                    const vegX = side + (Math.random() - 0.5) * 4;
                    vegetation.position.set(vegX, segmentElevation, segZ + (Math.random() - 0.5) * segLen * 0.6);
                    vegetation.userData.baseX = vegX;
                    vegetation.userData.spawnCurve = roadCurve;
                    vegetation.userData.baseY = segmentElevation;
                    vegetation.userData.segmentElevation = segmentElevation;
                    scene.add(vegetation);
                    scenery.push(vegetation);
                });
            }
            
            // Iconic country landmarks (rare but memorable - torii gates, pyramids, etc.)
            if (Math.random() < 0.015 && iconicLandmarks.length < 3) {
                const landmark = createIconicLandmark(c.sceneryType);
                if (landmark.children.length > 0) {
                    const side = Math.random() > 0.5 ? 50 : -50;
                    const landmarkX = side + (Math.random() - 0.5) * 20;
                    landmark.position.set(landmarkX, segmentElevation, segZ - 30);
                    landmark.rotation.y = side > 0 ? -0.3 : 0.3;
                    landmark.userData.baseX = landmarkX;
                    landmark.userData.spawnCurve = roadCurve;
                    landmark.userData.baseY = segmentElevation;
                    landmark.userData.segmentElevation = segmentElevation;
                    scene.add(landmark);
                    iconicLandmarks.push(landmark);
                }
            }
            
            // Animated windmills for European/American countryside
            if ((c.sceneryType === 'european' || c.sceneryType === 'american') && Math.random() < 0.02 && animatedWindmills.length < 5) {
                const side = Math.random() > 0.5 ? 55 : -55;
                const windmill = createWindmill();
                const wmX = side + (Math.random() - 0.5) * 15;
                windmill.position.set(wmX, segmentElevation, segZ - 20);
                windmill.rotation.y = side > 0 ? -0.5 : 0.5; // Face toward road
                windmill.userData.baseX = wmX;
                windmill.userData.spawnCurve = roadCurve;
                windmill.userData.baseY = segmentElevation;
                windmill.userData.segmentElevation = segmentElevation;
                scene.add(windmill);
                animatedWindmills.push(windmill);
            }
            
            // Modern wind turbines for Germany (common along autobahn) and UAE (renewable energy projects)
            if ((c.sceneryType === 'european' || c.sceneryType === 'dubai') && Math.random() < 0.025 && animatedWindmills.length < 6) {
                const side = Math.random() > 0.5 ? 70 : -70;
                const turbine = createModernWindTurbine();
                const tX = side + (Math.random() - 0.5) * 20;
                turbine.position.set(tX, segmentElevation, segZ - 30);
                turbine.userData.baseX = tX;
                turbine.userData.spawnCurve = roadCurve;
                turbine.userData.baseY = segmentElevation;
                turbine.userData.segmentElevation = segmentElevation;
                scene.add(turbine);
                animatedWindmills.push(turbine);
            }
            
            // Palm tree oases for UAE (contrast against skyscrapers)
            if (c.sceneryType === 'dubai' && Math.random() < 0.04) {
                const side = Math.random() > 0.5 ? 35 : -35;
                const oasis = createPalmOasis();
                const oX = side + (Math.random() - 0.5) * 10;
                oasis.position.set(oX, segmentElevation, segZ);
                oasis.userData.baseX = oX;
                oasis.userData.spawnCurve = roadCurve;
                oasis.userData.baseY = segmentElevation;
                oasis.userData.segmentElevation = segmentElevation;
                scene.add(oasis);
                scenery.push(oasis);
            }
            
            // Guard rails / barriers (for curves and elevated sections)
            // More likely on curves and at elevation changes
            const needsGuardRail = Math.abs(roadCurve) > 0.01 || Math.abs(elevationTarget) > 1;
            if (needsGuardRail && Math.random() < 0.3) {
                createGuardRail(segZ, segLen, segmentElevation, bankAngle, c, roadW);
            }
            
            // === CLIFF WALLS FOR NARROW MOUNTAIN PASSES ===
            // Add dramatic rock walls when road is narrow (mountain pass feeling)
            if (activeSurface === 'narrow' || roadW <= 18) {
                const cliffMats = getCliffMaterials();
                
                // Rock walls on both sides (varying height for natural look)
                [-halfRoad - 3, halfRoad + 3].forEach(side => {
                    const wallHeight = 8 + Math.random() * 6;
                    const wallWidth = 4 + Math.random() * 2;
                    
                    // Main cliff face
                    const cliff = new THREE.Mesh(
                        new THREE.BoxGeometry(wallWidth, wallHeight, segLen + 2),
                        cliffMats.cliff
                    );
                    cliff.position.set(side + (side > 0 ? wallWidth/2 : -wallWidth/2), 
                                        segmentElevation + wallHeight/2 - 1, segZ);
                    cliff.userData.baseX = cliff.position.x;
                    cliff.userData.baseY = cliff.position.y;
                    cliff.userData.segmentElevation = segmentElevation;
                    cliff.castShadow = true;
                    cliff.receiveShadow = true;
                    scene.add(cliff);
                    roadSegments.push(cliff);
                    
                    // Add rocky outcrops for visual interest
                    if (Math.random() < 0.4) {
                        const outcrop = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(1.5 + Math.random()),
                            cliffMats.rock
                        );
                        outcrop.position.set(
                            side + (side > 0 ? 1 : -1),
                            segmentElevation + 2 + Math.random() * 3,
                            segZ + (Math.random() - 0.5) * segLen * 0.6
                        );
                        outcrop.rotation.set(Math.random(), Math.random(), Math.random());
                        outcrop.userData.baseX = outcrop.position.x;
                        outcrop.userData.baseY = outcrop.position.y;
                        outcrop.userData.segmentElevation = segmentElevation;
                        scene.add(outcrop);
                        roadSegments.push(outcrop);
                    }
                });
            }
            
            // Traffic - DYNAMIC DENSITY based on speed and score
            // TUNED for balanced arcade feel:
            // Base: 18% spawn rate (was 15%) - more traffic = more excitement
            // Speed factor: up to +12% (was +20%) - gentler scaling with speed
            // Score factor: up to +10% (was +15%) - gentler late-game scaling
            // Max spawn rate: 40% (18 + 12 + 10) prevents overwhelming traffic
            const speedFactor = Math.min(0.12, Math.max(0, speed - 80) / 600);
            const scoreFactor = Math.min(0.10, score / 120000);
            const dynamicSpawnRate = 0.18 + speedFactor + scoreFactor;
            
            if (Math.random() < dynamicSpawnRate && segZ < -120) {
                spawnTraffic(segZ);
            }
            
            // Emergency vehicle spawning - rare (every ~800m on average), dramatic!
            lastEmergencySpawn += 35; // Track distance per segment
            if (lastEmergencySpawn > 600 && Math.random() < 0.08 && segZ < -150) {
                spawnEmergencyVehicle(segZ);
                lastEmergencySpawn = 0;
            }
            
            lastRoadZ -= segLen;
        }
        
        // Create guard rails / barriers along dangerous road sections
        function createGuardRail(segZ, segLen, segmentElevation, bankAngle, country, roadWidth) {
            const side = Math.random() > 0.5 ? 1 : -1;
            // Position guard rails just outside the shoulder (road half-width + shoulder + margin)
            const halfRoad = (roadWidth || 24) / 2;
            const xPos = side * (halfRoad + 2.5); // 2.5 units outside road edge (past 2-unit shoulder)
            
            // Different barrier types per country
            const barrierType = country.sceneryType;
            
            if (barrierType === 'tokyo' || barrierType === 'dubai') {
                // Concrete Jersey barriers for urban areas
                const concreteMat = new THREE.MeshStandardMaterial({ 
                    color: barrierType === 'dubai' ? 0x888888 : 0x999999, 
                    roughness: 0.9 
                });
                
                const barrierCount = Math.floor(segLen / 4);
                for (let i = 0; i < barrierCount; i++) {
                    // Jersey barrier shape (trapezoidal cross-section)
                    const shape = new THREE.Shape();
                    shape.moveTo(-0.4, 0);
                    shape.lineTo(0.4, 0);
                    shape.lineTo(0.25, 0.8);
                    shape.lineTo(-0.25, 0.8);
                    shape.lineTo(-0.4, 0);
                    
                    const barrierGeo = new THREE.ExtrudeGeometry(shape, {
                        steps: 1, depth: 3.5, bevelEnabled: false
                    });
                    const barrier = new THREE.Mesh(barrierGeo, concreteMat);
                    barrier.rotation.y = Math.PI / 2;
                    barrier.rotation.x = bankAngle;
                    barrier.position.set(xPos, segmentElevation, segZ + segLen/2 - i * 4 - 2);
                    barrier.castShadow = true;
                    barrier.userData.baseX = xPos;
                    barrier.userData.baseY = segmentElevation;
                    barrier.userData.segmentElevation = segmentElevation;
                    barrier.userData.banking = bankAngle;
                    scene.add(barrier);
                    roadSegments.push(barrier);
                }
                
            } else if (barrierType === 'autobahn' || barrierType === 'european' || barrierType === 'british') {
                // Metal W-beam guard rails (standard highway style)
                const postMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6 });
                const railMat = new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc, 
                    metalness: 0.8, 
                    roughness: 0.3 
                });
                
                // Posts every 2 meters
                const postCount = Math.floor(segLen / 2);
                for (let i = 0; i < postCount; i++) {
                    const postZ = segZ + segLen/2 - i * 2;
                    
                    // Vertical post
                    const post = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 1.0, 0.08),
                        postMat
                    );
                    post.rotation.z = bankAngle;
                    post.position.set(xPos, segmentElevation + 0.5, postZ);
                    post.userData.baseX = xPos;
                    post.userData.baseY = segmentElevation + 0.5;
                    post.userData.segmentElevation = segmentElevation;
                    post.userData.banking = bankAngle;
                    scene.add(post);
                    roadSegments.push(post);
                }
                
                // Continuous W-beam rail
                const rail = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.3, segLen),
                    railMat
                );
                rail.rotation.z = bankAngle;
                rail.position.set(xPos, segmentElevation + 0.7, segZ);
                rail.userData.baseX = xPos;
                rail.userData.baseY = segmentElevation + 0.7;
                rail.userData.segmentElevation = segmentElevation;
                rail.userData.banking = bankAngle;
                scene.add(rail);
                roadSegments.push(rail);
                
            } else {
                // Wooden post and wire fence for rural areas (american, outback, desert, etc.)
                const postMat = new THREE.MeshStandardMaterial({ 
                    color: barrierType === 'desert' || barrierType === 'outback' ? 0x6b5a4a : 0x5a4a3a, 
                    roughness: 0.9 
                });
                const wireMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5 });
                
                // Fence posts every 4 meters
                const postCount = Math.floor(segLen / 4);
                for (let i = 0; i < postCount; i++) {
                    const postZ = segZ + segLen/2 - i * 4;
                    
                    const post = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 1.2, 0.15),
                        postMat
                    );
                    post.rotation.z = bankAngle;
                    post.position.set(xPos, segmentElevation + 0.6, postZ);
                    post.userData.baseX = xPos;
                    post.userData.baseY = segmentElevation + 0.6;
                    post.userData.segmentElevation = segmentElevation;
                    post.userData.banking = bankAngle;
                    scene.add(post);
                    roadSegments.push(post);
                }
                
                // Wire strands (2 levels)
                [0.4, 0.9].forEach(height => {
                    const wire = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.01, 0.01, segLen, 4),
                        wireMat
                    );
                    wire.rotation.x = Math.PI / 2;
                    wire.rotation.y = bankAngle;
                    wire.position.set(xPos, segmentElevation + height, segZ);
                    wire.userData.baseX = xPos;
                    wire.userData.baseY = segmentElevation + height;
                    wire.userData.segmentElevation = segmentElevation;
                    scene.add(wire);
                    roadSegments.push(wire);
                });
            }
        }
        
        function createScenery(type) {
            const group = new THREE.Group();
            
            if (type === 'american' || type === 'european' || type === 'british') {
                // Variety of trees and roadside objects
                const variety = Math.random();
                
                if (variety < 0.5) {
                    // Full leafy tree like Cruisin' USA - Oak/Maple style
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.6, 6, 8),
                        new THREE.MeshStandardMaterial({ color: 0x3d2817 })
                    );
                    trunk.position.y = 3;
                    trunk.castShadow = true;
                    group.add(trunk);
                    
                    // Round bushy foliage (multiple spheres for fullness)
                    const foliageColors = type === 'british' ? [0x1a4a1a, 0x2a5a2a] : [0x2d5a2d, 0x3d6a3d, 0x4a7a4a];
                    const foliageColor = foliageColors[Math.floor(Math.random() * foliageColors.length)];
                    const foliageMat = new THREE.MeshStandardMaterial({ color: foliageColor });
                    
                    const mainFoliage = new THREE.Mesh(new THREE.SphereGeometry(4, 8, 8), foliageMat);
                    mainFoliage.position.y = 8;
                    mainFoliage.castShadow = true;
                    group.add(mainFoliage);
                    
                    // Extra foliage clusters for fuller appearance
                    for (let i = 0; i < 4; i++) {
                        const cluster = new THREE.Mesh(new THREE.SphereGeometry(2 + Math.random() * 1.5, 6, 6), foliageMat);
                        cluster.position.set(
                            (Math.random() - 0.5) * 4,
                            6 + Math.random() * 3,
                            (Math.random() - 0.5) * 4
                        );
                        group.add(cluster);
                    }
                } else if (variety < 0.7) {
                    // Pine/Evergreen tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.5, 5, 8),
                        new THREE.MeshStandardMaterial({ color: 0x4a3520 })
                    );
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    group.add(trunk);
                    
                    // Tiered cone foliage
                    const pineMat = new THREE.MeshStandardMaterial({ color: 0x1a4a2a });
                    for (let i = 0; i < 3; i++) {
                        const cone = new THREE.Mesh(
                            new THREE.ConeGeometry(3 - i * 0.7, 4 - i * 0.5, 8),
                            pineMat
                        );
                        cone.position.y = 5 + i * 2.5;
                        cone.castShadow = true;
                        group.add(cone);
                    }
                } else if (variety < 0.85) {
                    // Tall birch/aspen tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.25, 0.35, 10, 8),
                        new THREE.MeshStandardMaterial({ color: 0xccccbb })
                    );
                    trunk.position.y = 5;
                    trunk.castShadow = true;
                    group.add(trunk);
                    
                    // Lighter foliage
                    const foliageMat = new THREE.MeshStandardMaterial({ color: 0x5a8a4a });
                    const foliage = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), foliageMat);
                    foliage.position.y = 11;
                    group.add(foliage);
                } else if (type === 'british' && Math.random() > 0.5) {
                    // British-specific: Red telephone box or double-decker bus
                    if (Math.random() > 0.4) {
                        // Iconic red telephone box (K6 style)
                        const phoneBoxRed = new THREE.MeshStandardMaterial({ 
                            color: 0xcc2222, 
                            roughness: 0.4,
                            metalness: 0.2
                        });
                        const phoneBoxGlass = new THREE.MeshStandardMaterial({ 
                            color: 0x88aacc, 
                            transparent: true, 
                            opacity: 0.5,
                            metalness: 0.8
                        });
                        
                        // Main body
                        const body = new THREE.Mesh(
                            new THREE.BoxGeometry(1.2, 2.8, 1.2),
                            phoneBoxRed
                        );
                        body.position.y = 1.4;
                        body.castShadow = true;
                        group.add(body);
                        
                        // Crown/dome top
                        const crown = new THREE.Mesh(
                            new THREE.BoxGeometry(1.3, 0.4, 1.3),
                            phoneBoxRed
                        );
                        crown.position.y = 2.9;
                        group.add(crown);
                        
                        // Dome cap
                        const cap = new THREE.Mesh(
                            new THREE.SphereGeometry(0.5, 8, 4, 0, Math.PI * 2, 0, Math.PI / 2),
                            phoneBoxRed
                        );
                        cap.position.y = 3.1;
                        group.add(cap);
                        
                        // Window panels (glass)
                        const panelPositions = [[0, 0, 0.62], [0, 0, -0.62], [0.62, 0, 0], [-0.62, 0, 0]];
                        panelPositions.forEach(([px, py, pz], idx) => {
                            const panel = new THREE.Mesh(
                                new THREE.PlaneGeometry(0.9, 2.2),
                                phoneBoxGlass
                            );
                            panel.position.set(px, 1.5, pz);
                            panel.rotation.y = idx < 2 ? 0 : Math.PI / 2;
                            group.add(panel);
                        });
                        
                        // "TELEPHONE" sign on top (subtle detail)
                        const signMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        const sign = new THREE.Mesh(
                            new THREE.BoxGeometry(0.9, 0.15, 0.05),
                            signMat
                        );
                        sign.position.set(0, 2.65, 0.63);
                        group.add(sign);
                        
                    } else {
                        // Double-decker bus (simplified)
                        const busRed = new THREE.MeshStandardMaterial({ 
                            color: 0xcc1111, 
                            roughness: 0.5 
                        });
                        const busWindow = new THREE.MeshStandardMaterial({ 
                            color: 0x334455, 
                            metalness: 0.7, 
                            roughness: 0.2 
                        });
                        const busTrim = new THREE.MeshStandardMaterial({ color: 0x111111 });
                        
                        // Lower deck
                        const lowerDeck = new THREE.Mesh(
                            new THREE.BoxGeometry(2.5, 1.5, 6),
                            busRed
                        );
                        lowerDeck.position.y = 0.95;
                        lowerDeck.castShadow = true;
                        group.add(lowerDeck);
                        
                        // Upper deck
                        const upperDeck = new THREE.Mesh(
                            new THREE.BoxGeometry(2.4, 1.3, 5.8),
                            busRed
                        );
                        upperDeck.position.y = 2.35;
                        group.add(upperDeck);
                        
                        // Windows (upper deck)
                        for (let w = -2; w <= 2; w++) {
                            const win = new THREE.Mesh(
                                new THREE.PlaneGeometry(0.8, 0.9),
                                busWindow
                            );
                            win.position.set(1.26, 2.4, w * 1.1);
                            win.rotation.y = Math.PI / 2;
                            group.add(win);
                            
                            const win2 = win.clone();
                            win2.position.x = -1.26;
                            win2.rotation.y = -Math.PI / 2;
                            group.add(win2);
                        }
                        
                        // Front windshield
                        const windshield = new THREE.Mesh(
                            new THREE.PlaneGeometry(2, 1.8),
                            busWindow
                        );
                        windshield.position.set(0, 1.8, 3.01);
                        group.add(windshield);
                        
                        // Wheels
                        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                        [[-0.8, 0.35, 2], [-0.8, 0.35, -2], [0.8, 0.35, 2], [0.8, 0.35, -2]].forEach(([wx, wy, wz]) => {
                            const wheel = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.35, 0.35, 0.3, 12),
                                wheelMat
                            );
                            wheel.rotation.z = Math.PI / 2;
                            wheel.position.set(wx > 0 ? 1.3 : -1.3, wy, wz);
                            group.add(wheel);
                        });
                        
                        // Headlights
                        const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                        [-0.7, 0.7].forEach(x => {
                            const light = new THREE.Mesh(
                                new THREE.CircleGeometry(0.15, 8),
                                lightMat
                            );
                            light.position.set(x, 0.6, 3.01);
                            group.add(light);
                        });
                    }
                } else {
                    // Bush/shrub cluster
                    const bushMat = new THREE.MeshStandardMaterial({ color: 0x3a6a3a });
                    for (let i = 0; i < 3; i++) {
                        const bush = new THREE.Mesh(
                            new THREE.SphereGeometry(1.2 + Math.random(), 6, 6),
                            bushMat
                        );
                        bush.position.set(
                            (Math.random() - 0.5) * 3,
                            0.8 + Math.random() * 0.5,
                            (Math.random() - 0.5) * 3
                        );
                        bush.scale.y = 0.7;
                        group.add(bush);
                    }
                }
            } else if (type === 'tokyo') {
                // Tokyo cityscape - skyscrapers, Tokyo Tower, etc
                const buildingType = Math.random();
                
                if (buildingType < 0.15) {
                    // Tokyo Tower - iconic red/orange lattice tower
                    const towerHeight = 25;
                    const towerMat = new THREE.MeshStandardMaterial({ color: 0xdd4422 });
                    const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                    
                    // Main tower structure (tapered)
                    const tower1 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.8, 2.5, towerHeight * 0.7, 4),
                        towerMat
                    );
                    tower1.position.y = towerHeight * 0.35;
                    group.add(tower1);
                    
                    // Upper section
                    const tower2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.8, towerHeight * 0.3, 4),
                        towerMat
                    );
                    tower2.position.y = towerHeight * 0.85;
                    group.add(tower2);
                    
                    // Antenna
                    const antenna = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.1, 5, 8),
                        whiteMat
                    );
                    antenna.position.y = towerHeight + 2.5;
                    group.add(antenna);
                    
                    // White bands
                    for (let i = 0; i < 5; i++) {
                        const band = new THREE.Mesh(
                            new THREE.CylinderGeometry(1.8 - i * 0.3, 1.9 - i * 0.3, 0.8, 4),
                            whiteMat
                        );
                        band.position.y = 5 + i * 3;
                        group.add(band);
                    }
                } else if (buildingType < 0.5) {
                    // Modern glass skyscraper
                    const height = 15 + Math.random() * 35;
                    const width = 3 + Math.random() * 4;
                    
                    const glassMat = new THREE.MeshStandardMaterial({ 
                        color: 0x334455 + Math.floor(Math.random() * 0x222222),
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    
                    const building = new THREE.Mesh(
                        new THREE.BoxGeometry(width, height, width),
                        glassMat
                    );
                    building.position.y = height / 2;
                    building.castShadow = true;
                    group.add(building);
                    
                    // Window lights
                    const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                    for (let y = 2; y < height - 1; y += 2.5) {
                        for (let x = -1; x <= 1; x++) {
                            if (Math.random() > 0.3) {
                                const win = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 1.2), lightMat);
                                win.position.set(x * 1, y, width/2 + 0.01);
                                group.add(win);
                            }
                        }
                    }
                } else {
                    // Regular city building
                    const height = 8 + Math.random() * 20;
                    const colors = [0x888888, 0x666677, 0x777788, 0x998877, 0xaaaaaa];
                    
                    const building = new THREE.Mesh(
                        new THREE.BoxGeometry(4 + Math.random() * 3, height, 4 + Math.random() * 3),
                        new THREE.MeshStandardMaterial({ color: colors[Math.floor(Math.random() * colors.length)] })
                    );
                    building.position.y = height / 2;
                    building.castShadow = true;
                    group.add(building);
                }
            } else if (type === 'tropical') {
                const variety = Math.random();
                
                if (variety < 0.6) {
                    // Palm tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.25, 0.4, 7, 8),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                    );
                    trunk.position.y = 3.5;
                    // Slight lean for natural look
                    trunk.rotation.z = (Math.random() - 0.5) * 0.2;
                    group.add(trunk);
                    
                    const leafMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                    for (let i = 0; i < 7; i++) {
                        const leaf = new THREE.Mesh(
                            new THREE.ConeGeometry(0.5, 4.5, 4),
                            leafMat
                        );
                        leaf.position.set(0, 7, 0);
                        leaf.rotation.z = Math.PI / 3 + (Math.random() - 0.5) * 0.2;
                        leaf.rotation.y = (i / 7) * Math.PI * 2;
                        group.add(leaf);
                    }
                } else if (variety < 0.8) {
                    // Tropical bush/fern cluster
                    const fernMat = new THREE.MeshStandardMaterial({ color: 0x2d8b2d });
                    for (let i = 0; i < 5; i++) {
                        const fern = new THREE.Mesh(
                            new THREE.ConeGeometry(1.5 + Math.random(), 3, 6),
                            fernMat
                        );
                        fern.position.set(
                            (Math.random() - 0.5) * 3,
                            1.5,
                            (Math.random() - 0.5) * 3
                        );
                        fern.rotation.x = (Math.random() - 0.5) * 0.3;
                        group.add(fern);
                    }
                } else if (variety < 0.9) {
                    // Banana tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.5, 5, 8),
                        new THREE.MeshStandardMaterial({ color: 0x6b8e23 })
                    );
                    trunk.position.y = 2.5;
                    group.add(trunk);
                    
                    // Large leaves
                    const leafMat = new THREE.MeshStandardMaterial({ 
                        color: 0x32cd32,
                        side: THREE.DoubleSide 
                    });
                    for (let i = 0; i < 5; i++) {
                        const leaf = new THREE.Mesh(
                            new THREE.PlaneGeometry(1, 4),
                            leafMat
                        );
                        leaf.position.set(0, 5, 0);
                        leaf.rotation.z = Math.PI / 4;
                        leaf.rotation.y = (i / 5) * Math.PI * 2;
                        leaf.rotation.x = 0.3;
                        group.add(leaf);
                    }
                } else {
                    // Beach setup (umbrellas, chairs - coastal Brazil vibes)
                    const umbrellaColors = [0xff4444, 0x4444ff, 0xffff44, 0x44ff44, 0xff8800];
                    const umbrellaColor = umbrellaColors[Math.floor(Math.random() * 5)];
                    
                    // Beach umbrella
                    const pole = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 3, 8),
                        new THREE.MeshStandardMaterial({ color: 0x8b4513 })
                    );
                    pole.position.y = 1.5;
                    group.add(pole);
                    
                    const canopy = new THREE.Mesh(
                        new THREE.ConeGeometry(2, 0.8, 8, 1, true),
                        new THREE.MeshStandardMaterial({ color: umbrellaColor, side: THREE.DoubleSide })
                    );
                    canopy.rotation.x = Math.PI;
                    canopy.position.y = 2.8;
                    group.add(canopy);
                    
                    // Beach chair
                    const chairMat = new THREE.MeshStandardMaterial({ color: 0x4488ff });
                    const chairFrame = new THREE.MeshStandardMaterial({ color: 0xdddddd });
                    
                    const seat = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 0.08, 2),
                        chairMat
                    );
                    seat.rotation.x = 0.2;
                    seat.position.set(1.5, 0.5, 0);
                    group.add(seat);
                    
                    // Chair legs
                    [[-0.5, -0.8], [-0.5, 0.8], [0.5, -0.8], [0.5, 0.8]].forEach(([x, z]) => {
                        const leg = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.03, 0.03, 0.6, 6),
                            chairFrame
                        );
                        leg.position.set(1.5 + x * 0.5, 0.3, z * 0.4);
                        group.add(leg);
                    });
                }
            } else if (type === 'outback' || type === 'desert') {
                const variety = Math.random();
                
                if (variety < 0.35) {
                    // Rocky outcrop / boulder cluster
                    const rockColor = type === 'desert' ? 0xc4a35a : 0xb8860b;
                    const rockMat = new THREE.MeshStandardMaterial({ 
                        color: rockColor, 
                        roughness: 0.9,
                        flatShading: true 
                    });
                    
                    // Main rock
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(3 + Math.random() * 3),
                        rockMat
                    );
                    rock.position.y = 2;
                    rock.scale.set(1, 0.6 + Math.random() * 0.3, 1);
                    rock.rotation.y = Math.random() * Math.PI;
                    rock.castShadow = true;
                    group.add(rock);
                    
                    // Smaller rocks around
                    for (let i = 0; i < 3; i++) {
                        const smallRock = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(1 + Math.random()),
                            rockMat
                        );
                        smallRock.position.set(
                            (Math.random() - 0.5) * 5,
                            0.8,
                            (Math.random() - 0.5) * 5
                        );
                        smallRock.rotation.set(Math.random(), Math.random(), Math.random());
                        group.add(smallRock);
                    }
                } else if (variety < 0.55) {
                    // Saguaro cactus (desert only)
                    if (type === 'desert') {
                        const cactusMat = new THREE.MeshStandardMaterial({ color: 0x2d5a2d });
                        
                        // Main trunk
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.5, 8, 12),
                            cactusMat
                        );
                        trunk.position.y = 4;
                        trunk.castShadow = true;
                        group.add(trunk);
                        
                        // Arms
                        const armHeight = 2 + Math.random() * 2;
                        [-1, 1].forEach((side, i) => {
                            if (Math.random() > 0.3) {
                                // Horizontal part
                                const armH = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8),
                                    cactusMat
                                );
                                armH.rotation.z = Math.PI / 2;
                                armH.position.set(side * 0.8, 3 + i * 1.5, 0);
                                group.add(armH);
                                
                                // Vertical part
                                const armV = new THREE.Mesh(
                                    new THREE.CylinderGeometry(0.25, 0.3, armHeight, 8),
                                    cactusMat
                                );
                                armV.position.set(side * 1.5, 3 + i * 1.5 + armHeight / 2, 0);
                                group.add(armV);
                            }
                        });
                    } else {
                        // Outback - dead tree / ghost gum
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.5, 6, 8),
                            new THREE.MeshStandardMaterial({ color: 0x8b8b7a })
                        );
                        trunk.position.y = 3;
                        trunk.rotation.z = 0.1;
                        group.add(trunk);
                        
                        // Dead branches
                        for (let i = 0; i < 3; i++) {
                            const branch = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.08, 0.15, 2, 6),
                                new THREE.MeshStandardMaterial({ color: 0x7a7a6a })
                            );
                            branch.position.set(0, 4 + i, 0);
                            branch.rotation.z = (Math.random() - 0.5) * 1.5;
                            branch.rotation.y = Math.random() * Math.PI * 2;
                            group.add(branch);
                        }
                    }
                } else if (variety < 0.75) {
                    // Mesa / butte formation
                    const mesaColor = type === 'desert' ? 0xb8860b : 0xa0522d;
                    const mesaMat = new THREE.MeshStandardMaterial({ 
                        color: mesaColor,
                        flatShading: true
                    });
                    
                    const mesa = new THREE.Mesh(
                        new THREE.CylinderGeometry(4, 6, 10, 6),
                        mesaMat
                    );
                    mesa.position.y = 5;
                    mesa.castShadow = true;
                    group.add(mesa);
                    
                    // Flat top
                    const top = new THREE.Mesh(
                        new THREE.CylinderGeometry(4.5, 4, 2, 6),
                        mesaMat
                    );
                    top.position.y = 11;
                    group.add(top);
                } else if (variety < 0.88 && type === 'desert') {
                    // Egyptian obelisk (ancient monument style)
                    const stoneMat = new THREE.MeshStandardMaterial({ 
                        color: 0xd4c4a8, 
                        roughness: 0.85 
                    });
                    
                    // Tapered column
                    const height = 8 + Math.random() * 6;
                    const obelisk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.6, 1.0, height, 4),
                        stoneMat
                    );
                    obelisk.rotation.y = Math.PI / 4; // Align corners
                    obelisk.position.y = height / 2;
                    obelisk.castShadow = true;
                    group.add(obelisk);
                    
                    // Pyramidion (pointed top)
                    const top = new THREE.Mesh(
                        new THREE.ConeGeometry(0.7, 2, 4),
                        new THREE.MeshStandardMaterial({ color: 0xd4af37 }) // Gold-ish tip
                    );
                    top.rotation.y = Math.PI / 4;
                    top.position.y = height + 1;
                    group.add(top);
                    
                    // Base plinth
                    const base = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.5, 2),
                        stoneMat
                    );
                    base.position.y = 0.25;
                    group.add(base);
                } else {
                    // Tumbleweed / scrub brush
                    const scrubMat = new THREE.MeshStandardMaterial({ color: 0x6b6b3a });
                    for (let i = 0; i < 4; i++) {
                        const scrub = new THREE.Mesh(
                            new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 6, 6),
                            scrubMat
                        );
                        scrub.position.set(
                            (Math.random() - 0.5) * 4,
                            0.4,
                            (Math.random() - 0.5) * 4
                        );
                        scrub.scale.y = 0.5;
                        group.add(scrub);
                    }
                }
            } else if (type === 'dubai') {
                // Skyscraper
                const height = 15 + Math.random() * 30;
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(4 + Math.random() * 3, height, 4 + Math.random() * 3),
                    new THREE.MeshStandardMaterial({ color: 0x334455, metalness: 0.8, roughness: 0.2 })
                );
                building.position.y = height / 2;
                group.add(building);
                
                // Windows (lights)
                const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
                for (let y = 2; y < height - 2; y += 3) {
                    for (let x = -1; x <= 1; x++) {
                        const win = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 1.5), windowMat);
                        win.position.set(x * 1.2, y, 2.01 + Math.random() * 0.5);
                        group.add(win);
                    }
                }
            } else if (type === 'mediterranean') {
                const variety = Math.random();
                
                if (variety < 0.5) {
                    // Cypress tree (classic Italian countryside)
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.3, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0x3d2817 })
                    );
                    trunk.position.y = 4;
                    group.add(trunk);
                    
                    const foliage = new THREE.Mesh(
                        new THREE.ConeGeometry(1.2, 10, 8),
                        new THREE.MeshStandardMaterial({ color: 0x2f4f2f })
                    );
                    foliage.position.y = 7;
                    group.add(foliage);
                } else if (variety < 0.7) {
                    // Olive tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.6, 4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x5a4a3a })
                    );
                    trunk.position.y = 2;
                    trunk.rotation.z = 0.1;
                    group.add(trunk);
                    
                    const foliageMat = new THREE.MeshStandardMaterial({ color: 0x556b2f });
                    const foliage = new THREE.Mesh(new THREE.SphereGeometry(3, 8, 8), foliageMat);
                    foliage.position.y = 5;
                    foliage.scale.y = 0.7;
                    group.add(foliage);
                } else if (variety < 0.85) {
                    // Stone ruin/column
                    const stoneMat = new THREE.MeshStandardMaterial({ color: 0xd4c4a8, roughness: 0.9 });
                    
                    const column = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.8, 1, 6, 12),
                        stoneMat
                    );
                    column.position.y = 3;
                    group.add(column);
                    
                    // Capital on top
                    const capital = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.8, 2),
                        stoneMat
                    );
                    capital.position.y = 6.4;
                    group.add(capital);
                } else {
                    // Vineyard posts
                    const postMat = new THREE.MeshStandardMaterial({ color: 0x4a3a2a });
                    for (let i = 0; i < 3; i++) {
                        const post = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.08, 0.1, 2.5, 6),
                            postMat
                        );
                        post.position.set(i * 2 - 2, 1.25, 0);
                        group.add(post);
                    }
                    // Wire
                    const wire = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.02, 0.02, 5, 4),
                        new THREE.MeshStandardMaterial({ color: 0x333333 })
                    );
                    wire.rotation.z = Math.PI / 2;
                    wire.position.y = 2;
                    group.add(wire);
                }
            }
            
            return group;
        }
        
        // Create detailed low-poly civilian car (matching cop car quality)
        function createCivilianCar(color, style) {
            const car = new THREE.Group();
            
            // Track lights for dynamic effects (brake lights, turn signals)
            car.userData.taillights = []; // Will hold taillight meshes
            car.userData.leftBlinkers = []; // Left turn signals
            car.userData.rightBlinkers = []; // Right turn signals
            car.userData.baseTaillightIntensity = 2.0; // Normal taillight brightness
            car.userData.brakeLightIntensity = 5.0; // Bright brake lights
            car.userData.baseBlinkerIntensity = 0.3; // Dim when off
            car.userData.activeBlinkerIntensity = 4.0; // Bright when flashing
            car.userData.blinkerPhase = 0; // For flashing animation
            
            // High quality materials - enhanced for more realistic car paint look
            const bodyMat = new THREE.MeshStandardMaterial({ 
                color: color, 
                metalness: 0.8,  // Higher metalness for car paint sheen
                roughness: 0.18  // Lower roughness for glossier finish
            });
            const glassMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a3344,  // Darker tint for more realistic glass
                metalness: 0.95, 
                roughness: 0.05,  // Very smooth glass
                transparent: true,
                opacity: 0.65
            });
            const trimMat = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a0a,  // Near black for trim
                roughness: 0.4,
                metalness: 0.1
            });
            const wheelMat = new THREE.MeshStandardMaterial({ 
                color: 0x151515,  // Dark rubber color
                roughness: 0.92 
            });
            const chromeMat = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,  // Brighter chrome
                metalness: 1.0, 
                roughness: 0.08  // More reflective
            });
            // Glowing light materials with enhanced emissive for realistic lighting effect
            const headlightMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0xffffee, 
                emissiveIntensity: 3.5,  // Brighter headlights
                roughness: 0.1
            });
            const ledMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const taillightMat = new THREE.MeshStandardMaterial({ 
                color: 0xff2200, 
                emissive: 0xff1100, 
                emissiveIntensity: 2.5,  // Slightly brighter taillights
                roughness: 0.25
            });
            const blinkerMat = new THREE.MeshStandardMaterial({ 
                color: 0xffaa00,  // More orange/amber
                emissive: 0xff8800, 
                emissiveIntensity: 0.5, // Slightly brighter base state
                roughness: 0.25
            });
            
            if (style === 'sedan') {
                // ================================================================
                // HIGH-QUALITY LOW-POLY SEDAN (Toyota Camry / Honda Accord style)
                // Smooth curved surfaces using ExtrudeGeometry with bevels
                // Realistic proportions: 4.8m long, 1.4m tall, 1.8m wide
                // ================================================================
                
                // --- MAIN BODY PROFILE (Side silhouette) ---
                // Create a smooth sedan shape using Shape + ExtrudeGeometry
                const bodyShape = new THREE.Shape();
                
                // Start at front bumper bottom
                bodyShape.moveTo(-2.4, 0.25);
                
                // Front bumper curve up
                bodyShape.quadraticCurveTo(-2.5, 0.5, -2.35, 0.7);
                
                // Hood line (gentle slope up)
                bodyShape.quadraticCurveTo(-1.8, 0.85, -1.2, 0.95);
                
                // A-pillar / windshield base
                bodyShape.lineTo(-0.9, 0.98);
                
                // Windshield (smooth curve up)
                bodyShape.quadraticCurveTo(-0.6, 1.35, -0.2, 1.52);
                
                // Roof line (gentle arc)
                bodyShape.quadraticCurveTo(0.4, 1.58, 1.0, 1.52);
                
                // C-pillar / rear window
                bodyShape.quadraticCurveTo(1.4, 1.4, 1.7, 1.15);
                
                // Trunk deck
                bodyShape.quadraticCurveTo(2.0, 1.05, 2.25, 0.95);
                
                // Rear bumper curve down
                bodyShape.quadraticCurveTo(2.45, 0.8, 2.4, 0.5);
                bodyShape.quadraticCurveTo(2.35, 0.3, 2.2, 0.25);
                
                // Bottom of car (with wheel well cutouts implied by shape)
                bodyShape.lineTo(-2.4, 0.25);
                
                // Extrude the body shape with smooth bevels
                const bodyExtrudeSettings = {
                    steps: 1,
                    depth: 1.8,
                    bevelEnabled: true,
                    bevelThickness: 0.08,
                    bevelSize: 0.06,
                    bevelSegments: 3
                };
                
                const bodyGeo = new THREE.ExtrudeGeometry(bodyShape, bodyExtrudeSettings);
                bodyGeo.center();
                const mainBody = new THREE.Mesh(bodyGeo, bodyMat);
                mainBody.rotation.y = Math.PI / 2;
                mainBody.position.set(0, 0.65, 0);
                mainBody.castShadow = true;
                car.add(mainBody);
                
                // --- LOWER BODY PANEL (rocker panels / side skirts) ---
                const lowerShape = new THREE.Shape();
                lowerShape.moveTo(-2.3, 0.15);
                lowerShape.lineTo(2.2, 0.15);
                lowerShape.lineTo(2.2, 0.4);
                lowerShape.quadraticCurveTo(1.5, 0.42, 1.0, 0.35);
                // Front wheel arch
                lowerShape.quadraticCurveTo(0.0, 0.3, -1.0, 0.35);
                lowerShape.quadraticCurveTo(-1.5, 0.42, -2.3, 0.4);
                lowerShape.lineTo(-2.3, 0.15);
                
                const lowerExtrudeSettings = {
                    steps: 1,
                    depth: 1.85,
                    bevelEnabled: true,
                    bevelThickness: 0.03,
                    bevelSize: 0.02,
                    bevelSegments: 2
                };
                
                const lowerGeo = new THREE.ExtrudeGeometry(lowerShape, lowerExtrudeSettings);
                lowerGeo.center();
                const lowerBody = new THREE.Mesh(lowerGeo, bodyMat);
                lowerBody.rotation.y = Math.PI / 2;
                lowerBody.position.set(0, 0.15, 0);
                lowerBody.castShadow = true;
                car.add(lowerBody);
                
                // --- GREENHOUSE (Windows area with tinted glass) ---
                const cabinShape = new THREE.Shape();
                cabinShape.moveTo(-0.85, 1.0);
                cabinShape.quadraticCurveTo(-0.5, 1.38, -0.15, 1.48);
                cabinShape.quadraticCurveTo(0.45, 1.54, 0.95, 1.48);
                cabinShape.quadraticCurveTo(1.3, 1.35, 1.55, 1.1);
                cabinShape.lineTo(1.55, 1.0);
                cabinShape.lineTo(-0.85, 1.0);
                
                const cabinExtrudeSettings = {
                    steps: 1,
                    depth: 1.55,
                    bevelEnabled: true,
                    bevelThickness: 0.04,
                    bevelSize: 0.03,
                    bevelSegments: 2
                };
                
                const cabinGeo = new THREE.ExtrudeGeometry(cabinShape, cabinExtrudeSettings);
                cabinGeo.center();
                const cabin = new THREE.Mesh(cabinGeo, glassMat);
                cabin.rotation.y = Math.PI / 2;
                cabin.position.set(0.35, 0.52, 0);
                car.add(cabin);
                
                // --- WINDOW CHROME TRIM ---
                // Front windshield trim
                const windshieldTrimShape = new THREE.Shape();
                windshieldTrimShape.moveTo(-0.88, 0.98);
                windshieldTrimShape.quadraticCurveTo(-0.55, 1.36, -0.18, 1.5);
                
                const trimCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(-0.88, 0.98, 0),
                    new THREE.Vector3(-0.65, 1.22, 0),
                    new THREE.Vector3(-0.4, 1.4, 0),
                    new THREE.Vector3(-0.18, 1.5, 0)
                ]);
                const trimTubeGeo = new THREE.TubeGeometry(trimCurve, 12, 0.025, 6, false);
                
                [-0.82, 0.82].forEach(z => {
                    const wsTrim = new THREE.Mesh(trimTubeGeo, chromeMat);
                    wsTrim.position.set(0, 0.52, z);
                    car.add(wsTrim);
                });
                
                // Rear window trim
                const rearTrimCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0.95, 1.5, 0),
                    new THREE.Vector3(1.2, 1.38, 0),
                    new THREE.Vector3(1.45, 1.2, 0),
                    new THREE.Vector3(1.58, 1.05, 0)
                ]);
                const rearTrimTubeGeo = new THREE.TubeGeometry(rearTrimCurve, 12, 0.025, 6, false);
                
                [-0.78, 0.78].forEach(z => {
                    const rwTrim = new THREE.Mesh(rearTrimTubeGeo, chromeMat);
                    rwTrim.position.set(0, 0.52, z);
                    car.add(rwTrim);
                });
                
                // Roof trim (chrome strip along roof edge)
                [-0.8, 0.8].forEach(z => {
                    const roofTrim = new THREE.Mesh(
                        new THREE.BoxGeometry(1.6, 0.02, 0.04),
                        chromeMat
                    );
                    roofTrim.position.set(0.4, 1.56, z);
                    car.add(roofTrim);
                });
                
                // --- WINDOW PILLARS (A, B, C pillars - gloss black trim) ---
                const pillarMat = new THREE.MeshStandardMaterial({ 
                    color: 0x111111, 
                    roughness: 0.2,
                    metalness: 0.3
                });
                
                [-0.83, 0.83].forEach(z => {
                    // A-Pillar (windshield pillar) - angled
                    const aPillarCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(-0.9, 1.0, z),
                        new THREE.Vector3(-0.7, 1.25, z),
                        new THREE.Vector3(-0.45, 1.42, z),
                        new THREE.Vector3(-0.2, 1.52, z)
                    ]);
                    const aPillarGeo = new THREE.TubeGeometry(aPillarCurve, 10, 0.035, 6, false);
                    const aPillar = new THREE.Mesh(aPillarGeo, pillarMat);
                    car.add(aPillar);
                    
                    // B-Pillar (center pillar between front/rear doors)
                    const bPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.55, 0.04),
                        pillarMat
                    );
                    bPillar.position.set(0.35, 1.28, z);
                    car.add(bPillar);
                    
                    // C-Pillar (rear pillar) - wider for sedan look
                    const cPillarCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(0.95, 1.5, z),
                        new THREE.Vector3(1.15, 1.4, z),
                        new THREE.Vector3(1.35, 1.25, z),
                        new THREE.Vector3(1.55, 1.08, z)
                    ]);
                    const cPillarGeo = new THREE.TubeGeometry(cPillarCurve, 10, 0.045, 6, false);
                    const cPillar = new THREE.Mesh(cPillarGeo, pillarMat);
                    car.add(cPillar);
                });
                
                // --- DOOR PANEL LINES ---
                // Front door line
                [-0.92, 0.92].forEach(z => {
                    // Vertical front door edge (A-pillar area)
                    const doorVertFront = new THREE.Mesh(
                        new THREE.BoxGeometry(0.012, 0.5, 0.015),
                        trimMat
                    );
                    doorVertFront.position.set(-0.85, 0.65, z);
                    car.add(doorVertFront);
                    
                    // Vertical door edge (B-pillar area - door gap)
                    const doorVert = new THREE.Mesh(
                        new THREE.BoxGeometry(0.012, 0.6, 0.015),
                        trimMat
                    );
                    doorVert.position.set(0.32, 0.7, z);
                    car.add(doorVert);
                    
                    // Horizontal door line (belt line - character line)
                    const doorHoriz = new THREE.Mesh(
                        new THREE.BoxGeometry(2.8, 0.012, 0.015),
                        trimMat
                    );
                    doorHoriz.position.set(-0.05, 0.9, z);
                    car.add(doorHoriz);
                    
                    // Lower door crease (body sculpt line)
                    const doorCrease = new THREE.Mesh(
                        new THREE.BoxGeometry(3.0, 0.008, 0.012),
                        trimMat
                    );
                    doorCrease.position.set(-0.1, 0.55, z);
                    car.add(doorCrease);
                    
                    // Shoulder line (upper body crease)
                    const shoulderLine = new THREE.Mesh(
                        new THREE.BoxGeometry(2.2, 0.006, 0.01),
                        trimMat
                    );
                    shoulderLine.position.set(0, 0.75, z);
                    car.add(shoulderLine);
                });
                
                // --- DOOR HANDLES (chrome) ---
                [-0.93, 0.93].forEach(z => {
                    // Front door handle
                    const handleFront = new THREE.Mesh(
                        new THREE.BoxGeometry(0.18, 0.04, 0.03),
                        chromeMat
                    );
                    handleFront.position.set(-0.5, 0.85, z);
                    car.add(handleFront);
                    
                    // Rear door handle
                    const handleRear = new THREE.Mesh(
                        new THREE.BoxGeometry(0.18, 0.04, 0.03),
                        chromeMat
                    );
                    handleRear.position.set(0.5, 0.85, z);
                    car.add(handleRear);
                });
                
                // --- SIDE MIRRORS ---
                [-0.98, 0.98].forEach(z => {
                    // Mirror arm
                    const mirrorArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.04, 0.12),
                        trimMat
                    );
                    mirrorArm.position.set(-0.85, 1.15, z);
                    car.add(mirrorArm);
                    
                    // Mirror housing (teardrop shape approximation)
                    const mirrorShape = new THREE.Shape();
                    mirrorShape.moveTo(0, 0);
                    mirrorShape.quadraticCurveTo(-0.06, 0.08, 0, 0.14);
                    mirrorShape.quadraticCurveTo(0.08, 0.08, 0, 0);
                    
                    const mirrorExtrudeSettings = {
                        steps: 1,
                        depth: 0.06,
                        bevelEnabled: true,
                        bevelThickness: 0.015,
                        bevelSize: 0.015,
                        bevelSegments: 2
                    };
                    
                    const mirrorGeo = new THREE.ExtrudeGeometry(mirrorShape, mirrorExtrudeSettings);
                    const mirror = new THREE.Mesh(mirrorGeo, bodyMat);
                    mirror.rotation.x = Math.PI / 2;
                    mirror.position.set(-0.92, 1.08, z > 0 ? z + 0.03 : z - 0.09);
                    car.add(mirror);
                    
                    // Mirror glass
                    const mirrorGlass = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.08, 0.1),
                        new THREE.MeshStandardMaterial({ color: 0x223344, metalness: 0.9, roughness: 0.1 })
                    );
                    mirrorGlass.rotation.y = z > 0 ? Math.PI / 2 : -Math.PI / 2;
                    mirrorGlass.position.set(-0.92, 1.12, z > 0 ? z + 0.1 : z - 0.1);
                    car.add(mirrorGlass);
                    
                    // --- TURN SIGNAL REPEATER (modern LED strip on mirror housing) ---
                    const turnSignalMat = new THREE.MeshStandardMaterial({ 
                        color: 0xff8800, 
                        emissive: 0xff6600, 
                        emissiveIntensity: 1.2,
                        roughness: 0.3
                    });
                    
                    // Main turn signal strip (horizontal LED bar)
                    const turnSignalGeo = new THREE.BoxGeometry(0.06, 0.012, 0.025);
                    const turnSignal = new THREE.Mesh(turnSignalGeo, turnSignalMat);
                    turnSignal.position.set(-0.92, 1.05, z > 0 ? z + 0.06 : z - 0.06);
                    car.add(turnSignal);
                    
                    // Turn signal housing/bezel (dark surround)
                    const signalBezelGeo = new THREE.BoxGeometry(0.07, 0.018, 0.03);
                    const signalBezel = new THREE.Mesh(signalBezelGeo, trimMat);
                    signalBezel.position.set(-0.92, 1.05, z > 0 ? z + 0.058 : z - 0.058);
                    car.add(signalBezel);
                });
                
                // --- HOOD DETAILS ---
                // Hood crease lines
                [-0.3, 0.3].forEach(z => {
                    const hoodCrease = new THREE.Mesh(
                        new THREE.BoxGeometry(1.0, 0.008, 0.015),
                        trimMat
                    );
                    hoodCrease.position.set(-1.6, 0.94, z);
                    car.add(hoodCrease);
                });
                
                // --- TRUNK LID ---
                // Trunk crease
                const trunkCrease = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.008, 1.3),
                    trimMat
                );
                trunkCrease.position.set(1.95, 1.0, 0);
                car.add(trunkCrease);
                
                // Trunk lip spoiler (subtle)
                const trunkLipShape = new THREE.Shape();
                trunkLipShape.moveTo(-0.65, 0);
                trunkLipShape.quadraticCurveTo(0, 0.04, 0.65, 0);
                trunkLipShape.lineTo(0.65, -0.02);
                trunkLipShape.lineTo(-0.65, -0.02);
                
                const trunkLipExtrudeSettings = {
                    steps: 1,
                    depth: 0.08,
                    bevelEnabled: false
                };
                
                const trunkLipGeo = new THREE.ExtrudeGeometry(trunkLipShape, trunkLipExtrudeSettings);
                const trunkLip = new THREE.Mesh(trunkLipGeo, bodyMat);
                trunkLip.rotation.x = -Math.PI / 2;
                trunkLip.position.set(2.15, 1.0, -0.04);
                car.add(trunkLip);
                
                // --- HEADLIGHTS (detailed, modern style) ---
                [-0.65, 0.65].forEach(z => {
                    // Headlight housing (swept back shape)
                    const hlShape = new THREE.Shape();
                    hlShape.moveTo(0, 0);
                    hlShape.quadraticCurveTo(0.2, 0.12, 0.35, 0.08);
                    hlShape.lineTo(0.35, -0.08);
                    hlShape.quadraticCurveTo(0.2, -0.12, 0, 0);
                    
                    const hlExtrudeSettings = {
                        steps: 1,
                        depth: 0.35,
                        bevelEnabled: true,
                        bevelThickness: 0.02,
                        bevelSize: 0.02,
                        bevelSegments: 2
                    };
                    
                    const hlGeo = new THREE.ExtrudeGeometry(hlShape, hlExtrudeSettings);
                    const hlHousing = new THREE.Mesh(hlGeo, new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.3,
                        roughness: 0.1 
                    }));
                    hlHousing.rotation.y = Math.PI / 2;
                    hlHousing.position.set(-2.35, 0.8, z > 0 ? z - 0.18 : z + 0.18);
                    car.add(hlHousing);
                    
                    // Main beam (projector lens - larger and brighter)
                    const mainBeam = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 16, 12),
                        headlightMat
                    );
                    mainBeam.position.set(-2.38, 0.82, z);
                    car.add(mainBeam);
                    
                    // Secondary low beam (adds depth to light cluster)
                    const lowBeam = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06, 12, 8),
                        headlightMat
                    );
                    lowBeam.position.set(-2.36, 0.75, z);
                    car.add(lowBeam);
                    
                    // DRL strip (LED style) - brighter with emissive
                    const drlMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        emissive: 0xffffff, 
                        emissiveIntensity: 2.5,
                        roughness: 0.1
                    });
                    const drlCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(-2.3, 0.72, z),
                        new THREE.Vector3(-2.35, 0.74, z > 0 ? z + 0.12 : z - 0.12),
                        new THREE.Vector3(-2.25, 0.76, z > 0 ? z + 0.2 : z - 0.2)
                    ]);
                    const drlGeo = new THREE.TubeGeometry(drlCurve, 12, 0.018, 8, false);
                    const drl = new THREE.Mesh(drlGeo, drlMat);
                    car.add(drl);
                });
                
                // --- TAILLIGHTS (detailed LED style) ---
                [-0.6, 0.6].forEach(z => {
                    // Taillight housing
                    const tlShape = new THREE.Shape();
                    tlShape.moveTo(0, -0.12);
                    tlShape.quadraticCurveTo(-0.08, -0.14, -0.12, -0.08);
                    tlShape.lineTo(-0.12, 0.08);
                    tlShape.quadraticCurveTo(-0.08, 0.14, 0, 0.12);
                    tlShape.lineTo(0, -0.12);
                    
                    const tlExtrudeSettings = {
                        steps: 1,
                        depth: 0.3,
                        bevelEnabled: true,
                        bevelThickness: 0.015,
                        bevelSize: 0.015,
                        bevelSegments: 2
                    };
                    
                    const tlGeo = new THREE.ExtrudeGeometry(tlShape, tlExtrudeSettings);
                    const tlHousing = new THREE.Mesh(tlGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x330000, 
                        transparent: true, 
                        opacity: 0.7 
                    }));
                    tlHousing.rotation.y = -Math.PI / 2;
                    tlHousing.position.set(2.32, 0.9, z > 0 ? z - 0.15 : z + 0.15);
                    car.add(tlHousing);
                    
                    // Main red brake light - clone material so each car has independent control
                    const brakeLightMat = taillightMat.clone();
                    const brakeLight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.16, 0.22),
                        brakeLightMat
                    );
                    brakeLight.position.set(2.35, 0.9, z);
                    car.add(brakeLight);
                    car.userData.taillights.push(brakeLight); // Track for brake light effect
                    
                    // Turn signal (amber/orange) - clone material for independent flash control
                    const turnSignalMat = blinkerMat.clone();
                    const turnSignal = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.06, 0.18),
                        turnSignalMat
                    );
                    turnSignal.position.set(2.35, 0.75, z);
                    car.add(turnSignal);
                    // Track by side: z > 0 = right side, z < 0 = left side
                    if (z > 0) {
                        car.userData.rightBlinkers.push(turnSignal);
                    } else {
                        car.userData.leftBlinkers.push(turnSignal);
                    }
                    
                    // Reverse light (white)
                    const reverseLight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.05, 0.1),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    reverseLight.position.set(2.35, 0.68, z);
                    car.add(reverseLight);
                });
                
                // Center tail light strip (connecting bar) - also tracked for brake effect
                const centerTaillightMat = taillightMat.clone();
                const centerTaillight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.03, 0.04, 0.8),
                    centerTaillightMat
                );
                centerTaillight.position.set(2.36, 0.92, 0);
                car.add(centerTaillight);
                car.userData.taillights.push(centerTaillight);
                
                // --- FRONT GRILLE ---
                const grilleShape = new THREE.Shape();
                grilleShape.moveTo(-0.55, 0);
                grilleShape.quadraticCurveTo(-0.6, 0.08, -0.5, 0.15);
                grilleShape.lineTo(0.5, 0.15);
                grilleShape.quadraticCurveTo(0.6, 0.08, 0.55, 0);
                grilleShape.lineTo(-0.55, 0);
                
                const grilleExtrudeSettings = {
                    steps: 1,
                    depth: 0.06,
                    bevelEnabled: false
                };
                
                const grilleGeo = new THREE.ExtrudeGeometry(grilleShape, grilleExtrudeSettings);
                const grille = new THREE.Mesh(grilleGeo, trimMat);
                grille.rotation.x = Math.PI / 2;
                grille.position.set(-2.4, 0.55, 0.03);
                car.add(grille);
                
                // Chrome grille surround
                const grilleTrimCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(-2.38, 0.55, -0.5),
                    new THREE.Vector3(-2.42, 0.62, 0),
                    new THREE.Vector3(-2.38, 0.55, 0.5)
                ]);
                const grilleTrimGeo = new THREE.TubeGeometry(grilleTrimCurve, 12, 0.02, 6, false);
                const grilleTrim = new THREE.Mesh(grilleTrimGeo, chromeMat);
                car.add(grilleTrim);
                
                // --- LICENSE PLATE AREA (front) ---
                const frontPlate = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.12, 0.35),
                    new THREE.MeshStandardMaterial({ color: 0xeeeeee })
                );
                frontPlate.position.set(-2.42, 0.42, 0);
                car.add(frontPlate);
                
                // --- LICENSE PLATE AREA (rear) ---
                const rearPlateRecess = new THREE.Mesh(
                    new THREE.BoxGeometry(0.03, 0.18, 0.42),
                    trimMat
                );
                rearPlateRecess.position.set(2.34, 0.55, 0);
                car.add(rearPlateRecess);
                
                const rearPlate = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.12, 0.35),
                    new THREE.MeshStandardMaterial({ color: 0xffffee })
                );
                rearPlate.position.set(2.36, 0.55, 0);
                car.add(rearPlate);
                
                // Plate lights
                [-0.12, 0.12].forEach(z => {
                    const plateLight = new THREE.Mesh(
                        new THREE.SphereGeometry(0.02, 6, 4),
                        new THREE.MeshBasicMaterial({ color: 0xffffcc })
                    );
                    plateLight.position.set(2.34, 0.68, z);
                    car.add(plateLight);
                });
                
                // --- HIGH-DETAIL WHEELS with brake rotors and calipers ---
                // Initialize wheel tracking for animation
                car.userData.wheels = [];
                car.userData.wheelRadius = 0.38;
                
                const wheelRadius = 0.38;
                const tireWidth = 0.24;
                const wheelY = 0.38;
                const frontWheelX = -1.45;
                const rearWheelX = 1.5;
                const wheelZ = 0.82;
                
                // Wheel positions: [x, y, z, isRightSide]
                const wheelPositions = [
                    [frontWheelX, wheelY, wheelZ, true],    // Front right
                    [frontWheelX, wheelY, -wheelZ, false],  // Front left
                    [rearWheelX, wheelY, wheelZ, true],     // Rear right
                    [rearWheelX, wheelY, -wheelZ, false]    // Rear left
                ];
                
                wheelPositions.forEach(([wx, wy, wz, isRight], idx) => {
                    const wheelGroup = new THREE.Group();
                    wheelGroup.position.set(wx, wy, wz);
                    
                    // Direction multiplier: +1 for right side (outer = +z), -1 for left side (outer = -z)
                    const outDir = isRight ? 1 : -1;
                    
                    // --- TIRE (using LatheGeometry for rounded sidewall profile) ---
                    const tireProfile = [];
                    // Inner sidewall
                    tireProfile.push(new THREE.Vector2(wheelRadius - 0.06, -tireWidth / 2));
                    tireProfile.push(new THREE.Vector2(wheelRadius - 0.02, -tireWidth / 2 + 0.02));
                    // Inner shoulder curve
                    tireProfile.push(new THREE.Vector2(wheelRadius + 0.01, -tireWidth / 2 + 0.04));
                    // Tread surface (slightly crowned)
                    tireProfile.push(new THREE.Vector2(wheelRadius + 0.025, -tireWidth / 4));
                    tireProfile.push(new THREE.Vector2(wheelRadius + 0.03, 0));
                    tireProfile.push(new THREE.Vector2(wheelRadius + 0.025, tireWidth / 4));
                    // Outer shoulder curve
                    tireProfile.push(new THREE.Vector2(wheelRadius + 0.01, tireWidth / 2 - 0.04));
                    tireProfile.push(new THREE.Vector2(wheelRadius - 0.02, tireWidth / 2 - 0.02));
                    // Outer sidewall
                    tireProfile.push(new THREE.Vector2(wheelRadius - 0.06, tireWidth / 2));
                    
                    const tireGeo = new THREE.LatheGeometry(tireProfile, 32);
                    tireGeo.rotateX(Math.PI / 2);
                    const tire = new THREE.Mesh(tireGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a, 
                        roughness: 0.92,
                        metalness: 0.0
                    }));
                    tire.castShadow = true;
                    wheelGroup.add(tire);
                    
                    // --- TIRE SIDEWALL TEXT (subtle raised lettering effect) ---
                    const sidewallRing = new THREE.Mesh(
                        new THREE.TorusGeometry(wheelRadius - 0.03, 0.008, 6, 24),
                        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 })
                    );
                    sidewallRing.rotation.x = Math.PI / 2;
                    sidewallRing.position.z = outDir * (tireWidth / 2 - 0.025);
                    wheelGroup.add(sidewallRing);
                    
                    // --- WHEEL RIM (5-spoke alloy design) ---
                    const rimRadius = wheelRadius - 0.08;
                    const rimOuterZ = outDir * (tireWidth / 2 - 0.03);
                    
                    // Rim lip (outer edge)
                    const rimLipGeo = new THREE.TorusGeometry(rimRadius + 0.02, 0.018, 8, 32);
                    const rimLip = new THREE.Mesh(rimLipGeo, chromeMat);
                    rimLip.rotation.x = Math.PI / 2;
                    rimLip.position.z = rimOuterZ;
                    wheelGroup.add(rimLip);
                    
                    // Rim barrel (connects to hub)
                    const rimBarrelGeo = new THREE.CylinderGeometry(rimRadius, rimRadius - 0.02, tireWidth - 0.06, 24, 1, true);
                    const rimBarrel = new THREE.Mesh(rimBarrelGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x555555, 
                        metalness: 0.6, 
                        roughness: 0.4,
                        side: THREE.DoubleSide
                    }));
                    rimBarrel.rotation.x = Math.PI / 2;
                    wheelGroup.add(rimBarrel);
                    
                    // Rim face (dish - slightly concave)
                    const rimFaceGeo = new THREE.CylinderGeometry(rimRadius - 0.01, rimRadius - 0.03, 0.025, 24);
                    const rimFace = new THREE.Mesh(rimFaceGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x777777, 
                        metalness: 0.85, 
                        roughness: 0.2 
                    }));
                    rimFace.rotation.x = Math.PI / 2;
                    rimFace.position.z = rimOuterZ - outDir * 0.02;
                    wheelGroup.add(rimFace);
                    
                    // 5-Spoke design (twin-spoke style)
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        
                        // Main spoke
                        const spokeLen = rimRadius - 0.06;
                        const spokeGeo = new THREE.BoxGeometry(spokeLen, 0.045, 0.025);
                        const spoke = new THREE.Mesh(spokeGeo, chromeMat);
                        spoke.position.set(
                            Math.cos(angle) * (spokeLen / 2),
                            Math.sin(angle) * (spokeLen / 2),
                            rimOuterZ - outDir * 0.01
                        );
                        spoke.rotation.z = angle;
                        wheelGroup.add(spoke);
                        
                        // Secondary spoke (twin design)
                        const spoke2Geo = new THREE.BoxGeometry(spokeLen * 0.85, 0.03, 0.02);
                        const spoke2 = new THREE.Mesh(spoke2Geo, new THREE.MeshStandardMaterial({ 
                            color: 0x666666, 
                            metalness: 0.7, 
                            roughness: 0.3 
                        }));
                        spoke2.position.set(
                            Math.cos(angle + 0.15) * (spokeLen / 2 - 0.02),
                            Math.sin(angle + 0.15) * (spokeLen / 2 - 0.02),
                            rimOuterZ - outDir * 0.015
                        );
                        spoke2.rotation.z = angle + 0.15;
                        wheelGroup.add(spoke2);
                    }
                    
                    // Center cap (raised dome)
                    const centerCapGeo = new THREE.SphereGeometry(0.05, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const centerCap = new THREE.Mesh(centerCapGeo, chromeMat);
                    centerCap.rotation.x = isRight ? -Math.PI / 2 : Math.PI / 2;
                    centerCap.position.z = rimOuterZ + outDir * 0.01;
                    wheelGroup.add(centerCap);
                    
                    // Center cap ring
                    const capRingGeo = new THREE.TorusGeometry(0.045, 0.008, 6, 16);
                    const capRing = new THREE.Mesh(capRingGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x333333, 
                        metalness: 0.5, 
                        roughness: 0.5 
                    }));
                    capRing.rotation.x = Math.PI / 2;
                    capRing.position.z = rimOuterZ;
                    wheelGroup.add(capRing);
                    
                    // Lug nuts (5 in a circle)
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2 + Math.PI / 10;
                        const lugGeo = new THREE.CylinderGeometry(0.012, 0.014, 0.015, 6);
                        const lug = new THREE.Mesh(lugGeo, new THREE.MeshStandardMaterial({ 
                            color: 0x444444, 
                            metalness: 0.6, 
                            roughness: 0.4 
                        }));
                        lug.rotation.x = Math.PI / 2;
                        lug.position.set(
                            Math.cos(angle) * 0.035,
                            Math.sin(angle) * 0.035,
                            rimOuterZ + outDir * 0.008
                        );
                        wheelGroup.add(lug);
                    }
                    
                    // --- BRAKE ROTOR (vented disc) ---
                    const rotorRadius = rimRadius - 0.04;
                    const rotorGeo = new THREE.CylinderGeometry(rotorRadius, rotorRadius, 0.025, 32);
                    const rotorMat = new THREE.MeshStandardMaterial({ 
                        color: 0x888888, 
                        metalness: 0.75, 
                        roughness: 0.35 
                    });
                    const rotor = new THREE.Mesh(rotorGeo, rotorMat);
                    rotor.rotation.x = Math.PI / 2;
                    rotor.position.z = -outDir * 0.02;
                    wheelGroup.add(rotor);
                    
                    // Rotor inner hub
                    const rotorHubGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.03, 16);
                    const rotorHub = new THREE.Mesh(rotorHubGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x555555, 
                        metalness: 0.6, 
                        roughness: 0.5 
                    }));
                    rotorHub.rotation.x = Math.PI / 2;
                    rotorHub.position.z = -outDir * 0.02;
                    wheelGroup.add(rotorHub);
                    
                    // --- CROSS-DRILLED BRAKE ROTOR HOLES (performance look) ---
                    const holeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                    
                    // Outer ring of cross-drilled holes
                    for (let i = 0; i < 18; i++) {
                        const holeAngle = (i / 18) * Math.PI * 2;
                        const holeGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.028, 6);
                        const hole = new THREE.Mesh(holeGeo, holeMat);
                        hole.rotation.x = Math.PI / 2;
                        hole.position.set(
                            Math.cos(holeAngle) * (rotorRadius - 0.035),
                            Math.sin(holeAngle) * (rotorRadius - 0.035),
                            -outDir * 0.02
                        );
                        wheelGroup.add(hole);
                    }
                    
                    // Inner ring of cross-drilled holes (staggered)
                    for (let i = 0; i < 12; i++) {
                        const holeAngle = (i / 12) * Math.PI * 2 + Math.PI / 24; // Offset for staggered look
                        const holeGeo = new THREE.CylinderGeometry(0.007, 0.007, 0.028, 6);
                        const hole = new THREE.Mesh(holeGeo, holeMat);
                        hole.rotation.x = Math.PI / 2;
                        hole.position.set(
                            Math.cos(holeAngle) * (rotorRadius - 0.07),
                            Math.sin(holeAngle) * (rotorRadius - 0.07),
                            -outDir * 0.02
                        );
                        wheelGroup.add(hole);
                    }
                    
                    // Rotor ventilation slots (curved for heat dissipation)
                    for (let i = 0; i < 20; i++) {
                        const slotAngle = (i / 20) * Math.PI * 2;
                        const slotGeo = new THREE.BoxGeometry(0.035, 0.004, 0.006);
                        const slot = new THREE.Mesh(slotGeo, holeMat);
                        slot.position.set(
                            Math.cos(slotAngle) * (rotorRadius - 0.1),
                            Math.sin(slotAngle) * (rotorRadius - 0.1),
                            -outDir * 0.02
                        );
                        slot.rotation.z = slotAngle + 0.25;
                        wheelGroup.add(slot);
                    }
                    
                    // --- BRAKE CALIPER (multi-piston style) ---
                    const caliperGroup = new THREE.Group();
                    
                    // Main caliper body
                    const caliperBodyGeo = new THREE.BoxGeometry(0.1, 0.065, 0.045);
                    const caliperMat = new THREE.MeshStandardMaterial({ 
                        color: 0xdd0000, // Red performance calipers
                        metalness: 0.4, 
                        roughness: 0.45 
                    });
                    const caliperBody = new THREE.Mesh(caliperBodyGeo, caliperMat);
                    caliperGroup.add(caliperBody);
                    
                    // Caliper mounting bracket
                    const bracketGeo = new THREE.BoxGeometry(0.025, 0.09, 0.035);
                    const bracketMat = new THREE.MeshStandardMaterial({ 
                        color: 0x333333, 
                        metalness: 0.5, 
                        roughness: 0.6 
                    });
                    const bracket = new THREE.Mesh(bracketGeo, bracketMat);
                    bracket.position.set(-0.055, 0, 0);
                    caliperGroup.add(bracket);
                    
                    // Caliper pistons (visible bumps)
                    [-0.025, 0.025].forEach(px => {
                        const pistonGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.01, 8);
                        const piston = new THREE.Mesh(pistonGeo, new THREE.MeshStandardMaterial({ 
                            color: 0xaa0000, 
                            metalness: 0.3, 
                            roughness: 0.5 
                        }));
                        piston.rotation.x = Math.PI / 2;
                        piston.position.set(px, 0.035, 0);
                        caliperGroup.add(piston);
                    });
                    
                    // Brake line fitting
                    const fittingGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.02, 6);
                    const fitting = new THREE.Mesh(fittingGeo, chromeMat);
                    fitting.rotation.z = Math.PI / 2;
                    fitting.position.set(0.06, 0.02, 0);
                    caliperGroup.add(fitting);
                    
                    // Caliper lettering detail (raised section for brand effect)
                    const letteringGeo = new THREE.BoxGeometry(0.06, 0.035, 0.008);
                    const letteringMat = new THREE.MeshStandardMaterial({ 
                        color: 0xee1111, // Slightly brighter red
                        metalness: 0.3, 
                        roughness: 0.5 
                    });
                    const lettering = new THREE.Mesh(letteringGeo, letteringMat);
                    lettering.position.set(0, 0, outDir * 0.024);
                    caliperGroup.add(lettering);
                    
                    // Position caliper at top of rotor
                    caliperGroup.position.set(
                        0,
                        rotorRadius - 0.04,
                        -outDir * 0.04
                    );
                    wheelGroup.add(caliperGroup);
                    
                    // Track for wheel animation (first 2 positions are front wheels)
                    wheelGroup.userData.isFront = idx < 2;
                    car.add(wheelGroup);
                    car.userData.wheels.push(wheelGroup);
                });
                
                // --- WHEEL WELL ARCHES (black plastic trim like modern sedans) ---
                const archTrimMat = new THREE.MeshStandardMaterial({ 
                    color: 0x222222, 
                    roughness: 0.9,
                    metalness: 0.0
                });
                
                // Create arch trim for each wheel
                [[frontWheelX, 'front'], [rearWheelX, 'rear']].forEach(([xPos, position]) => {
                    [-wheelZ, wheelZ].forEach(zSide => {
                        // Generate arch curve points
                        const archPoints = [];
                        for (let a = 0; a <= Math.PI; a += Math.PI / 12) {
                            archPoints.push(new THREE.Vector3(
                                xPos + Math.cos(a) * 0.5,
                                0.38 + Math.sin(a) * 0.5,
                                zSide + (zSide > 0 ? 0.02 : -0.02)
                            ));
                        }
                        
                        const archCurve = new THREE.CatmullRomCurve3(archPoints);
                        const archTrimGeo = new THREE.TubeGeometry(archCurve, 16, 0.025, 6, false);
                        const archTrim = new THREE.Mesh(archTrimGeo, archTrimMat);
                        car.add(archTrim);
                    });
                });
                
                // --- FRONT BUMPER AIR INTAKES ---
                [-0.35, 0.35].forEach(z => {
                    const intakeShape = new THREE.Shape();
                    intakeShape.moveTo(-0.12, 0);
                    intakeShape.quadraticCurveTo(-0.15, 0.05, -0.1, 0.08);
                    intakeShape.lineTo(0.1, 0.08);
                    intakeShape.quadraticCurveTo(0.15, 0.05, 0.12, 0);
                    intakeShape.lineTo(-0.12, 0);
                    
                    const intakeGeo = new THREE.ShapeGeometry(intakeShape);
                    const intake = new THREE.Mesh(intakeGeo, trimMat);
                    intake.rotation.x = -Math.PI / 2 + 0.2;
                    intake.position.set(-2.38, 0.35, z);
                    car.add(intake);
                    
                    // Intake mesh/honeycomb
                    const meshGeo = new THREE.PlaneGeometry(0.18, 0.06);
                    const intakeMesh = new THREE.Mesh(meshGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x111111,
                        roughness: 0.9
                    }));
                    intakeMesh.rotation.x = -Math.PI / 2 + 0.2;
                    intakeMesh.position.set(-2.37, 0.36, z);
                    car.add(intakeMesh);
                });
                
                // --- FOG LIGHTS ---
                [-0.55, 0.55].forEach(z => {
                    const fogLight = new THREE.Mesh(
                        new THREE.CircleGeometry(0.04, 12),
                        new THREE.MeshBasicMaterial({ color: 0xffffcc })
                    );
                    fogLight.rotation.y = -Math.PI / 2;
                    fogLight.position.set(-2.42, 0.38, z);
                    car.add(fogLight);
                    
                    // Fog light housing
                    const fogHousing = new THREE.Mesh(
                        new THREE.TorusGeometry(0.045, 0.012, 6, 12),
                        chromeMat
                    );
                    fogHousing.rotation.y = Math.PI / 2;
                    fogHousing.position.set(-2.41, 0.38, z);
                    car.add(fogHousing);
                });
                
                // --- EXHAUST TIPS (rear bumper) ---
                [-0.4, 0.4].forEach(z => {
                    // Chrome exhaust tip
                    const exhaustGeo = new THREE.CylinderGeometry(0.035, 0.04, 0.08, 12);
                    const exhaust = new THREE.Mesh(exhaustGeo, chromeMat);
                    exhaust.rotation.z = Math.PI / 2;
                    exhaust.position.set(2.38, 0.28, z);
                    car.add(exhaust);
                    
                    // Inner dark exhaust
                    const exhaustInner = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.028, 0.028, 0.06, 12),
                        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 })
                    );
                    exhaustInner.rotation.z = Math.PI / 2;
                    exhaustInner.position.set(2.4, 0.28, z);
                    car.add(exhaustInner);
                });
                
                // --- REAR DIFFUSER ---
                const diffuserShape = new THREE.Shape();
                diffuserShape.moveTo(-0.6, 0);
                diffuserShape.lineTo(0.6, 0);
                diffuserShape.lineTo(0.55, 0.06);
                diffuserShape.lineTo(-0.55, 0.06);
                diffuserShape.lineTo(-0.6, 0);
                
                const diffuserGeo = new THREE.ExtrudeGeometry(diffuserShape, {
                    steps: 1,
                    depth: 0.15,
                    bevelEnabled: false
                });
                const diffuser = new THREE.Mesh(diffuserGeo, trimMat);
                diffuser.rotation.x = Math.PI / 2;
                diffuser.position.set(2.2, 0.2, 0.075);
                car.add(diffuser);
                
                // Diffuser fins
                [-0.3, 0, 0.3].forEach(z => {
                    const finGeo = new THREE.BoxGeometry(0.12, 0.04, 0.008);
                    const fin = new THREE.Mesh(finGeo, trimMat);
                    fin.position.set(2.25, 0.22, z);
                    car.add(fin);
                });
                
                // --- ANTENNA (shark fin style) ---
                const antennaShape = new THREE.Shape();
                antennaShape.moveTo(0, 0);
                antennaShape.quadraticCurveTo(0.04, 0.06, 0.02, 0.1);
                antennaShape.quadraticCurveTo(-0.01, 0.08, -0.03, 0.03);
                antennaShape.lineTo(0, 0);
                
                const antennaGeo = new THREE.ExtrudeGeometry(antennaShape, {
                    steps: 1,
                    depth: 0.04,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.01,
                    bevelSegments: 2
                });
                const antenna = new THREE.Mesh(antennaGeo, trimMat);
                antenna.rotation.y = Math.PI / 2;
                antenna.position.set(0.8, 1.55, -0.02);
                car.add(antenna);
                
                // Set custom wheels flag to skip common wheel section
                car.userData.hasCustomWheels = true;
                
            } else if (style === 'sports') {
                // ========================================================
                // HIGH-QUALITY LOW-POLY SPORTS CAR (Mustang/Camaro/Porsche style)
                // Aggressive stance, smooth curves, detailed wheels
                // ========================================================
                
                // Enhanced materials for sports car
                const sportBodyMat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    metalness: 0.85, 
                    roughness: 0.15 
                });
                const carbonMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, 
                    metalness: 0.3, 
                    roughness: 0.4 
                });
                const sportGlassMat = new THREE.MeshStandardMaterial({ 
                    color: 0x112233, 
                    metalness: 0.95, 
                    roughness: 0.05,
                    transparent: true,
                    opacity: 0.6
                });
                const redBrakeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xcc0000, 
                    metalness: 0.6, 
                    roughness: 0.3 
                });
                const rotorMat = new THREE.MeshStandardMaterial({ 
                    color: 0x555555, 
                    metalness: 0.8, 
                    roughness: 0.3 
                });
                
                // --- MAIN BODY using ExtrudeGeometry for smooth curves ---
                // Side profile shape (aggressive wedge)
                const bodyShape = new THREE.Shape();
                // Start at front bottom
                bodyShape.moveTo(-2.5, 0.25);
                // Front splitter/air dam
                bodyShape.lineTo(-2.6, 0.15);
                bodyShape.lineTo(-2.65, 0.2);
                // Front bumper curve up
                bodyShape.quadraticCurveTo(-2.6, 0.5, -2.4, 0.55);
                // Hood line (long, low, aggressive)
                bodyShape.quadraticCurveTo(-1.8, 0.65, -1.0, 0.72);
                // A-pillar / windshield base
                bodyShape.lineTo(-0.6, 0.75);
                // Windshield (steep rake)
                bodyShape.quadraticCurveTo(-0.3, 1.1, 0.0, 1.25);
                // Roof line
                bodyShape.quadraticCurveTo(0.4, 1.32, 0.8, 1.28);
                // Rear window (fastback)
                bodyShape.quadraticCurveTo(1.3, 1.15, 1.6, 0.95);
                // Trunk/decklid
                bodyShape.lineTo(2.0, 0.9);
                // Rear bumper
                bodyShape.quadraticCurveTo(2.3, 0.85, 2.4, 0.6);
                // Rear diffuser area
                bodyShape.lineTo(2.45, 0.35);
                bodyShape.lineTo(2.35, 0.2);
                // Underbody
                bodyShape.lineTo(-2.5, 0.2);
                bodyShape.lineTo(-2.5, 0.25);
                
                const bodyExtrudeSettings = {
                    steps: 1,
                    depth: 2.1,
                    bevelEnabled: true,
                    bevelThickness: 0.12,
                    bevelSize: 0.1,
                    bevelSegments: 4
                };
                
                const mainBodyGeo = new THREE.ExtrudeGeometry(bodyShape, bodyExtrudeSettings);
                const mainBody = new THREE.Mesh(mainBodyGeo, sportBodyMat);
                mainBody.position.set(0, 0, -1.05);
                mainBody.castShadow = true;
                mainBody.receiveShadow = true;
                car.add(mainBody);
                
                // --- MUSCULAR REAR FENDERS (wide haunches) ---
                const fenderShape = new THREE.Shape();
                fenderShape.moveTo(0, 0);
                fenderShape.quadraticCurveTo(0.35, 0.15, 0.35, 0.4);
                fenderShape.quadraticCurveTo(0.35, 0.65, 0, 0.75);
                fenderShape.lineTo(0, 0);
                
                const fenderExtrudeSettings = {
                    steps: 1,
                    depth: 1.1,
                    bevelEnabled: true,
                    bevelThickness: 0.05,
                    bevelSize: 0.05,
                    bevelSegments: 3
                };
                
                [-1, 1].forEach(side => {
                    const fenderGeo = new THREE.ExtrudeGeometry(fenderShape, fenderExtrudeSettings);
                    const fender = new THREE.Mesh(fenderGeo, sportBodyMat);
                    fender.position.set(1.1, 0.25, side * 0.95);
                    fender.rotation.y = side > 0 ? 0 : Math.PI;
                    fender.castShadow = true;
                    car.add(fender);
                });
                
                // --- FRONT FENDER FLARES ---
                [-1, 1].forEach(side => {
                    const frontFenderGeo = new THREE.ExtrudeGeometry(fenderShape, {
                        ...fenderExtrudeSettings,
                        depth: 0.9
                    });
                    const frontFender = new THREE.Mesh(frontFenderGeo, sportBodyMat);
                    frontFender.position.set(-1.5, 0.25, side * 0.9);
                    frontFender.rotation.y = side > 0 ? 0 : Math.PI;
                    frontFender.scale.set(0.85, 0.85, 0.85);
                    frontFender.castShadow = true;
                    car.add(frontFender);
                });
                
                // --- WINDSHIELD (tinted, angled) ---
                const windshieldGeo = new THREE.BoxGeometry(0.05, 0.6, 1.65);
                const windshield = new THREE.Mesh(windshieldGeo, sportGlassMat);
                windshield.position.set(-0.35, 1.05, 0);
                windshield.rotation.z = 0.65;
                car.add(windshield);
                
                // --- A-PILLAR TRIM (black trim around windshield) ---
                const pillarMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.7 });
                [-0.85, 0.85].forEach(side => {
                    const aPillarGeo = new THREE.BoxGeometry(0.06, 0.55, 0.06);
                    const aPillar = new THREE.Mesh(aPillarGeo, pillarMat);
                    aPillar.position.set(-0.35, 1.05, side);
                    aPillar.rotation.z = 0.65;
                    car.add(aPillar);
                });
                
                // --- WINDSHIELD WIPER REST AREA ---
                const cowlGeo = new THREE.BoxGeometry(0.3, 0.04, 1.5);
                const cowl = new THREE.Mesh(cowlGeo, trimMat);
                cowl.position.set(-0.6, 0.78, 0);
                car.add(cowl);
                
                // --- SIDE WINDOWS (tinted) with rubber trim ---
                [-0.98, 0.98].forEach(side => {
                    const sideWinGeo = new THREE.BoxGeometry(1.4, 0.4, 0.04);
                    const sideWin = new THREE.Mesh(sideWinGeo, sportGlassMat);
                    sideWin.position.set(0.3, 1.15, side);
                    car.add(sideWin);
                    
                    // Window rubber trim (weatherstripping)
                    const rubberTrimGeo = new THREE.BoxGeometry(1.45, 0.03, 0.02);
                    const rubberTrimTop = new THREE.Mesh(rubberTrimGeo, pillarMat);
                    rubberTrimTop.position.set(0.3, 1.36, side > 0 ? side - 0.01 : side + 0.01);
                    car.add(rubberTrimTop);
                    
                    const rubberTrimBot = new THREE.Mesh(rubberTrimGeo, pillarMat);
                    rubberTrimBot.position.set(0.3, 0.94, side > 0 ? side - 0.01 : side + 0.01);
                    car.add(rubberTrimBot);
                    
                    // Quarter window
                    const quarterWinGeo = new THREE.BoxGeometry(0.5, 0.3, 0.04);
                    const quarterWin = new THREE.Mesh(quarterWinGeo, sportGlassMat);
                    quarterWin.position.set(1.15, 1.05, side);
                    car.add(quarterWin);
                    
                    // B-pillar (between door and quarter window)
                    const bPillarGeo = new THREE.BoxGeometry(0.08, 0.45, 0.06);
                    const bPillar = new THREE.Mesh(bPillarGeo, pillarMat);
                    bPillar.position.set(0.85, 1.1, side);
                    car.add(bPillar);
                    
                    // C-pillar (rear quarter panel)
                    const cPillarGeo = new THREE.BoxGeometry(0.1, 0.35, 0.08);
                    const cPillar = new THREE.Mesh(cPillarGeo, sportBodyMat);
                    cPillar.position.set(1.4, 1.0, side);
                    car.add(cPillar);
                });
                
                // --- REAR WINDOW (fastback style, tinted) ---
                const rearWinGeo = new THREE.BoxGeometry(0.05, 0.45, 1.5);
                const rearWindow = new THREE.Mesh(rearWinGeo, sportGlassMat);
                rearWindow.position.set(1.35, 1.0, 0);
                rearWindow.rotation.z = -0.45;
                car.add(rearWindow);
                
                // --- INTERIOR SILHOUETTE (visible through glass) ---
                const interiorMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
                
                // Dashboard
                const dashGeo = new THREE.BoxGeometry(0.6, 0.2, 1.4);
                const dash = new THREE.Mesh(dashGeo, interiorMat);
                dash.position.set(-0.4, 0.88, 0);
                car.add(dash);
                
                // Seats (driver and passenger silhouettes)
                [-0.45, 0.45].forEach(zPos => {
                    // Seat back
                    const seatBackGeo = new THREE.BoxGeometry(0.15, 0.4, 0.4);
                    const seatBack = new THREE.Mesh(seatBackGeo, interiorMat);
                    seatBack.position.set(0.2, 1.0, zPos);
                    seatBack.rotation.z = -0.15;
                    car.add(seatBack);
                    
                    // Headrest
                    const headrestGeo = new THREE.BoxGeometry(0.08, 0.15, 0.25);
                    const headrest = new THREE.Mesh(headrestGeo, interiorMat);
                    headrest.position.set(0.28, 1.22, zPos);
                    car.add(headrest);
                });
                
                // Steering wheel silhouette
                const steeringGeo = new THREE.TorusGeometry(0.12, 0.02, 8, 16);
                const steering = new THREE.Mesh(steeringGeo, interiorMat);
                steering.position.set(-0.25, 0.95, 0.35);
                steering.rotation.x = Math.PI / 2;
                steering.rotation.z = 0.4;
                car.add(steering);
                
                // --- DOOR SEAMS / PANEL GAPS ---
                [-1.03, 1.03].forEach(side => {
                    // Front door seam (vertical)
                    const doorSeamFrontGeo = new THREE.BoxGeometry(0.015, 0.5, 0.01);
                    const doorSeamFront = new THREE.Mesh(doorSeamFrontGeo, trimMat);
                    doorSeamFront.position.set(-0.55, 0.75, side);
                    car.add(doorSeamFront);
                    
                    // Door bottom seam
                    const doorSeamBotGeo = new THREE.BoxGeometry(1.2, 0.01, 0.01);
                    const doorSeamBot = new THREE.Mesh(doorSeamBotGeo, trimMat);
                    doorSeamBot.position.set(0.1, 0.35, side);
                    car.add(doorSeamBot);
                });
                
                // --- HOOD POWER BULGE (aggressive muscle car look) ---
                const bulgeShape = new THREE.Shape();
                bulgeShape.moveTo(-0.8, 0);
                bulgeShape.quadraticCurveTo(-0.5, 0.12, 0, 0.15);
                bulgeShape.quadraticCurveTo(0.5, 0.12, 0.8, 0);
                bulgeShape.lineTo(-0.8, 0);
                
                const bulgeExtrudeSettings = {
                    steps: 1,
                    depth: 0.7,
                    bevelEnabled: true,
                    bevelThickness: 0.04,
                    bevelSize: 0.04,
                    bevelSegments: 3
                };
                
                const bulgeGeo = new THREE.ExtrudeGeometry(bulgeShape, bulgeExtrudeSettings);
                const hoodBulge = new THREE.Mesh(bulgeGeo, sportBodyMat);
                hoodBulge.position.set(-1.6, 0.72, -0.35);
                hoodBulge.rotation.x = -Math.PI / 2;
                hoodBulge.castShadow = true;
                car.add(hoodBulge);
                
                // --- HOOD VENTS (functional look on power bulge) ---
                [-0.35, 0.35].forEach(zPos => {
                    // Vent housing
                    const ventHousingGeo = new THREE.BoxGeometry(0.9, 0.08, 0.28);
                    const ventHousing = new THREE.Mesh(ventHousingGeo, carbonMat);
                    ventHousing.position.set(-1.4, 0.82, zPos);
                    car.add(ventHousing);
                    
                    // Vent slats
                    for (let i = 0; i < 4; i++) {
                        const slatGeo = new THREE.BoxGeometry(0.15, 0.04, 0.22);
                        const slat = new THREE.Mesh(slatGeo, carbonMat);
                        slat.position.set(-1.55 + i * 0.2, 0.86, zPos);
                        slat.rotation.z = 0.3;
                        car.add(slat);
                    }
                });
                
                // --- BODY CHARACTER LINES (side crease for visual interest) ---
                [-1.05, 1.05].forEach(side => {
                    // Main body crease (runs full length)
                    const creaseMat = new THREE.MeshStandardMaterial({ 
                        color: color, 
                        metalness: 0.9, 
                        roughness: 0.1 
                    });
                    const creaseGeo = new THREE.BoxGeometry(3.8, 0.02, 0.015);
                    const crease = new THREE.Mesh(creaseGeo, creaseMat);
                    crease.position.set(-0.1, 0.6, side);
                    car.add(crease);
                    
                    // Upper accent line (above wheel arches)
                    const accentGeo = new THREE.BoxGeometry(2.5, 0.015, 0.012);
                    const accent = new THREE.Mesh(accentGeo, creaseMat);
                    accent.position.set(0.2, 0.85, side);
                    car.add(accent);
                });
                
                // --- FENDER BADGES / VENTS (side gill vents) ---
                [-1.06, 1.06].forEach(side => {
                    // Three horizontal vent slats
                    for (let v = 0; v < 3; v++) {
                        const gillGeo = new THREE.BoxGeometry(0.25, 0.03, 0.03);
                        const gill = new THREE.Mesh(gillGeo, chromeMat);
                        gill.position.set(-0.9, 0.5 + v * 0.08, side);
                        car.add(gill);
                    }
                    
                    // Vent surround
                    const surroundGeo = new THREE.BoxGeometry(0.32, 0.28, 0.02);
                    const surround = new THREE.Mesh(surroundGeo, carbonMat);
                    surround.position.set(-0.9, 0.58, side > 0 ? side + 0.01 : side - 0.01);
                    car.add(surround);
                });
                
                // --- FUEL DOOR (driver's side) ---
                const fuelDoorGeo = new THREE.BoxGeometry(0.18, 0.15, 0.02);
                const fuelDoor = new THREE.Mesh(fuelDoorGeo, sportBodyMat);
                fuelDoor.position.set(0.8, 0.7, 1.06);
                car.add(fuelDoor);
                // Fuel door outline
                const fuelOutlineGeo = new THREE.BoxGeometry(0.2, 0.17, 0.015);
                const fuelOutline = new THREE.Mesh(fuelOutlineGeo, trimMat);
                fuelOutline.position.set(0.8, 0.7, 1.055);
                car.add(fuelOutline);
                
                // --- SIDE SCOOPS / AIR INTAKES ---
                [-1.08, 1.08].forEach(side => {
                    const scoopGeo = new THREE.BoxGeometry(0.5, 0.18, 0.08);
                    const scoop = new THREE.Mesh(scoopGeo, carbonMat);
                    scoop.position.set(0.2, 0.55, side);
                    car.add(scoop);
                    
                    // Scoop opening
                    const openingGeo = new THREE.BoxGeometry(0.35, 0.12, 0.03);
                    const opening = new THREE.Mesh(openingGeo, trimMat);
                    opening.position.set(0.15, 0.55, side > 0 ? side + 0.03 : side - 0.03);
                    car.add(opening);
                });
                
                // --- REAR SPOILER / WING (aggressive) ---
                // Spoiler uprights
                [-0.65, 0.65].forEach(zPos => {
                    const uprightGeo = new THREE.BoxGeometry(0.08, 0.25, 0.08);
                    const upright = new THREE.Mesh(uprightGeo, carbonMat);
                    upright.position.set(2.05, 1.02, zPos);
                    car.add(upright);
                });
                
                // Spoiler wing (airfoil shape using extrude)
                const wingShape = new THREE.Shape();
                wingShape.moveTo(0, 0);
                wingShape.quadraticCurveTo(0.15, 0.08, 0.3, 0.05);
                wingShape.quadraticCurveTo(0.35, 0.02, 0.35, 0);
                wingShape.quadraticCurveTo(0.2, -0.02, 0, 0);
                
                const wingExtrudeSettings = {
                    steps: 1,
                    depth: 1.6,
                    bevelEnabled: true,
                    bevelThickness: 0.02,
                    bevelSize: 0.02,
                    bevelSegments: 2
                };
                
                const wingGeo = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
                const wing = new THREE.Mesh(wingGeo, sportBodyMat);
                wing.position.set(1.9, 1.15, -0.8);
                wing.castShadow = true;
                car.add(wing);
                
                // Wing end plates
                [-0.82, 0.82].forEach(zPos => {
                    const endPlateGeo = new THREE.BoxGeometry(0.35, 0.18, 0.04);
                    const endPlate = new THREE.Mesh(endPlateGeo, carbonMat);
                    endPlate.position.set(2.05, 1.18, zPos);
                    car.add(endPlate);
                });
                
                // --- REAR DIFFUSER ---
                const diffuserGeo = new THREE.BoxGeometry(0.4, 0.12, 1.6);
                const diffuser = new THREE.Mesh(diffuserGeo, carbonMat);
                diffuser.position.set(2.25, 0.25, 0);
                car.add(diffuser);
                
                // Diffuser fins
                for (let i = -2; i <= 2; i++) {
                    const finGeo = new THREE.BoxGeometry(0.35, 0.1, 0.03);
                    const fin = new THREE.Mesh(finGeo, carbonMat);
                    fin.position.set(2.25, 0.28, i * 0.3);
                    car.add(fin);
                }
                
                // --- EXHAUST TIPS (quad) ---
                [-0.55, -0.25, 0.25, 0.55].forEach(zPos => {
                    const exhaustGeo = new THREE.CylinderGeometry(0.06, 0.07, 0.15, 12);
                    const exhaust = new THREE.Mesh(exhaustGeo, chromeMat);
                    exhaust.position.set(2.42, 0.32, zPos);
                    exhaust.rotation.z = Math.PI / 2;
                    car.add(exhaust);
                    
                    // Inner dark
                    const innerGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.08, 8);
                    const inner = new THREE.Mesh(innerGeo, trimMat);
                    inner.position.set(2.46, 0.32, zPos);
                    inner.rotation.z = Math.PI / 2;
                    car.add(inner);
                });
                
                // --- AGGRESSIVE HEADLIGHTS (enhanced with better glow) ---
                [-0.7, 0.7].forEach(zPos => {
                    // LED DRL strip (now with emissive glow)
                    const drlMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        emissive: 0xffffff, 
                        emissiveIntensity: 3.0,
                        roughness: 0.1
                    });
                    const drlGeo = new THREE.BoxGeometry(0.4, 0.05, 0.35);
                    const drl = new THREE.Mesh(drlGeo, drlMat);
                    drl.position.set(-2.35, 0.6, zPos);
                    car.add(drl);
                    
                    // Main projector housing (chrome bezel)
                    const projectorGeo = new THREE.CylinderGeometry(0.11, 0.13, 0.1, 20);
                    const projector = new THREE.Mesh(projectorGeo, chromeMat);
                    projector.position.set(-2.38, 0.5, zPos);
                    projector.rotation.z = Math.PI / 2;
                    car.add(projector);
                    
                    // Projector lens (glowing center)
                    const lensMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffee, 
                        emissive: 0xffffcc, 
                        emissiveIntensity: 4.0,
                        roughness: 0.05
                    });
                    const lensGeo = new THREE.SphereGeometry(0.09, 16, 12);
                    const lens = new THREE.Mesh(lensGeo, lensMat);
                    lens.position.set(-2.42, 0.5, zPos);
                    lens.scale.x = 0.35;
                    car.add(lens);
                    
                    // Secondary low beam
                    const lowBeamGeo = new THREE.SphereGeometry(0.05, 12, 8);
                    const lowBeam = new THREE.Mesh(lowBeamGeo, headlightMat);
                    lowBeam.position.set(-2.4, 0.42, zPos);
                    car.add(lowBeam);
                    
                    // Housing surround (dark for contrast)
                    const housingGeo = new THREE.BoxGeometry(0.1, 0.28, 0.48);
                    const housing = new THREE.Mesh(housingGeo, trimMat);
                    housing.position.set(-2.4, 0.52, zPos);
                    car.add(housing);
                });
                
                // --- AGGRESSIVE TAILLIGHTS (LED bar style) ---
                [-0.65, 0.65].forEach(zPos => {
                    // Main taillight bar - use emissive material for brake light effect
                    const tlBarGeo = new THREE.BoxGeometry(0.08, 0.12, 0.5);
                    const tlBarMat = new THREE.MeshStandardMaterial({ 
                        color: 0xff1111, 
                        emissive: 0xff1100, 
                        emissiveIntensity: 2.0,
                        roughness: 0.3
                    });
                    const tlBar = new THREE.Mesh(tlBarGeo, tlBarMat);
                    tlBar.position.set(2.38, 0.75, zPos);
                    car.add(tlBar);
                    car.userData.taillights.push(tlBar); // Track for brake light effect
                    
                    // Taillight housing
                    const tlHousingGeo = new THREE.BoxGeometry(0.1, 0.18, 0.55);
                    const tlHousing = new THREE.Mesh(tlHousingGeo, trimMat);
                    tlHousing.position.set(2.36, 0.75, zPos);
                    car.add(tlHousing);
                    
                    // Amber turn signal strip - use emissive for flash effect
                    const turnGeo = new THREE.BoxGeometry(0.06, 0.04, 0.4);
                    const turnMat = new THREE.MeshStandardMaterial({ 
                        color: 0xff6600, 
                        emissive: 0xff5500, 
                        emissiveIntensity: 0.3,
                        roughness: 0.3
                    });
                    const turn = new THREE.Mesh(turnGeo, turnMat);
                    turn.position.set(2.4, 0.63, zPos);
                    car.add(turn);
                    // Track by side: zPos > 0 = right, zPos < 0 = left
                    if (zPos > 0) {
                        car.userData.rightBlinkers.push(turn);
                    } else {
                        car.userData.leftBlinkers.push(turn);
                    }
                });
                
                // Center taillight bar (connects both sides - modern look)
                const centerTlGeo = new THREE.BoxGeometry(0.06, 0.06, 1.0);
                const centerTlMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff1111, 
                    emissive: 0xff1100, 
                    emissiveIntensity: 2.0,
                    roughness: 0.3
                });
                const centerTl = new THREE.Mesh(centerTlGeo, centerTlMat);
                centerTl.position.set(2.39, 0.75, 0);
                car.add(centerTl);
                car.userData.taillights.push(centerTl);
                
                // --- BACKUP / REVERSE LIGHTS ---
                [-0.35, 0.35].forEach(zPos => {
                    const backupGeo = new THREE.BoxGeometry(0.06, 0.08, 0.15);
                    const backup = new THREE.Mesh(backupGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    backup.position.set(2.4, 0.58, zPos);
                    car.add(backup);
                });
                
                // --- LICENSE PLATE (rear, with illumination) ---
                // Plate recess
                const plateRecessGeo = new THREE.BoxGeometry(0.06, 0.16, 0.4);
                const plateRecess = new THREE.Mesh(plateRecessGeo, trimMat);
                plateRecess.position.set(2.38, 0.48, 0);
                car.add(plateRecess);
                
                // Actual plate (white/cream)
                const plateMat = new THREE.MeshStandardMaterial({ color: 0xffffee, roughness: 0.8 });
                const plateGeo = new THREE.BoxGeometry(0.04, 0.12, 0.35);
                const plate = new THREE.Mesh(plateGeo, plateMat);
                plate.position.set(2.4, 0.48, 0);
                car.add(plate);
                
                // Plate lights (above plate)
                [-0.12, 0.12].forEach(zPos => {
                    const plateLightGeo = new THREE.BoxGeometry(0.04, 0.03, 0.08);
                    const plateLight = new THREE.Mesh(plateLightGeo, new THREE.MeshBasicMaterial({ color: 0xffffdd }));
                    plateLight.position.set(2.4, 0.56, zPos);
                    car.add(plateLight);
                });
                
                // --- REAR BADGE/EMBLEM (center of trunk) ---
                const badgeGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.03, 24);
                const badge = new THREE.Mesh(badgeGeo, chromeMat);
                badge.position.set(2.0, 0.92, 0);
                badge.rotation.z = Math.PI / 2;
                car.add(badge);
                
                // Badge inner (colored accent)
                const badgeInnerGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.035, 16);
                const badgeInner = new THREE.Mesh(badgeInnerGeo, sportBodyMat);
                badgeInner.position.set(2.02, 0.92, 0);
                badgeInner.rotation.z = Math.PI / 2;
                car.add(badgeInner);
                
                // --- TRUNK SEAM LINE ---
                const trunkSeamGeo = new THREE.BoxGeometry(0.015, 0.25, 1.6);
                const trunkSeam = new THREE.Mesh(trunkSeamGeo, trimMat);
                trunkSeam.position.set(1.6, 0.95, 0);
                car.add(trunkSeam);
                
                // --- HIGH-PERFORMANCE WHEELS with brake rotors & calipers ---
                const wheelRadius = 0.42;
                const wheelWidth = 0.35;
                const wheelY = 0.42;
                const frontWheelX = -1.55;
                const rearWheelX = 1.4;
                const wheelZFront = 0.92;
                const wheelZRear = 0.98;
                
                const sportsWheelPositions = [
                    [frontWheelX, wheelY, wheelZFront], [frontWheelX, wheelY, -wheelZFront],
                    [rearWheelX, wheelY, wheelZRear], [rearWheelX, wheelY, -wheelZRear]
                ];
                
                sportsWheelPositions.forEach((pos, idx) => {
                    const side = pos[2] > 0 ? 1 : -1;
                    
                    // --- TIRE (using LatheGeometry for rounded profile) ---
                    const tireProfile = [];
                    const tireInner = wheelRadius - 0.08;
                    const tireOuter = wheelRadius;
                    // Create rounded tire cross-section with slight sidewall bulge
                    for (let i = 0; i <= 12; i++) {
                        const t = i / 12;
                        const angle = t * Math.PI;
                        // Add slight sidewall bulge at quarters
                        const bulgeFactor = Math.sin(angle) * (1 + 0.08 * Math.sin(angle * 2));
                        const r = tireInner + (tireOuter - tireInner) * bulgeFactor;
                        const y = (t - 0.5) * wheelWidth;
                        tireProfile.push(new THREE.Vector2(r, y));
                    }
                    const tireGeo = new THREE.LatheGeometry(tireProfile, 32);
                    const tireMat = new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a, 
                        roughness: 0.85 
                    });
                    const tire = new THREE.Mesh(tireGeo, tireMat);
                    tire.rotation.x = Math.PI / 2;
                    tire.position.set(pos[0], pos[1], pos[2]);
                    tire.castShadow = true;
                    car.add(tire);
                    
                    // Tire sidewall raised lettering (performance tire look)
                    const letteringMat = new THREE.MeshStandardMaterial({ 
                        color: 0x252525, 
                        roughness: 0.7 
                    });
                    
                    // Sidewall rim protector ridge
                    const protectorGeo = new THREE.TorusGeometry(wheelRadius - 0.06, 0.012, 6, 32);
                    const protector = new THREE.Mesh(protectorGeo, letteringMat);
                    protector.position.set(pos[0], pos[1], pos[2] + side * 0.14);
                    car.add(protector);
                    
                    // Tire brand marking (raised ridge simulating text)
                    for (let m = 0; m < 3; m++) {
                        const markAngle = (m / 8 + 0.1) * Math.PI * 2;
                        const markGeo = new THREE.BoxGeometry(0.08, 0.015, 0.012);
                        const mark = new THREE.Mesh(markGeo, letteringMat);
                        mark.position.set(
                            pos[0] + Math.cos(markAngle) * (wheelRadius - 0.04),
                            pos[1] + Math.sin(markAngle) * (wheelRadius - 0.04),
                            pos[2] + side * 0.15
                        );
                        mark.rotation.z = markAngle + Math.PI / 2;
                        car.add(mark);
                    }
                    
                    // Tire size marking on opposite side
                    for (let m = 0; m < 2; m++) {
                        const markAngle = (m / 12 + 0.55) * Math.PI * 2;
                        const markGeo = new THREE.BoxGeometry(0.06, 0.012, 0.01);
                        const mark = new THREE.Mesh(markGeo, letteringMat);
                        mark.position.set(
                            pos[0] + Math.cos(markAngle) * (wheelRadius - 0.035),
                            pos[1] + Math.sin(markAngle) * (wheelRadius - 0.035),
                            pos[2] + side * 0.15
                        );
                        mark.rotation.z = markAngle + Math.PI / 2;
                        car.add(mark);
                    }
                    
                    // --- MULTI-SPOKE RIM (forged aluminum look) ---
                    const rimMat = new THREE.MeshStandardMaterial({ 
                        color: 0x3a3a3a, 
                        metalness: 0.95, 
                        roughness: 0.15 
                    });
                    
                    // Rim barrel (inner part visible through spokes)
                    const rimBarrelGeo = new THREE.CylinderGeometry(wheelRadius - 0.1, wheelRadius - 0.11, wheelWidth - 0.04, 24);
                    const rimBarrel = new THREE.Mesh(rimBarrelGeo, rimMat);
                    rimBarrel.rotation.x = Math.PI / 2;
                    rimBarrel.position.set(pos[0], pos[1], pos[2]);
                    car.add(rimBarrel);
                    
                    // Rim lip (outer edge - polished)
                    const rimLipGeo = new THREE.TorusGeometry(wheelRadius - 0.09, 0.025, 8, 32);
                    const rimLip = new THREE.Mesh(rimLipGeo, chromeMat);
                    rimLip.position.set(pos[0], pos[1], pos[2] + side * 0.15);
                    car.add(rimLip);
                    
                    // 5-spoke design (twin-spoke for 10-spoke look)
                    for (let s = 0; s < 5; s++) {
                        const spokeAngle = (s / 5) * Math.PI * 2;
                        
                        // Main spoke (wider at base)
                        const spokeShape = new THREE.Shape();
                        spokeShape.moveTo(0.04, 0);
                        spokeShape.lineTo(wheelRadius - 0.14, 0.025);
                        spokeShape.lineTo(wheelRadius - 0.14, -0.025);
                        spokeShape.lineTo(0.04, 0);
                        
                        const spokeExtrudeSettings = {
                            steps: 1,
                            depth: 0.035,
                            bevelEnabled: false
                        };
                        
                        const spokeGeo = new THREE.ExtrudeGeometry(spokeShape, spokeExtrudeSettings);
                        const spoke = new THREE.Mesh(spokeGeo, chromeMat);
                        spoke.position.set(pos[0], pos[1], pos[2] + side * 0.1);
                        spoke.rotation.z = spokeAngle;
                        car.add(spoke);
                        
                        // Secondary spoke (twin spoke design)
                        const spoke2 = new THREE.Mesh(spokeGeo, chromeMat);
                        spoke2.position.set(pos[0], pos[1], pos[2] + side * 0.1);
                        spoke2.rotation.z = spokeAngle + 0.2;
                        car.add(spoke2);
                    }
                    
                    // Center hub cap (domed with logo area)
                    const hubCapGeo = new THREE.SphereGeometry(0.07, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const hubCap = new THREE.Mesh(hubCapGeo, chromeMat);
                    hubCap.rotation.x = side > 0 ? -Math.PI / 2 : Math.PI / 2;
                    hubCap.position.set(pos[0], pos[1], pos[2] + side * 0.17);
                    car.add(hubCap);
                    
                    // Hub center ring (accent)
                    const hubRingGeo = new THREE.TorusGeometry(0.04, 0.008, 8, 16);
                    const hubRing = new THREE.Mesh(hubRingGeo, rimMat);
                    hubRing.position.set(pos[0], pos[1], pos[2] + side * 0.175);
                    car.add(hubRing);
                    
                    // Lug nuts (5 visible)
                    for (let lug = 0; lug < 5; lug++) {
                        const lugAngle = (lug / 5) * Math.PI * 2;
                        const lugGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.02, 6);
                        const lugNut = new THREE.Mesh(lugGeo, chromeMat);
                        lugNut.rotation.x = Math.PI / 2;
                        lugNut.position.set(
                            pos[0] + Math.cos(lugAngle) * 0.05,
                            pos[1] + Math.sin(lugAngle) * 0.05,
                            pos[2] + side * 0.16
                        );
                        car.add(lugNut);
                    }
                    
                    // --- VISIBLE BRAKE ROTOR (cross-drilled performance rotors) ---
                    const rotorGeo = new THREE.CylinderGeometry(wheelRadius - 0.12, wheelRadius - 0.12, 0.035, 32);
                    const rotor = new THREE.Mesh(rotorGeo, rotorMat);
                    rotor.rotation.x = Math.PI / 2;
                    rotor.position.set(pos[0], pos[1], pos[2] - side * 0.05);
                    car.add(rotor);
                    
                    // Cross-drilled holes (in concentric rings)
                    const holeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
                    for (let ring = 0; ring < 2; ring++) {
                        const holeRadius = wheelRadius - 0.18 - ring * 0.06;
                        const holeCount = 18 - ring * 6;
                        for (let h = 0; h < holeCount; h++) {
                            const angle = (h / holeCount) * Math.PI * 2;
                            const holeGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.04, 6);
                            const hole = new THREE.Mesh(holeGeo, holeMat);
                            hole.rotation.x = Math.PI / 2;
                            hole.position.set(
                                pos[0] + Math.cos(angle) * holeRadius,
                                pos[1] + Math.sin(angle) * holeRadius,
                                pos[2] - side * 0.05
                            );
                            car.add(hole);
                        }
                    }
                    
                    // Rotor ventilation slots (curved for realism)
                    for (let v = 0; v < 24; v++) {
                        const angle = (v / 24) * Math.PI * 2;
                        const slotLen = 0.08;
                        const slotGeo = new THREE.BoxGeometry(slotLen, 0.04, 0.006);
                        const slot = new THREE.Mesh(slotGeo, trimMat);
                        const slotR = wheelRadius - 0.26;
                        slot.position.set(
                            pos[0] + Math.cos(angle) * slotR,
                            pos[1] + Math.sin(angle) * slotR,
                            pos[2] - side * 0.05
                        );
                        slot.rotation.z = angle + 0.2; // Slight curve to slots
                        car.add(slot);
                    }
                    
                    // Rotor hub (center mounting flange)
                    const hubFlangeGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.04, 16);
                    const hubFlange = new THREE.Mesh(hubFlangeGeo, rotorMat);
                    hubFlange.rotation.x = Math.PI / 2;
                    hubFlange.position.set(pos[0], pos[1], pos[2] - side * 0.03);
                    car.add(hubFlange);
                    
                    // --- RED BRAKE CALIPER (Brembo-style 6-piston) ---
                    // Position caliper at front-top of rotor (where you'd see it through spokes)
                    const caliperAngle = idx < 2 ? -0.4 : -0.25;
                    const caliperX = pos[0] + Math.cos(caliperAngle) * (wheelRadius - 0.17);
                    const caliperY = pos[1] + Math.sin(caliperAngle) * (wheelRadius - 0.17) + 0.02;
                    const caliperZ = pos[2] - side * 0.02;
                    
                    // Main caliper body
                    const caliperGeo = new THREE.BoxGeometry(0.14, 0.09, 0.07);
                    const caliper = new THREE.Mesh(caliperGeo, redBrakeMat);
                    caliper.position.set(caliperX, caliperY, caliperZ);
                    caliper.rotation.z = caliperAngle + 0.1;
                    car.add(caliper);
                    
                    // Caliper lettering area (raised section for "BREMBO" style)
                    const letterAreaGeo = new THREE.BoxGeometry(0.1, 0.05, 0.01);
                    const letterArea = new THREE.Mesh(letterAreaGeo, new THREE.MeshStandardMaterial({ 
                        color: 0xdd0000, 
                        metalness: 0.5, 
                        roughness: 0.4 
                    }));
                    letterArea.position.set(caliperX, caliperY, caliperZ + side * 0.035);
                    letterArea.rotation.z = caliperAngle + 0.1;
                    car.add(letterArea);
                    
                    // Caliper pistons (visible as bumps)
                    for (let p = 0; p < 3; p++) {
                        const pistonGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.08, 8);
                        const piston = new THREE.Mesh(pistonGeo, trimMat);
                        piston.rotation.x = Math.PI / 2;
                        piston.position.set(
                            caliperX + (p - 1) * 0.035 * Math.cos(caliperAngle + Math.PI / 2),
                            caliperY + (p - 1) * 0.035 * Math.sin(caliperAngle + Math.PI / 2),
                            caliperZ
                        );
                        car.add(piston);
                    }
                    
                    // Brake line fitting
                    const fittingGeo = new THREE.CylinderGeometry(0.008, 0.01, 0.04, 8);
                    const fitting = new THREE.Mesh(fittingGeo, chromeMat);
                    fitting.position.set(caliperX + 0.06, caliperY + 0.03, caliperZ);
                    car.add(fitting);
                    
                    // Caliper mounting bracket (spindle mount)
                    const bracketGeo = new THREE.BoxGeometry(0.05, 0.18, 0.05);
                    const bracket = new THREE.Mesh(bracketGeo, trimMat);
                    bracket.position.set(
                        pos[0] + Math.cos(caliperAngle) * (wheelRadius - 0.24),
                        pos[1] + Math.sin(caliperAngle) * (wheelRadius - 0.24),
                        pos[2] - side * 0.06
                    );
                    bracket.rotation.z = caliperAngle;
                    car.add(bracket);
                    
                    // Bracket bolts
                    [-0.06, 0.06].forEach(offset => {
                        const boltGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.02, 6);
                        const bolt = new THREE.Mesh(boltGeo, chromeMat);
                        bolt.rotation.x = Math.PI / 2;
                        bolt.position.set(
                            pos[0] + Math.cos(caliperAngle) * (wheelRadius - 0.24),
                            pos[1] + Math.sin(caliperAngle) * (wheelRadius - 0.24) + offset,
                            pos[2] - side * 0.04
                        );
                        car.add(bolt);
                    });
                });
                
                // --- FRONT GRILLE (aggressive mesh pattern with chrome surround) ---
                const grilleGeo = new THREE.BoxGeometry(0.08, 0.22, 1.1);
                const grille = new THREE.Mesh(grilleGeo, trimMat);
                grille.position.set(-2.48, 0.42, 0);
                car.add(grille);
                
                // Grille mesh pattern (honeycomb style)
                for (let gz = -4; gz <= 4; gz++) {
                    const meshBarGeo = new THREE.BoxGeometry(0.06, 0.18, 0.02);
                    const meshBar = new THREE.Mesh(meshBarGeo, carbonMat);
                    meshBar.position.set(-2.52, 0.42, gz * 0.12);
                    car.add(meshBar);
                }
                
                // Chrome grille surround
                const grilleSurroundGeo = new THREE.BoxGeometry(0.05, 0.26, 1.2);
                const grilleSurround = new THREE.Mesh(grilleSurroundGeo, chromeMat);
                grilleSurround.position.set(-2.5, 0.42, 0);
                car.add(grilleSurround);
                
                // --- FOG LIGHTS (in lower bumper) ---
                [-0.75, 0.75].forEach(zPos => {
                    // Fog light housing (hexagonal look)
                    const fogHousingGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.06, 6);
                    const fogHousing = new THREE.Mesh(fogHousingGeo, trimMat);
                    fogHousing.position.set(-2.52, 0.28, zPos);
                    fogHousing.rotation.z = Math.PI / 2;
                    car.add(fogHousing);
                    
                    // Fog light lens (amber/yellow)
                    const fogLensGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.03, 12);
                    const fogLens = new THREE.Mesh(fogLensGeo, new THREE.MeshBasicMaterial({ color: 0xffffaa }));
                    fogLens.position.set(-2.55, 0.28, zPos);
                    fogLens.rotation.z = Math.PI / 2;
                    car.add(fogLens);
                    
                    // Chrome bezel
                    const bezelGeo = new THREE.TorusGeometry(0.08, 0.015, 8, 16);
                    const bezel = new THREE.Mesh(bezelGeo, chromeMat);
                    bezel.position.set(-2.54, 0.28, zPos);
                    bezel.rotation.y = Math.PI / 2;
                    car.add(bezel);
                });
                
                // --- FRONT AIR INTAKES (brake cooling ducts) ---
                [-0.4, 0.4].forEach(zPos => {
                    const intakeGeo = new THREE.BoxGeometry(0.15, 0.12, 0.25);
                    const intake = new THREE.Mesh(intakeGeo, trimMat);
                    intake.position.set(-2.5, 0.25, zPos);
                    car.add(intake);
                    
                    // Mesh inside intake
                    const meshGeo = new THREE.BoxGeometry(0.08, 0.1, 0.22);
                    const mesh = new THREE.Mesh(meshGeo, carbonMat);
                    mesh.position.set(-2.54, 0.25, zPos);
                    car.add(mesh);
                });
                
                // --- FRONT SPLITTER ---
                const splitterGeo = new THREE.BoxGeometry(0.6, 0.04, 2.0);
                const splitter = new THREE.Mesh(splitterGeo, carbonMat);
                splitter.position.set(-2.55, 0.16, 0);
                car.add(splitter);
                
                // Splitter end plates
                [-1.0, 1.0].forEach(zPos => {
                    const endGeo = new THREE.BoxGeometry(0.25, 0.12, 0.04);
                    const end = new THREE.Mesh(endGeo, carbonMat);
                    end.position.set(-2.5, 0.18, zPos);
                    car.add(end);
                });
                
                // Splitter struts (canards)
                [-0.85, 0.85].forEach(zPos => {
                    const strutGeo = new THREE.BoxGeometry(0.15, 0.06, 0.04);
                    const strut = new THREE.Mesh(strutGeo, carbonMat);
                    strut.position.set(-2.6, 0.22, zPos);
                    strut.rotation.z = 0.3;
                    car.add(strut);
                });
                
                // --- SIDE SKIRTS ---
                [-1.08, 1.08].forEach(side => {
                    const skirtGeo = new THREE.BoxGeometry(3.2, 0.12, 0.06);
                    const skirt = new THREE.Mesh(skirtGeo, carbonMat);
                    skirt.position.set(-0.2, 0.22, side);
                    car.add(skirt);
                });
                
                // --- WHEEL WELL FENDER LINERS ---
                const linerMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.95 });
                
                // Front wheel well liners
                [-0.95, 0.95].forEach(side => {
                    const fwlShape = new THREE.Shape();
                    fwlShape.absarc(0, 0, 0.48, 0, Math.PI, false);
                    
                    const fwlExtrudeSettings = {
                        steps: 1,
                        depth: 0.25,
                        bevelEnabled: false
                    };
                    
                    const fwlGeo = new THREE.ExtrudeGeometry(fwlShape, fwlExtrudeSettings);
                    const fwl = new THREE.Mesh(fwlGeo, linerMat);
                    fwl.position.set(-1.55, 0.42, side > 0 ? side - 0.12 : side + 0.12);
                    fwl.rotation.y = side > 0 ? 0 : Math.PI;
                    car.add(fwl);
                });
                
                // Rear wheel well liners (slightly larger for wider tires)
                [-0.98, 0.98].forEach(side => {
                    const rwlShape = new THREE.Shape();
                    rwlShape.absarc(0, 0, 0.52, 0, Math.PI, false);
                    
                    const rwlExtrudeSettings = {
                        steps: 1,
                        depth: 0.28,
                        bevelEnabled: false
                    };
                    
                    const rwlGeo = new THREE.ExtrudeGeometry(rwlShape, rwlExtrudeSettings);
                    const rwl = new THREE.Mesh(rwlGeo, linerMat);
                    rwl.position.set(1.4, 0.42, side > 0 ? side - 0.14 : side + 0.14);
                    rwl.rotation.y = side > 0 ? 0 : Math.PI;
                    car.add(rwl);
                });
                
                // --- SIDE MIRRORS (aerodynamic) ---
                [-1.1, 1.1].forEach(side => {
                    // Mirror arm
                    const armGeo = new THREE.BoxGeometry(0.15, 0.04, 0.08);
                    const arm = new THREE.Mesh(armGeo, trimMat);
                    arm.position.set(-0.75, 1.0, side);
                    car.add(arm);
                    
                    // Mirror housing
                    const mirrorGeo = new THREE.BoxGeometry(0.12, 0.1, 0.15);
                    const mirror = new THREE.Mesh(mirrorGeo, sportBodyMat);
                    mirror.position.set(-0.85, 1.0, side > 0 ? side + 0.08 : side - 0.08);
                    car.add(mirror);
                    
                    // Mirror glass
                    const glassGeo = new THREE.BoxGeometry(0.02, 0.07, 0.1);
                    const mirrorGlass = new THREE.Mesh(glassGeo, sportGlassMat);
                    mirrorGlass.position.set(-0.8, 1.0, side > 0 ? side + 0.12 : side - 0.12);
                    car.add(mirrorGlass);
                });
                
                // --- DOOR HANDLES (flush) ---
                [-1.02, 1.02].forEach(side => {
                    const handleGeo = new THREE.BoxGeometry(0.2, 0.03, 0.03);
                    const handle = new THREE.Mesh(handleGeo, chromeMat);
                    handle.position.set(0.0, 0.9, side);
                    car.add(handle);
                });
                
                // --- ANTENNA (shark fin) ---
                const finShape = new THREE.Shape();
                finShape.moveTo(0, 0);
                finShape.quadraticCurveTo(0.08, 0.12, 0.02, 0.15);
                finShape.lineTo(-0.1, 0);
                finShape.lineTo(0, 0);
                
                const finExtrudeSettings = {
                    steps: 1,
                    depth: 0.06,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.01,
                    bevelSegments: 2
                };
                
                const antennaGeo = new THREE.ExtrudeGeometry(finShape, finExtrudeSettings);
                const antenna = new THREE.Mesh(antennaGeo, trimMat);
                antenna.position.set(0.5, 1.28, -0.03);
                antenna.rotation.y = Math.PI / 2;
                car.add(antenna);
                
                // Skip the common wheel section for sports cars (we built custom wheels above)
                // by setting a flag
                car.userData.hasCustomWheels = true;
                
            } else if (style === 'suv') {
                // ============================================
                // HIGH-QUALITY LOW-POLY SUV (RAV4/CR-V/Grand Cherokee style)
                // Smooth curved surfaces with proper ground clearance
                // ITERATION 3: Enhanced proportions and smoother curves
                // ============================================
                
                // --- BODY PROFILE using ExtrudeGeometry for smooth curves ---
                // Side profile shape (viewed from side, X=length, Y=height)
                // Optimized for tall stance and commanding presence
                const bodyShape = new THREE.Shape();
                
                // Start at front bottom (high ground clearance ~0.4m)
                bodyShape.moveTo(-2.35, 0.38);
                
                // Front bumper - smooth sculpted nose with approach angle
                bodyShape.quadraticCurveTo(-2.55, 0.55, -2.48, 0.82);
                bodyShape.quadraticCurveTo(-2.52, 1.05, -2.42, 1.28);
                
                // Hood line (commanding upward slope, muscular)
                bodyShape.quadraticCurveTo(-2.2, 1.38, -1.65, 1.42);
                
                // A-pillar / windshield (smooth flowing curve)
                bodyShape.quadraticCurveTo(-1.45, 1.55, -1.25, 1.95);
                bodyShape.quadraticCurveTo(-1.15, 2.12, -1.0, 2.2);
                
                // Roof line (gentle dome arc for headroom)
                bodyShape.quadraticCurveTo(-0.4, 2.32, 0.3, 2.3);
                bodyShape.quadraticCurveTo(0.85, 2.26, 1.0, 2.18);
                
                // D-pillar / rear window (smooth descent with style)
                bodyShape.quadraticCurveTo(1.25, 2.05, 1.45, 1.82);
                bodyShape.quadraticCurveTo(1.62, 1.65, 1.72, 1.52);
                
                // Rear hatch (vertical for cargo space)
                bodyShape.lineTo(2.15, 1.48);
                bodyShape.quadraticCurveTo(2.28, 1.42, 2.32, 1.25);
                
                // Rear bumper (sculpted with departure angle)
                bodyShape.quadraticCurveTo(2.38, 1.0, 2.4, 0.78);
                bodyShape.quadraticCurveTo(2.42, 0.55, 2.32, 0.42);
                
                // Rear underbody (wheel arch clearance)
                bodyShape.lineTo(1.85, 0.38);
                bodyShape.quadraticCurveTo(1.58, 0.22, 1.25, 0.38);
                
                // Center underbody (flat for aerodynamics)
                bodyShape.lineTo(-0.85, 0.38);
                
                // Front wheel arch clearance
                bodyShape.quadraticCurveTo(-1.15, 0.22, -1.45, 0.38);
                bodyShape.lineTo(-2.35, 0.38);
                
                const bodyExtrudeSettings = {
                    steps: 1,
                    depth: 2.15,  // Slightly wider for SUV stance
                    bevelEnabled: true,
                    bevelThickness: 0.14,
                    bevelSize: 0.12,
                    bevelSegments: 4  // More segments for smoother edges
                };
                
                const bodyGeo = new THREE.ExtrudeGeometry(bodyShape, bodyExtrudeSettings);
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.set(0, 0, -1.05);  // Center the width
                body.castShadow = true;
                body.receiveShadow = true;
                car.add(body);
                
                // --- FENDER FLARES / WHEEL ARCH CLADDING ---
                const claddingMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, 
                    roughness: 0.85 
                });
                
                // Create wheel arch cladding using curved shapes
                const archShape = new THREE.Shape();
                archShape.absarc(0, 0, 0.65, 0, Math.PI, false);
                archShape.lineTo(-0.65, -0.15);
                archShape.lineTo(0.65, -0.15);
                
                const archExtrudeSettings = {
                    steps: 1,
                    depth: 0.18,
                    bevelEnabled: true,
                    bevelThickness: 0.04,
                    bevelSize: 0.03,
                    bevelSegments: 2
                };
                
                // Front wheel arches (both sides)
                [-1.15, 1.15].forEach(z => {
                    const arch = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(archShape, archExtrudeSettings),
                        claddingMat
                    );
                    arch.rotation.y = z > 0 ? 0 : Math.PI;
                    arch.position.set(-1.45, 0.5, z > 0 ? z - 0.09 : z + 0.09);
                    car.add(arch);
                });
                
                // Rear wheel arches (both sides)  
                [-1.15, 1.15].forEach(z => {
                    const arch = new THREE.Mesh(
                        new THREE.ExtrudeGeometry(archShape, archExtrudeSettings),
                        claddingMat
                    );
                    arch.rotation.y = z > 0 ? 0 : Math.PI;
                    arch.position.set(1.45, 0.5, z > 0 ? z - 0.09 : z + 0.09);
                    car.add(arch);
                });
                
                // --- ROOF RAILS (Chrome, raised properly) ---
                [-0.92, 0.92].forEach(z => {
                    // Rail base mounts
                    [-1.0, 0.0, 0.9].forEach(x => {
                        const mount = new THREE.Mesh(
                            new THREE.BoxGeometry(0.2, 0.1, 0.08),
                            claddingMat
                        );
                        mount.position.set(x, 2.22, z);
                        car.add(mount);
                    });
                    
                    // Main rail bar
                    const rail = new THREE.Mesh(
                        new THREE.CapsuleGeometry(0.04, 2.2, 4, 8),
                        chromeMat
                    );
                    rail.rotation.z = Math.PI / 2;
                    rail.position.set(-0.05, 2.32, z);
                    car.add(rail);
                });
                
                // --- RUNNING BOARDS / SIDE STEPS ---
                [-1.12, 1.12].forEach(z => {
                    const runningBoard = new THREE.Mesh(
                        new THREE.BoxGeometry(2.4, 0.06, 0.25),
                        claddingMat
                    );
                    runningBoard.position.set(0, 0.32, z);
                    car.add(runningBoard);
                    
                    // Aluminum tread plate texture effect
                    const tread = new THREE.Mesh(
                        new THREE.BoxGeometry(2.3, 0.02, 0.2),
                        chromeMat
                    );
                    tread.position.set(0, 0.36, z);
                    car.add(tread);
                });
                
                // --- WINDOWS (Tinted glass panels) ---
                // Windshield (angled, follows body curve)
                const windshieldShape = new THREE.Shape();
                windshieldShape.moveTo(-0.85, 0);
                windshieldShape.lineTo(0.85, 0);
                windshieldShape.lineTo(0.75, 0.7);
                windshieldShape.quadraticCurveTo(0, 0.8, -0.75, 0.7);
                windshieldShape.lineTo(-0.85, 0);
                
                const windshield = new THREE.Mesh(
                    new THREE.ShapeGeometry(windshieldShape),
                    glassMat
                );
                windshield.rotation.x = -0.35;
                windshield.rotation.y = -Math.PI / 2;
                windshield.position.set(-1.48, 1.55, 0);
                car.add(windshield);
                
                // Rear window (less angled)
                const rearWindowShape = new THREE.Shape();
                rearWindowShape.moveTo(-0.78, 0);
                rearWindowShape.lineTo(0.78, 0);
                rearWindowShape.lineTo(0.7, 0.55);
                rearWindowShape.quadraticCurveTo(0, 0.62, -0.7, 0.55);
                rearWindowShape.lineTo(-0.78, 0);
                
                const rearWindow = new THREE.Mesh(
                    new THREE.ShapeGeometry(rearWindowShape),
                    glassMat
                );
                rearWindow.rotation.x = 0.2;
                rearWindow.rotation.y = Math.PI / 2;
                rearWindow.position.set(1.75, 1.55, 0);
                car.add(rearWindow);
                
                // Side windows (trapezoidal shapes)
                [-1.05, 1.05].forEach(z => {
                    // Front door window
                    const frontWinShape = new THREE.Shape();
                    frontWinShape.moveTo(0, 0);
                    frontWinShape.lineTo(0.9, 0);
                    frontWinShape.lineTo(0.85, 0.55);
                    frontWinShape.lineTo(0.15, 0.6);
                    frontWinShape.lineTo(0, 0);
                    
                    const frontWin = new THREE.Mesh(
                        new THREE.ShapeGeometry(frontWinShape),
                        glassMat
                    );
                    frontWin.rotation.y = z > 0 ? 0 : Math.PI;
                    frontWin.position.set(-0.95, 1.58, z > 0 ? z + 0.01 : z - 0.01);
                    car.add(frontWin);
                    
                    // Rear door window  
                    const rearWinShape = new THREE.Shape();
                    rearWinShape.moveTo(0, 0);
                    rearWinShape.lineTo(0.75, 0);
                    rearWinShape.lineTo(0.7, 0.5);
                    rearWinShape.lineTo(0.05, 0.55);
                    rearWinShape.lineTo(0, 0);
                    
                    const rearWin = new THREE.Mesh(
                        new THREE.ShapeGeometry(rearWinShape),
                        glassMat
                    );
                    rearWin.rotation.y = z > 0 ? 0 : Math.PI;
                    rearWin.position.set(0.05, 1.58, z > 0 ? z + 0.01 : z - 0.01);
                    car.add(rearWin);
                    
                    // Quarter window (small triangular)
                    const quarterWin = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.35, 0.02),
                        glassMat
                    );
                    quarterWin.position.set(1.1, 1.72, z > 0 ? z + 0.01 : z - 0.01);
                    car.add(quarterWin);
                });
                
                // --- HIGH-QUALITY ALL-TERRAIN WHEELS (LatheGeometry + detailed brakes) ---
                // Enhanced materials for premium SUV wheels
                const suvWheelRadius = 0.48;
                const suvTireWidth = 0.38;
                const suvRotorMat = new THREE.MeshStandardMaterial({ 
                    color: 0x555555, 
                    metalness: 0.8, 
                    roughness: 0.3 
                });
                const suvCaliperMat = new THREE.MeshStandardMaterial({ 
                    color: 0xcc0000, 
                    metalness: 0.5, 
                    roughness: 0.4 
                });
                const suvLetteringMat = new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.7 });
                const suvSpokeMat = new THREE.MeshStandardMaterial({ 
                    color: 0x666666, 
                    metalness: 0.85, 
                    roughness: 0.25 
                });
                
                // ITERATION 4: Adjusted wheel positions for new body proportions
                const wheelPositions = [
                    [-1.52, 0.48, 1.1],   // Front right
                    [-1.52, 0.48, -1.1],  // Front left
                    [1.48, 0.48, 1.1],    // Rear right 
                    [1.48, 0.48, -1.1]    // Rear left
                ];
                
                wheelPositions.forEach(([x, y, z], idx) => {
                    const wheelGroup = new THREE.Group();
                    const side = z > 0 ? 1 : -1;
                    
                    // --- TIRE using LatheGeometry for proper rounded sidewall profile ---
                    const tireProfile = [];
                    const tireInner = suvWheelRadius - 0.09;
                    const tireOuter = suvWheelRadius;
                    // Create realistic all-terrain tire cross-section with aggressive sidewall bulge
                    for (let i = 0; i <= 14; i++) {
                        const t = i / 14;
                        const angle = t * Math.PI;
                        // Chunky sidewall bulge for SUV tires
                        const bulgeFactor = Math.sin(angle) * (1 + 0.08 * Math.sin(angle * 2));
                        const r = tireInner + (tireOuter - tireInner) * bulgeFactor;
                        const yPos = (t - 0.5) * suvTireWidth;
                        tireProfile.push(new THREE.Vector2(r, yPos));
                    }
                    const tireGeo = new THREE.LatheGeometry(tireProfile, 32);
                    const tire = new THREE.Mesh(tireGeo, wheelMat);
                    tire.rotation.x = Math.PI / 2;
                    tire.castShadow = true;
                    wheelGroup.add(tire);
                    
                    // Tire sidewall protector ridge (raised lip for curb protection)
                    const protectorGeo = new THREE.TorusGeometry(suvWheelRadius - 0.05, 0.012, 6, 32);
                    const protector = new THREE.Mesh(protectorGeo, suvLetteringMat);
                    protector.position.z = side * (suvTireWidth / 2 - 0.02);
                    wheelGroup.add(protector);
                    
                    // Tire brand lettering (raised ridges simulating "ALL-TERRAIN")
                    for (let m = 0; m < 4; m++) {
                        const markAngle = (m / 10 + 0.05) * Math.PI * 2;
                        const markGeo = new THREE.BoxGeometry(0.09, 0.015, 0.012);
                        const mark = new THREE.Mesh(markGeo, suvLetteringMat);
                        mark.position.set(
                            Math.cos(markAngle) * (suvWheelRadius - 0.04),
                            Math.sin(markAngle) * (suvWheelRadius - 0.04),
                            side * (suvTireWidth / 2 - 0.015)
                        );
                        mark.rotation.z = markAngle + Math.PI / 2;
                        wheelGroup.add(mark);
                    }
                    
                    // Tire size markings on sidewall
                    for (let m = 0; m < 2; m++) {
                        const markAngle = (m / 12 + 0.55) * Math.PI * 2;
                        const markGeo = new THREE.BoxGeometry(0.06, 0.01, 0.01);
                        const mark = new THREE.Mesh(markGeo, suvLetteringMat);
                        mark.position.set(
                            Math.cos(markAngle) * (suvWheelRadius - 0.035),
                            Math.sin(markAngle) * (suvWheelRadius - 0.035),
                            side * (suvTireWidth / 2 - 0.018)
                        );
                        mark.rotation.z = markAngle + Math.PI / 2;
                        wheelGroup.add(mark);
                    }
                    
                    // --- RIM with deep dish and polished lip ---
                    const rimRadius = suvWheelRadius - 0.11;
                    
                    // Rim barrel (inner visible part)
                    const rimBarrelGeo = new THREE.CylinderGeometry(rimRadius, rimRadius - 0.02, suvTireWidth - 0.05, 24);
                    const rimBarrelMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.35 });
                    const rimBarrel = new THREE.Mesh(rimBarrelGeo, rimBarrelMat);
                    rimBarrel.rotation.x = Math.PI / 2;
                    wheelGroup.add(rimBarrel);
                    
                    // Polished rim lip (outer edge)
                    const rimLipGeo = new THREE.TorusGeometry(rimRadius + 0.01, 0.022, 8, 32);
                    const rimLip = new THREE.Mesh(rimLipGeo, chromeMat);
                    rimLip.position.z = side * (suvTireWidth / 2 - 0.05);
                    wheelGroup.add(rimLip);
                    
                    // Rim face (slightly concave dish)
                    const rimFaceGeo = new THREE.CylinderGeometry(rimRadius - 0.01, rimRadius - 0.03, 0.02, 24);
                    const rimFaceMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9, roughness: 0.15 });
                    const rimFace = new THREE.Mesh(rimFaceGeo, rimFaceMat);
                    rimFace.rotation.x = Math.PI / 2;
                    rimFace.position.z = side * (suvTireWidth / 2 - 0.07);
                    wheelGroup.add(rimFace);
                    
                    // --- TWIN-SPOKE ALLOY DESIGN (5 pairs = 10 spokes) ---
                    for (let i = 0; i < 5; i++) {
                        const spokeAngle = (i / 5) * Math.PI * 2 + Math.PI / 10;
                        const spokeLen = rimRadius - 0.06;
                        
                        // Main spoke (wider at hub)
                        const spokeGeo = new THREE.BoxGeometry(spokeLen, 0.045, 0.028);
                        const spoke = new THREE.Mesh(spokeGeo, chromeMat);
                        spoke.position.set(
                            Math.cos(spokeAngle) * (spokeLen / 2),
                            Math.sin(spokeAngle) * (spokeLen / 2),
                            side * (suvTireWidth / 2 - 0.06)
                        );
                        spoke.rotation.z = spokeAngle;
                        wheelGroup.add(spoke);
                        
                        // Twin spoke (secondary for 10-spoke look)
                        const spoke2Geo = new THREE.BoxGeometry(spokeLen * 0.88, 0.032, 0.022);
                        const spoke2 = new THREE.Mesh(spoke2Geo, suvSpokeMat);
                        spoke2.position.set(
                            Math.cos(spokeAngle + 0.16) * (spokeLen / 2 - 0.01),
                            Math.sin(spokeAngle + 0.16) * (spokeLen / 2 - 0.01),
                            side * (suvTireWidth / 2 - 0.065)
                        );
                        spoke2.rotation.z = spokeAngle + 0.16;
                        wheelGroup.add(spoke2);
                    }
                    
                    // --- CENTER HUB CAP (domed with logo detail) ---
                    const hubCapGeo = new THREE.SphereGeometry(0.065, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const hubCap = new THREE.Mesh(hubCapGeo, chromeMat);
                    hubCap.rotation.x = side > 0 ? -Math.PI / 2 : Math.PI / 2;
                    hubCap.position.z = side * (suvTireWidth / 2 - 0.04);
                    wheelGroup.add(hubCap);
                    
                    // Hub ring accent
                    const hubRingGeo = new THREE.TorusGeometry(0.045, 0.007, 8, 16);
                    const hubRing = new THREE.Mesh(hubRingGeo, suvSpokeMat);
                    hubRing.position.z = side * (suvTireWidth / 2 - 0.035);
                    wheelGroup.add(hubRing);
                    
                    // --- LUG NUTS (5 visible - SUV style) ---
                    const lugRadius = rimRadius * 0.32;
                    for (let lugIdx = 0; lugIdx < 5; lugIdx++) {
                        const lugAngle = (lugIdx / 5) * Math.PI * 2 + Math.PI / 10;
                        const lugGeo = new THREE.CylinderGeometry(0.014, 0.016, 0.018, 6);
                        const lugNut = new THREE.Mesh(lugGeo, chromeMat);
                        lugNut.rotation.x = Math.PI / 2;
                        lugNut.position.set(
                            Math.cos(lugAngle) * lugRadius,
                            Math.sin(lugAngle) * lugRadius,
                            side * (suvTireWidth / 2 - 0.025)
                        );
                        wheelGroup.add(lugNut);
                    }
                    
                    // --- BRAKE ROTOR (cross-drilled performance style) ---
                    const rotorRadius = rimRadius - 0.06;
                    const rotorGeo = new THREE.CylinderGeometry(rotorRadius, rotorRadius, 0.035, 32);
                    const rotor = new THREE.Mesh(rotorGeo, suvRotorMat);
                    rotor.rotation.x = Math.PI / 2;
                    rotor.position.z = -side * 0.05;
                    wheelGroup.add(rotor);
                    
                    // Rotor hub (center mounting flange)
                    const rotorHubGeo = new THREE.CylinderGeometry(0.055, 0.055, 0.04, 16);
                    const rotorHub = new THREE.Mesh(rotorHubGeo, suvRotorMat);
                    rotorHub.rotation.x = Math.PI / 2;
                    rotorHub.position.z = -side * 0.05;
                    wheelGroup.add(rotorHub);
                    
                    // Cross-drilled holes (2 rings for realism)
                    const holeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
                    for (let ring = 0; ring < 2; ring++) {
                        const holeRadius = rotorRadius - 0.04 - ring * 0.055;
                        const holeCount = 16 - ring * 4;
                        for (let h = 0; h < holeCount; h++) {
                            const angle = (h / holeCount) * Math.PI * 2;
                            const holeGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.04, 6);
                            const hole = new THREE.Mesh(holeGeo, holeMat);
                            hole.rotation.x = Math.PI / 2;
                            hole.position.set(
                                Math.cos(angle) * holeRadius,
                                Math.sin(angle) * holeRadius,
                                -side * 0.05
                            );
                            wheelGroup.add(hole);
                        }
                    }
                    
                    // Ventilation slots (curved for realism)
                    for (let v = 0; v < 20; v++) {
                        const angle = (v / 20) * Math.PI * 2;
                        const slotGeo = new THREE.BoxGeometry(0.055, 0.035, 0.005);
                        const slot = new THREE.Mesh(slotGeo, trimMat);
                        const slotR = rotorRadius - 0.14;
                        slot.position.set(
                            Math.cos(angle) * slotR,
                            Math.sin(angle) * slotR,
                            -side * 0.05
                        );
                        slot.rotation.z = angle + 0.22;
                        wheelGroup.add(slot);
                    }
                    
                    // --- RED BRAKE CALIPER (visible through spokes) ---
                    const caliperAngle = idx < 2 ? -0.4 : -0.3;
                    const caliperX = Math.cos(caliperAngle) * (rotorRadius - 0.04);
                    const caliperY = Math.sin(caliperAngle) * (rotorRadius - 0.04) + 0.025;
                    
                    // Caliper body
                    const caliperGeo = new THREE.BoxGeometry(0.13, 0.08, 0.06);
                    const caliper = new THREE.Mesh(caliperGeo, suvCaliperMat);
                    caliper.position.set(caliperX, caliperY, -side * 0.07);
                    caliper.rotation.z = caliperAngle + 0.1;
                    wheelGroup.add(caliper);
                    
                    // Caliper lettering detail (raised "BRAKE" area)
                    const letterGeo = new THREE.BoxGeometry(0.08, 0.045, 0.008);
                    const letter = new THREE.Mesh(letterGeo, new THREE.MeshStandardMaterial({ 
                        color: 0xdd0000, metalness: 0.4, roughness: 0.45 
                    }));
                    letter.position.set(caliperX, caliperY, -side * 0.04);
                    letter.rotation.z = caliperAngle + 0.1;
                    wheelGroup.add(letter);
                    
                    // Caliper mounting bracket
                    const bracketGeo = new THREE.BoxGeometry(0.022, 0.12, 0.045);
                    const bracket = new THREE.Mesh(bracketGeo, trimMat);
                    bracket.position.set(
                        Math.cos(caliperAngle) * (rotorRadius - 0.1),
                        Math.sin(caliperAngle) * (rotorRadius - 0.1),
                        -side * 0.08
                    );
                    wheelGroup.add(bracket);
                    
                    // Brake line fitting (hydraulic connection)
                    const fittingGeo = new THREE.CylinderGeometry(0.006, 0.008, 0.028, 6);
                    const fitting = new THREE.Mesh(fittingGeo, chromeMat);
                    fitting.position.set(caliperX + 0.05, caliperY + 0.025, -side * 0.07);
                    wheelGroup.add(fitting);
                    
                    wheelGroup.position.set(x, y, z);
                    wheelGroup.castShadow = true;
                    car.add(wheelGroup);
                });
                
                // Set custom wheels flag to skip common wheel section
                car.userData.hasCustomWheels = true;
                
                // --- GRILLE (Bold horizontal bars) ---
                const grilleMat = new THREE.MeshStandardMaterial({ 
                    color: 0x111111, 
                    roughness: 0.3 
                });
                
                // Main grille housing
                const grilleHousing = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.45, 1.4),
                    chromeMat
                );
                grilleHousing.position.set(-2.42, 0.9, 0);
                car.add(grilleHousing);
                
                // Grille bars
                for (let i = 0; i < 5; i++) {
                    const bar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.05, 1.3),
                        chromeMat
                    );
                    bar.position.set(-2.46, 0.72 + i * 0.09, 0);
                    car.add(bar);
                }
                
                // --- HEADLIGHTS (Modern LED-style with enhanced glow) ---
                const suvLedMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    emissive: 0xffffff, 
                    emissiveIntensity: 3.0,
                    roughness: 0.1
                });
                [-0.55, 0.55].forEach(z => {
                    // Main headlight housing (dark background)
                    const housing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.25, 0.42),
                        trimMat
                    );
                    housing.position.set(-2.38, 1.1, z);
                    car.add(housing);
                    
                    // Chrome bezel around housing
                    const bezel = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.28, 0.45),
                        chromeMat
                    );
                    bezel.position.set(-2.42, 1.1, z);
                    car.add(bezel);
                    
                    // LED strip (daytime running light - brighter)
                    const ledStrip = new THREE.Mesh(
                        new THREE.BoxGeometry(0.03, 0.05, 0.36),
                        suvLedMat
                    );
                    ledStrip.position.set(-2.45, 1.17, z);
                    car.add(ledStrip);
                    
                    // Main beam projector (glowing center)
                    const beamMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffee, 
                        emissive: 0xffffcc, 
                        emissiveIntensity: 4.0,
                        roughness: 0.05
                    });
                    const beam = new THREE.Mesh(
                        new THREE.SphereGeometry(0.09, 16, 12),
                        beamMat
                    );
                    beam.scale.x = 0.4;
                    beam.position.set(-2.46, 1.05, z);
                    car.add(beam);
                    
                    // Low beam (secondary light)
                    const lowBeam = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05, 12, 8),
                        headlightMat
                    );
                    lowBeam.position.set(-2.44, 0.98, z);
                    car.add(lowBeam);
                });
                
                // --- TAILLIGHTS (Vertical LED-style, visible from behind) ---
                [-0.7, 0.7].forEach(z => {
                    // Vertical taillight housing
                    const tailHousing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.5, 0.25),
                        trimMat
                    );
                    tailHousing.position.set(2.35, 1.25, z);
                    car.add(tailHousing);
                    
                    // LED segments - use emissive material for brake light effect
                    for (let i = 0; i < 4; i++) {
                        const segmentMat = new THREE.MeshStandardMaterial({ 
                            color: 0xdd0000, 
                            emissive: 0xcc0000, 
                            emissiveIntensity: 2.0,
                            roughness: 0.3
                        });
                        const segment = new THREE.Mesh(
                            new THREE.BoxGeometry(0.02, 0.08, 0.2),
                            segmentMat
                        );
                        segment.position.set(2.41, 1.05 + i * 0.12, z);
                        car.add(segment);
                        car.userData.taillights.push(segment); // Track for brake effect
                    }
                    
                    // Add turn signal to bottom of each taillight cluster
                    const turnMat = new THREE.MeshStandardMaterial({ 
                        color: 0xff6600, 
                        emissive: 0xff5500, 
                        emissiveIntensity: 0.3,
                        roughness: 0.3
                    });
                    const turn = new THREE.Mesh(
                        new THREE.BoxGeometry(0.02, 0.06, 0.2),
                        turnMat
                    );
                    turn.position.set(2.41, 0.95, z);
                    car.add(turn);
                    if (z > 0) {
                        car.userData.rightBlinkers.push(turn);
                    } else {
                        car.userData.leftBlinkers.push(turn);
                    }
                });
                
                // Rear reflector strip (also serves as center brake light)
                const reflectorMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff3300, 
                    emissive: 0xee2200, 
                    emissiveIntensity: 2.0,
                    roughness: 0.3
                });
                const reflector = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.06, 0.8),
                    reflectorMat
                );
                reflector.position.set(2.42, 0.65, 0);
                car.add(reflector);
                car.userData.taillights.push(reflector);
                
                // --- LICENSE PLATE AREA ---
                const plateMat = new THREE.MeshBasicMaterial({ color: 0xffffee });
                const plate = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.2, 0.5),
                    plateMat
                );
                plate.position.set(2.42, 0.85, 0);
                car.add(plate);
                
                // Plate light
                const plateLight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.04, 0.15),
                    ledMat
                );
                plateLight.position.set(2.42, 1.0, 0);
                car.add(plateLight);
                
                // --- DOOR HANDLES (Chrome) ---
                [-1.05, 1.05].forEach(z => {
                    // Front door handle
                    const handle1 = new THREE.Mesh(
                        new THREE.BoxGeometry(0.18, 0.04, 0.03),
                        chromeMat
                    );
                    handle1.position.set(-0.5, 1.4, z);
                    car.add(handle1);
                    
                    // Rear door handle
                    const handle2 = new THREE.Mesh(
                        new THREE.BoxGeometry(0.18, 0.04, 0.03),
                        chromeMat
                    );
                    handle2.position.set(0.5, 1.4, z);
                    car.add(handle2);
                });
                
                // --- SIDE MIRRORS (with glass and turn signals) ---
                [-1.15, 1.15].forEach(z => {
                    // Mirror arm (angled for aerodynamics)
                    const arm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.18, 0.05, 0.08),
                        trimMat
                    );
                    arm.position.set(-1.2, 1.6, z);
                    car.add(arm);
                    
                    // Mirror housing (body-colored)
                    const mirrorHousing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.12, 0.15, 0.12),
                        bodyMat
                    );
                    mirrorHousing.position.set(-1.32, 1.58, z);
                    car.add(mirrorHousing);
                    
                    // Mirror glass (reflective surface)
                    const mirrorGlass = new THREE.Mesh(
                        new THREE.BoxGeometry(0.02, 0.1, 0.08),
                        glassMat
                    );
                    mirrorGlass.position.set(-1.36, 1.58, z > 0 ? z + 0.02 : z - 0.02);
                    car.add(mirrorGlass);
                    
                    // Turn signal indicator on mirror (LED strip)
                    const mirrorSignal = new THREE.Mesh(
                        new THREE.BoxGeometry(0.02, 0.025, 0.06),
                        new THREE.MeshBasicMaterial({ color: 0xff8800 })
                    );
                    mirrorSignal.position.set(-1.38, 1.52, z);
                    car.add(mirrorSignal);
                });
                
                // --- FRONT BUMPER DETAILS ---
                // Fog light housings
                [-0.65, 0.65].forEach(z => {
                    const fogHousing = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 0.06, 12),
                        trimMat
                    );
                    fogHousing.rotation.z = Math.PI / 2;
                    fogHousing.position.set(-2.42, 0.55, z);
                    car.add(fogHousing);
                    
                    const fogLight = new THREE.Mesh(
                        new THREE.CircleGeometry(0.07, 10),
                        new THREE.MeshBasicMaterial({ color: 0xffffcc })
                    );
                    fogLight.rotation.y = -Math.PI / 2;
                    fogLight.position.set(-2.45, 0.55, z);
                    car.add(fogLight);
                });
                
                // Lower bumper intake
                const intake = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.15, 1.2),
                    grilleMat
                );
                intake.position.set(-2.42, 0.42, 0);
                car.add(intake);
                
                // --- SUBTLE BODY LINES ---
                // Character line along body side
                [-1.06, 1.06].forEach(z => {
                    const characterLine = new THREE.Mesh(
                        new THREE.BoxGeometry(3.5, 0.015, 0.015),
                        chromeMat
                    );
                    characterLine.position.set(-0.1, 1.2, z);
                    car.add(characterLine);
                });
                
                // --- ITERATION 2 ENHANCEMENTS ---
                
                // Shark fin antenna (modern SUV staple)
                const finShape = new THREE.Shape();
                finShape.moveTo(0, 0);
                finShape.quadraticCurveTo(0.15, 0.12, 0.12, 0.0);
                finShape.lineTo(0, 0);
                
                const finGeo = new THREE.ExtrudeGeometry(finShape, {
                    steps: 1, depth: 0.06, bevelEnabled: true, 
                    bevelThickness: 0.015, bevelSize: 0.015, bevelSegments: 2
                });
                const sharkFin = new THREE.Mesh(finGeo, trimMat);
                sharkFin.rotation.x = Math.PI / 2;
                sharkFin.rotation.z = -Math.PI / 2;
                sharkFin.position.set(0.6, 2.25, 0);
                car.add(sharkFin);
                
                // Rear wiper (SUV characteristic)
                const wiperArm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.02, 0.015),
                    trimMat
                );
                wiperArm.position.set(1.6, 1.85, 0);
                wiperArm.rotation.z = 0.3;
                car.add(wiperArm);
                
                const wiperBlade = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.015, 0.04),
                    new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 })
                );
                wiperBlade.position.set(1.78, 1.92, 0);
                wiperBlade.rotation.z = 0.3;
                car.add(wiperBlade);
                
                // Front skid plate (rugged appearance)
                const skidPlateMat = new THREE.MeshStandardMaterial({ 
                    color: 0x666666, 
                    metalness: 0.5, 
                    roughness: 0.6 
                });
                const frontSkid = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 0.08, 1.5),
                    skidPlateMat
                );
                frontSkid.position.set(-2.25, 0.3, 0);
                car.add(frontSkid);
                
                // Rear skid plate / diffuser
                const rearSkid = new THREE.Mesh(
                    new THREE.BoxGeometry(0.35, 0.08, 1.4),
                    skidPlateMat
                );
                rearSkid.position.set(2.2, 0.35, 0);
                car.add(rearSkid);
                
                // Lower body cladding (black plastic trim like modern crossovers)
                const lowerCladdingMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, 
                    roughness: 0.9 
                });
                
                // Side lower cladding strips
                [-1.08, 1.08].forEach(z => {
                    const sideCladding = new THREE.Mesh(
                        new THREE.BoxGeometry(3.2, 0.22, 0.08),
                        lowerCladdingMat
                    );
                    sideCladding.position.set(0, 0.42, z);
                    car.add(sideCladding);
                });
                
                // Front lower valance
                const frontValance = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.18, 1.9),
                    lowerCladdingMat
                );
                frontValance.position.set(-2.38, 0.35, 0);
                car.add(frontValance);
                
                // Rear lower valance  
                const rearValance = new THREE.Mesh(
                    new THREE.BoxGeometry(0.12, 0.2, 1.85),
                    lowerCladdingMat
                );
                rearValance.position.set(2.38, 0.4, 0);
                car.add(rearValance);
                
                // D-pillar privacy glass (blacked out for SUV look)
                [-1.03, 1.03].forEach(z => {
                    const dPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.55, 0.45, 0.03),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x111122, 
                            metalness: 0.8, 
                            roughness: 0.1 
                        })
                    );
                    dPillar.position.set(1.35, 1.82, z);
                    car.add(dPillar);
                });
                
                // Exhaust tip (single, chrome)
                const exhaustTip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.07, 0.12, 12),
                    chromeMat
                );
                exhaustTip.rotation.z = Math.PI / 2;
                exhaustTip.position.set(2.42, 0.38, -0.4);
                car.add(exhaustTip);
                
                // Exhaust inner (dark)
                const exhaustInner = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.04, 0.04, 0.08, 8),
                    trimMat
                );
                exhaustInner.rotation.z = Math.PI / 2;
                exhaustInner.position.set(2.46, 0.38, -0.4);
                car.add(exhaustInner);
                
                // Roof crossbars (between rails - for cargo)
                [-0.5, 0.6].forEach(x => {
                    const crossbar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.04, 1.9),
                        trimMat
                    );
                    crossbar.position.set(x, 2.35, 0);
                    car.add(crossbar);
                });
                
                // Badge/emblem on rear hatch
                const badge = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.08, 0.35),
                    chromeMat
                );
                badge.position.set(2.42, 1.7, 0);
                car.add(badge);
                
                // Side turn signal repeaters (on mirrors)
                [-1.33, 1.33].forEach(z => {
                    const repeater = new THREE.Mesh(
                        new THREE.BoxGeometry(0.02, 0.03, 0.06),
                        new THREE.MeshBasicMaterial({ color: 0xff8800 })
                    );
                    repeater.position.set(-1.35, 1.52, z);
                    car.add(repeater);
                });
                
                // --- ITERATION 3: FINAL POLISH ---
                
                // Puddle lights (under mirrors - modern luxury SUV feature)
                [-1.35, 1.35].forEach(z => {
                    const puddleLight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.015, 0.06),
                        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
                    );
                    puddleLight.position.set(-1.28, 1.48, z);
                    car.add(puddleLight);
                });
                
                // Interior silhouette (dark cabin visible through windows)
                const interiorMat = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a0a, 
                    roughness: 0.9 
                });
                
                // Dashboard/interior volume
                const interiorVolume = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.4, 1.6),
                    interiorMat
                );
                interiorVolume.position.set(-0.3, 1.55, 0);
                car.add(interiorVolume);
                
                // Headrests (visible through rear window)
                [-0.45, 0.45].forEach(z => {
                    const headrest = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.2, 0.12),
                        interiorMat
                    );
                    headrest.position.set(0.4, 1.85, z);
                    car.add(headrest);
                });
                
                // Front grille brand bar (horizontal chrome accent)
                const brandBar = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.12, 1.5),
                    chromeMat
                );
                brandBar.position.set(-2.5, 1.02, 0);
                car.add(brandBar);
                
                // Grille mesh texture (honeycomb illusion)
                const grilleMeshMat = new THREE.MeshStandardMaterial({ 
                    color: 0x080808, 
                    roughness: 0.4,
                    metalness: 0.3
                });
                const grilleMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, 0.35, 1.35),
                    grilleMeshMat
                );
                grilleMesh.position.set(-2.48, 0.88, 0);
                car.add(grilleMesh);
                
                // Air dam / lower grille opening
                const airDam = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.12, 1.6),
                    grilleMeshMat
                );
                airDam.position.set(-2.48, 0.48, 0);
                car.add(airDam);
                
                // Tow hook cover (front)
                const towHookCover = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.08, 0.12),
                    claddingMat
                );
                towHookCover.position.set(-2.48, 0.42, 0.55);
                car.add(towHookCover);
                
                // Rear tow hook cover
                const rearTowCover = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.08, 0.12),
                    claddingMat
                );
                rearTowCover.position.set(2.42, 0.48, -0.55);
                car.add(rearTowCover);
                
                // Rear bumper step pad (textured plastic)
                const stepPad = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.03, 0.8),
                    new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 1 })
                );
                stepPad.position.set(2.38, 0.52, 0);
                car.add(stepPad);
                
                // Third brake light (top of rear window)
                const thirdBrake = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.05, 0.4),
                    new THREE.MeshBasicMaterial({ color: 0xcc0000 })
                );
                thirdBrake.position.set(1.65, 2.08, 0);
                car.add(thirdBrake);
                
                // Wheel well liners (dark plastic visible inside arches)
                const linerMat = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 1 });
                wheelPositions.forEach(([x, y, z]) => {
                    const liner = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.55, 0.55, 0.12, 16, 1, true, 0, Math.PI),
                        linerMat
                    );
                    liner.rotation.z = Math.PI / 2;
                    liner.rotation.y = z > 0 ? 0 : Math.PI;
                    liner.position.set(x, y + 0.15, z > 0 ? z - 0.06 : z + 0.06);
                    car.add(liner);
                });
                
            } else if (style === 'hatchback') {
                // ============================================
                // HIGH-QUALITY EUROPEAN HATCHBACK
                // Inspired by VW Golf / Honda Civic / Mazda 3
                // Smooth modern styling with sporty stance
                // ============================================
                
                // LED material for lights
                const ledMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                
                // --- MAIN BODY using ExtrudeGeometry for smooth curves ---
                const bodyShape = new THREE.Shape();
                // Start from front bottom, trace the side profile
                bodyShape.moveTo(-2.1, 0.25);   // Front bottom
                bodyShape.lineTo(-2.15, 0.4);   // Front bumper rise
                bodyShape.quadraticCurveTo(-2.2, 0.65, -2.1, 0.85);  // Front bumper curve
                bodyShape.lineTo(-2.0, 0.95);   // Hood start
                bodyShape.lineTo(-0.9, 1.1);    // Hood slope (slightly rising)
                bodyShape.quadraticCurveTo(-0.7, 1.12, -0.5, 1.35);  // A-pillar base curve
                bodyShape.lineTo(0.1, 1.75);    // Windshield (steep angle)
                bodyShape.quadraticCurveTo(0.2, 1.82, 0.4, 1.85);    // Roof front curve
                bodyShape.lineTo(1.4, 1.85);    // Roof (flat section)
                bodyShape.quadraticCurveTo(1.55, 1.84, 1.7, 1.7);    // Roof spoiler start
                bodyShape.lineTo(2.0, 1.35);    // Hatchback slope (D-pillar)
                bodyShape.quadraticCurveTo(2.08, 1.15, 2.1, 0.95);   // Rear curve
                bodyShape.lineTo(2.1, 0.55);    // Rear lower
                bodyShape.quadraticCurveTo(2.08, 0.35, 1.95, 0.25);  // Rear bumper curve
                bodyShape.lineTo(-2.1, 0.25);   // Back to start
                
                const bodyExtrudeSettings = {
                    steps: 1,
                    depth: 1.85,
                    bevelEnabled: true,
                    bevelThickness: 0.08,
                    bevelSize: 0.06,
                    bevelSegments: 3
                };
                
                const bodyGeo = new THREE.ExtrudeGeometry(bodyShape, bodyExtrudeSettings);
                bodyGeo.center();
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.y = Math.PI / 2;
                body.position.set(0, 0.85, 0);
                body.castShadow = true;
                car.add(body);
                
                // --- ROOF PANEL (slightly raised) ---
                const roofGeo = new THREE.BoxGeometry(1.8, 0.06, 1.65);
                const roof = new THREE.Mesh(roofGeo, bodyMat);
                roof.position.set(0.2, 1.88, 0);
                car.add(roof);
                
                // --- INTEGRATED ROOF SPOILER ---
                const spoilerShape = new THREE.Shape();
                spoilerShape.moveTo(0, 0);
                spoilerShape.lineTo(0.35, 0);
                spoilerShape.quadraticCurveTo(0.4, 0.08, 0.35, 0.12);
                spoilerShape.lineTo(0.05, 0.1);
                spoilerShape.quadraticCurveTo(0, 0.06, 0, 0);
                
                const spoilerSettings = { steps: 1, depth: 1.55, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02, bevelSegments: 2 };
                const spoilerGeo = new THREE.ExtrudeGeometry(spoilerShape, spoilerSettings);
                const spoiler = new THREE.Mesh(spoilerGeo, bodyMat);
                spoiler.rotation.y = Math.PI / 2;
                spoiler.position.set(1.55, 1.72, 0.77);
                spoiler.castShadow = true;
                car.add(spoiler);
                
                // --- WINDSHIELD (steeply raked) ---
                const windshieldShape = new THREE.Shape();
                windshieldShape.moveTo(0, 0);
                windshieldShape.lineTo(0.85, 0);
                windshieldShape.lineTo(0.75, 0.05);
                windshieldShape.lineTo(0.05, 0.05);
                windshieldShape.lineTo(0, 0);
                
                const wsSettings = { steps: 1, depth: 1.5, bevelEnabled: false };
                const wsGeo = new THREE.ExtrudeGeometry(windshieldShape, wsSettings);
                const windshield = new THREE.Mesh(wsGeo, glassMat);
                windshield.rotation.set(0, Math.PI/2, -0.9);
                windshield.position.set(-0.45, 1.25, 0.75);
                car.add(windshield);
                
                // --- REAR HATCH WINDOW (large, steeply angled) ---
                const rearWinShape = new THREE.Shape();
                rearWinShape.moveTo(0, 0);
                rearWinShape.lineTo(0.55, 0);
                rearWinShape.lineTo(0.48, 0.04);
                rearWinShape.lineTo(0.04, 0.04);
                rearWinShape.lineTo(0, 0);
                
                const rwSettings = { steps: 1, depth: 1.4, bevelEnabled: false };
                const rwGeo = new THREE.ExtrudeGeometry(rearWinShape, rwSettings);
                const rearWindow = new THREE.Mesh(rwGeo, glassMat);
                rearWindow.rotation.set(0, Math.PI/2, 0.65);
                rearWindow.position.set(1.75, 1.4, 0.7);
                car.add(rearWindow);
                
                // --- SIDE WINDOWS with black trim frame ---
                [-0.94, 0.94].forEach(z => {
                    // Window glass
                    const sideWin = new THREE.Mesh(
                        new THREE.BoxGeometry(1.85, 0.5, 0.04),
                        glassMat
                    );
                    sideWin.position.set(0.35, 1.55, z);
                    car.add(sideWin);
                    
                    // B-pillar (black trim between windows)
                    const bPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.55, 0.06),
                        trimMat
                    );
                    bPillar.position.set(0.15, 1.55, z * 1.01);
                    car.add(bPillar);
                    
                    // Window surround trim
                    const topTrim = new THREE.Mesh(
                        new THREE.BoxGeometry(2.0, 0.04, 0.06),
                        trimMat
                    );
                    topTrim.position.set(0.3, 1.82, z * 1.01);
                    car.add(topTrim);
                });
                
                // --- SIDE SKIRTS (sporty lower body trim) ---
                const skirtMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.6 });
                [-1.0, 1.0].forEach(z => {
                    const skirt = new THREE.Mesh(
                        new THREE.BoxGeometry(3.8, 0.12, 0.08),
                        skirtMat
                    );
                    skirt.position.set(0, 0.32, z);
                    car.add(skirt);
                });
                
                // --- WHEEL ARCH FLARES (muscular fender flares) ---
                const flareMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.7 });
                // Front wheel arches
                [-0.98, 0.98].forEach(z => {
                    // Front arch flare
                    const frontArchShape = new THREE.Shape();
                    frontArchShape.absarc(0, 0, 0.55, Math.PI * 0.15, Math.PI * 0.85, false);
                    frontArchShape.absarc(0, 0, 0.48, Math.PI * 0.85, Math.PI * 0.15, true);
                    
                    const frontArchGeo = new THREE.ExtrudeGeometry(frontArchShape, { depth: 0.08, bevelEnabled: false });
                    const frontArch = new THREE.Mesh(frontArchGeo, flareMat);
                    frontArch.rotation.y = z > 0 ? 0 : Math.PI;
                    frontArch.position.set(-1.35, 0.44, z > 0 ? z + 0.04 : z - 0.04);
                    car.add(frontArch);
                    
                    // Rear arch flare
                    const rearArchShape = new THREE.Shape();
                    rearArchShape.absarc(0, 0, 0.55, Math.PI * 0.15, Math.PI * 0.85, false);
                    rearArchShape.absarc(0, 0, 0.48, Math.PI * 0.85, Math.PI * 0.15, true);
                    
                    const rearArchGeo = new THREE.ExtrudeGeometry(rearArchShape, { depth: 0.08, bevelEnabled: false });
                    const rearArch = new THREE.Mesh(rearArchGeo, flareMat);
                    rearArch.rotation.y = z > 0 ? 0 : Math.PI;
                    rearArch.position.set(1.35, 0.44, z > 0 ? z + 0.04 : z - 0.04);
                    car.add(rearArch);
                });
                
                // --- REAR DIFFUSER (sporty aerodynamic element) ---
                const diffuserShape = new THREE.Shape();
                diffuserShape.moveTo(-0.7, 0);
                diffuserShape.lineTo(0.7, 0);
                diffuserShape.lineTo(0.6, -0.12);
                diffuserShape.lineTo(-0.6, -0.12);
                diffuserShape.lineTo(-0.7, 0);
                
                const diffuserGeo = new THREE.ExtrudeGeometry(diffuserShape, { depth: 0.35, bevelEnabled: false });
                const diffuser = new THREE.Mesh(diffuserGeo, trimMat);
                diffuser.rotation.x = Math.PI / 2;
                diffuser.position.set(2.0, 0.32, 0.175);
                car.add(diffuser);
                
                // Diffuser fins
                [-0.35, 0, 0.35].forEach(z => {
                    const fin = new THREE.Mesh(
                        new THREE.BoxGeometry(0.3, 0.08, 0.02),
                        trimMat
                    );
                    fin.position.set(2.05, 0.28, z);
                    car.add(fin);
                });
                
                // --- SHARK FIN ANTENNA ---
                const antennaShape = new THREE.Shape();
                antennaShape.moveTo(0, 0);
                antennaShape.lineTo(0.12, 0);
                antennaShape.quadraticCurveTo(0.14, 0.08, 0.08, 0.15);
                antennaShape.quadraticCurveTo(0.02, 0.12, 0, 0);
                
                const antennaGeo = new THREE.ExtrudeGeometry(antennaShape, { depth: 0.06, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.01, bevelSegments: 2 });
                const antenna = new THREE.Mesh(antennaGeo, trimMat);
                antenna.rotation.x = -Math.PI / 2;
                antenna.position.set(0.8, 1.88, 0.03);
                car.add(antenna);
                
                // --- A-PILLAR TRIM (black) ---
                [-0.96, 0.96].forEach(z => {
                    const aPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.55, 0.06, 0.04),
                        trimMat
                    );
                    aPillar.rotation.z = 0.9;
                    aPillar.position.set(-0.4, 1.48, z);
                    car.add(aPillar);
                });
                
                // --- SIDE MIRRORS (aerodynamic teardrop shape) ---
                [-0.98, 0.98].forEach(z => {
                    // Mirror stalk/arm
                    const mirrorArmGeo = new THREE.BoxGeometry(0.1, 0.04, 0.1);
                    const mirrorArm = new THREE.Mesh(mirrorArmGeo, trimMat);
                    mirrorArm.position.set(-0.85, 1.42, z);
                    car.add(mirrorArm);
                    
                    // Mirror housing (teardrop shape using extruded bezier)
                    const mirrorShape = new THREE.Shape();
                    mirrorShape.moveTo(0, 0);
                    mirrorShape.quadraticCurveTo(-0.05, 0.07, 0, 0.12);
                    mirrorShape.quadraticCurveTo(0.07, 0.07, 0, 0);
                    
                    const mirrorGeo = new THREE.ExtrudeGeometry(mirrorShape, {
                        steps: 1, depth: 0.05, bevelEnabled: true,
                        bevelThickness: 0.012, bevelSize: 0.012, bevelSegments: 2
                    });
                    const mirror = new THREE.Mesh(mirrorGeo, bodyMat);
                    mirror.rotation.x = Math.PI / 2;
                    mirror.position.set(-0.92, 1.35, z > 0 ? z + 0.02 : z - 0.07);
                    car.add(mirror);
                    
                    // Mirror glass
                    const mirrorGlass = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.07, 0.09),
                        new THREE.MeshStandardMaterial({ color: 0x223344, metalness: 0.95, roughness: 0.05 })
                    );
                    mirrorGlass.rotation.y = z > 0 ? Math.PI / 2 : -Math.PI / 2;
                    mirrorGlass.position.set(-0.92, 1.38, z > 0 ? z + 0.08 : z - 0.08);
                    car.add(mirrorGlass);
                    
                    // Turn signal indicator (on mirror housing) - clone for independent flash
                    const mirrorSignalMat = blinkerMat.clone();
                    const mirrorSignal = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.015, 0.04),
                        mirrorSignalMat
                    );
                    mirrorSignal.position.set(-0.92, 1.32, z > 0 ? z + 0.03 : z - 0.03);
                    car.add(mirrorSignal);
                    // Track by side for turn signal animation
                    if (z > 0) {
                        car.userData.rightBlinkers.push(mirrorSignal);
                    } else {
                        car.userData.leftBlinkers.push(mirrorSignal);
                    }
                });
                
                // --- REAR TURN SIGNALS (below taillights) ---
                [-0.72, 0.72].forEach(z => {
                    const rearTurnMat = blinkerMat.clone();
                    const rearTurn = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.06, 0.35),
                        rearTurnMat
                    );
                    rearTurn.position.set(2.1, 1.0, z * 0.85);
                    car.add(rearTurn);
                    if (z > 0) {
                        car.userData.rightBlinkers.push(rearTurn);
                    } else {
                        car.userData.leftBlinkers.push(rearTurn);
                    }
                });
                
                // --- C/D PILLAR TRIM (black) ---
                [-0.95, 0.95].forEach(z => {
                    const cdPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.45, 0.06, 0.04),
                        trimMat
                    );
                    cdPillar.rotation.z = -0.5;
                    cdPillar.position.set(1.5, 1.52, z);
                    car.add(cdPillar);
                });
                
                // --- DOOR LINES (character lines) ---
                [-0.93, 0.93].forEach(z => {
                    // Upper door line (shoulder line)
                    const shoulderLine = new THREE.Mesh(
                        new THREE.BoxGeometry(2.6, 0.025, 0.02),
                        trimMat
                    );
                    shoulderLine.position.set(0, 1.15, z);
                    car.add(shoulderLine);
                    
                    // Door handle
                    const handle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.22, 0.06, 0.04),
                        chromeMat
                    );
                    handle.position.set(-0.15, 1.25, z * 1.02);
                    car.add(handle);
                    
                    // Rear door handle
                    const handle2 = new THREE.Mesh(
                        new THREE.BoxGeometry(0.22, 0.06, 0.04),
                        chromeMat
                    );
                    handle2.position.set(0.7, 1.25, z * 1.02);
                    car.add(handle2);
                });
                
                // --- MODERN LED TAILLIGHTS (horizontal, wrapping) ---
                [-0.72, 0.72].forEach(z => {
                    // Main LED bar - use emissive material for brake effect
                    const ledBarMat = new THREE.MeshStandardMaterial({ 
                        color: 0xdd1111, 
                        emissive: 0xcc0000, 
                        emissiveIntensity: 2.0,
                        roughness: 0.3
                    });
                    const ledBar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.12, 0.55),
                        ledBarMat
                    );
                    ledBar.position.set(2.08, 1.15, z * 0.85);
                    car.add(ledBar);
                    car.userData.taillights.push(ledBar); // Track for brake effect
                    
                    // Upper LED accent - also tracks for brake effect
                    const ledAccentMat = new THREE.MeshStandardMaterial({ 
                        color: 0xff4444, 
                        emissive: 0xee2222, 
                        emissiveIntensity: 2.0,
                        roughness: 0.3
                    });
                    const ledAccent = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.04, 0.45),
                        ledAccentMat
                    );
                    ledAccent.position.set(2.09, 1.25, z * 0.85);
                    car.add(ledAccent);
                    car.userData.taillights.push(ledAccent);
                    
                    // Side wrap element
                    const sideWrap = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.15, 0.06),
                        ledMat
                    );
                    sideWrap.position.set(1.98, 1.15, z);
                    car.add(sideWrap);
                });
                
                // --- CENTER BRAKE LIGHT (on spoiler) ---
                const centerBrake = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.05, 0.6),
                    new THREE.MeshBasicMaterial({ color: 0xff2222 })
                );
                centerBrake.position.set(1.82, 1.78, 0);
                car.add(centerBrake);
                
                // --- HATCH SEAM LINE ---
                const hatchSeam = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.8, 1.7),
                    trimMat
                );
                hatchSeam.position.set(1.42, 1.45, 0);
                car.add(hatchSeam);
                
                // --- DUAL EXHAUST TIPS (sporty style) ---
                [-0.35, 0.35].forEach(z => {
                    // Chrome exhaust tip outer
                    const exhaustOuter = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.055, 0.06, 0.15, 16),
                        chromeMat
                    );
                    exhaustOuter.rotation.z = Math.PI / 2;
                    exhaustOuter.position.set(2.15, 0.35, z);
                    car.add(exhaustOuter);
                    
                    // Dark exhaust inner
                    const exhaustInner = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.04, 0.04, 0.12, 12),
                        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 })
                    );
                    exhaustInner.rotation.z = Math.PI / 2;
                    exhaustInner.position.set(2.18, 0.35, z);
                    car.add(exhaustInner);
                });
                
                // --- FRONT FENDER TURN SIGNALS ---
                [-0.96, 0.96].forEach(z => {
                    const turnSignal = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.025, 0.1),
                        blinkerMat
                    );
                    turnSignal.position.set(-1.65, 0.95, z);
                    car.add(turnSignal);
                });
                
                // --- FUEL FILLER CAP (right side) ---
                const fuelCap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.06, 0.02, 12),
                    bodyMat
                );
                fuelCap.rotation.x = Math.PI / 2;
                fuelCap.position.set(1.0, 0.85, 0.98);
                car.add(fuelCap);
                
                // Fuel cap outline
                const fuelCapRing = new THREE.Mesh(
                    new THREE.TorusGeometry(0.065, 0.008, 8, 16),
                    trimMat
                );
                fuelCapRing.rotation.x = Math.PI / 2;
                fuelCapRing.position.set(1.0, 0.85, 0.99);
                car.add(fuelCapRing);
                
                // --- WIPER COWL AREA ---
                const wiperCowl = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.04, 1.6),
                    trimMat
                );
                wiperCowl.position.set(-0.7, 1.13, 0);
                car.add(wiperCowl);
                
                // Wiper blade hints
                [-0.4, 0.3].forEach(z => {
                    const wiperArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.015, 0.02),
                        trimMat
                    );
                    wiperArm.rotation.z = -0.2;
                    wiperArm.position.set(-0.55, 1.2, z);
                    car.add(wiperArm);
                });
                
                // --- CHROME BELT LINE TRIM ---
                [-0.97, 0.97].forEach(z => {
                    const beltChrome = new THREE.Mesh(
                        new THREE.BoxGeometry(2.4, 0.02, 0.02),
                        chromeMat
                    );
                    beltChrome.position.set(0.2, 1.3, z);
                    car.add(beltChrome);
                });
                
                // --- REAR REFLECTORS ---
                [-0.85, 0.85].forEach(z => {
                    const reflector = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.06, 0.12),
                        new THREE.MeshBasicMaterial({ color: 0xff3300 })
                    );
                    reflector.position.set(2.1, 0.42, z);
                    car.add(reflector);
                });
                
                // --- UPPER GRILLE (modern honeycomb mesh style) ---
                // Grille surround frame
                const grilleSurroundGeo = new THREE.BoxGeometry(0.08, 0.22, 1.0);
                const grilleSurround = new THREE.Mesh(grilleSurroundGeo, chromeMat);
                grilleSurround.position.set(-2.14, 0.72, 0);
                car.add(grilleSurround);
                
                // Honeycomb mesh grille (dark with metallic sheen)
                const grilleMeshMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a, 
                    metalness: 0.6, 
                    roughness: 0.4 
                });
                const grilleMesh = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.18, 0.9),
                    grilleMeshMat
                );
                grilleMesh.position.set(-2.13, 0.72, 0);
                car.add(grilleMesh);
                
                // Horizontal grille accent bars
                [-0.05, 0.05].forEach(yOffset => {
                    const grilleBar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.02, 0.85),
                        chromeMat
                    );
                    grilleBar.position.set(-2.16, 0.72 + yOffset, 0);
                    car.add(grilleBar);
                });
                
                // Center brand badge area
                const grilleBadge = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.06, 0.04, 16),
                    chromeMat
                );
                grilleBadge.rotation.z = Math.PI / 2;
                grilleBadge.position.set(-2.17, 0.72, 0);
                car.add(grilleBadge);
                
                // --- LOWER GRILLE / AIR INTAKE ---
                const lowerGrille = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.18, 1.3),
                    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.8 })
                );
                lowerGrille.position.set(-2.12, 0.45, 0);
                car.add(lowerGrille);
                
                // --- FOG LIGHTS ---
                const fogMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
                [-0.65, 0.65].forEach(z => {
                    const fog = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.1, 0.15),
                        fogMat
                    );
                    fog.position.set(-2.12, 0.42, z);
                    car.add(fog);
                });
                
                // --- HIGH-QUALITY SPORTY ALLOY WHEELS (LatheGeometry + detailed brakes) ---
                const wheelRadius = 0.44;
                const tireWidth = 0.28;
                const wheelPositions = [
                    [-1.35, 0.44, 0.98], [-1.35, 0.44, -0.98],
                    [1.35, 0.44, 0.98], [1.35, 0.44, -0.98]
                ];
                
                // Brake materials
                const hbRotorMat = new THREE.MeshStandardMaterial({ 
                    color: 0x555555, 
                    metalness: 0.8, 
                    roughness: 0.3 
                });
                const hbCaliperMat = new THREE.MeshStandardMaterial({ 
                    color: 0xcc0000, 
                    metalness: 0.5, 
                    roughness: 0.4 
                });
                
                wheelPositions.forEach((pos, idx) => {
                    const wheelGroup = new THREE.Group();
                    const side = pos[2] > 0 ? 1 : -1;
                    
                    // --- TIRE using LatheGeometry for proper rounded profile ---
                    const tireProfile = [];
                    const tireInner = wheelRadius - 0.08;
                    const tireOuter = wheelRadius;
                    // Create realistic tire cross-section with sidewall bulge
                    for (let i = 0; i <= 12; i++) {
                        const t = i / 12;
                        const angle = t * Math.PI;
                        // Add slight sidewall bulge at quarters for realism
                        const bulgeFactor = Math.sin(angle) * (1 + 0.06 * Math.sin(angle * 2));
                        const r = tireInner + (tireOuter - tireInner) * bulgeFactor;
                        const y = (t - 0.5) * tireWidth;
                        tireProfile.push(new THREE.Vector2(r, y));
                    }
                    const tireGeo = new THREE.LatheGeometry(tireProfile, 32);
                    const tire = new THREE.Mesh(tireGeo, wheelMat);
                    tire.rotation.x = Math.PI / 2;
                    tire.castShadow = true;
                    wheelGroup.add(tire);
                    
                    // Tire sidewall raised lettering (performance tire detail)
                    const letteringMat = new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.7 });
                    const protectorGeo = new THREE.TorusGeometry(wheelRadius - 0.05, 0.01, 6, 32);
                    const protector = new THREE.Mesh(protectorGeo, letteringMat);
                    protector.position.z = side * (tireWidth / 2 - 0.02);
                    wheelGroup.add(protector);
                    
                    // --- RIM with polished lip and deep dish ---
                    const rimRadius = wheelRadius - 0.1;
                    
                    // Rim barrel (inner visible part)
                    const rimBarrelGeo = new THREE.CylinderGeometry(rimRadius, rimRadius - 0.02, tireWidth - 0.04, 24);
                    const rimBarrelMat = new THREE.MeshStandardMaterial({ 
                        color: 0x444444, 
                        metalness: 0.7, 
                        roughness: 0.35 
                    });
                    const rimBarrel = new THREE.Mesh(rimBarrelGeo, rimBarrelMat);
                    rimBarrel.rotation.x = Math.PI / 2;
                    wheelGroup.add(rimBarrel);
                    
                    // Polished rim lip (outer edge)
                    const rimLipGeo = new THREE.TorusGeometry(rimRadius + 0.01, 0.02, 8, 32);
                    const rimLip = new THREE.Mesh(rimLipGeo, chromeMat);
                    rimLip.position.z = side * (tireWidth / 2 - 0.04);
                    wheelGroup.add(rimLip);
                    
                    // Rim face (slightly concave for dish effect)
                    const rimFaceGeo = new THREE.CylinderGeometry(rimRadius - 0.01, rimRadius - 0.03, 0.02, 24);
                    const rimFaceMat = new THREE.MeshStandardMaterial({ 
                        color: 0x777777, 
                        metalness: 0.9, 
                        roughness: 0.15 
                    });
                    const rimFace = new THREE.Mesh(rimFaceGeo, rimFaceMat);
                    rimFace.rotation.x = Math.PI / 2;
                    rimFace.position.z = side * (tireWidth / 2 - 0.06);
                    wheelGroup.add(rimFace);
                    
                    // --- TWIN-SPOKE DESIGN (5 pairs = 10 spokes) ---
                    const spokeMat = new THREE.MeshStandardMaterial({ 
                        color: 0x666666, 
                        metalness: 0.85, 
                        roughness: 0.25 
                    });
                    
                    for (let i = 0; i < 5; i++) {
                        const spokeAngle = (i / 5) * Math.PI * 2;
                        const spokeLen = rimRadius - 0.06;
                        
                        // Main spoke (wider at base)
                        const spokeGeo = new THREE.BoxGeometry(spokeLen, 0.04, 0.025);
                        const spoke = new THREE.Mesh(spokeGeo, chromeMat);
                        spoke.position.set(
                            Math.cos(spokeAngle) * (spokeLen / 2),
                            Math.sin(spokeAngle) * (spokeLen / 2),
                            side * (tireWidth / 2 - 0.05)
                        );
                        spoke.rotation.z = spokeAngle;
                        wheelGroup.add(spoke);
                        
                        // Secondary spoke (twin design for sporty look)
                        const spoke2Geo = new THREE.BoxGeometry(spokeLen * 0.88, 0.028, 0.02);
                        const spoke2 = new THREE.Mesh(spoke2Geo, spokeMat);
                        spoke2.position.set(
                            Math.cos(spokeAngle + 0.18) * (spokeLen / 2 - 0.01),
                            Math.sin(spokeAngle + 0.18) * (spokeLen / 2 - 0.01),
                            side * (tireWidth / 2 - 0.055)
                        );
                        spoke2.rotation.z = spokeAngle + 0.18;
                        wheelGroup.add(spoke2);
                    }
                    
                    // --- CENTER HUB CAP (domed with logo detail) ---
                    const hubCapGeo = new THREE.SphereGeometry(0.055, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const hubCap = new THREE.Mesh(hubCapGeo, chromeMat);
                    hubCap.rotation.x = side > 0 ? -Math.PI / 2 : Math.PI / 2;
                    hubCap.position.z = side * (tireWidth / 2 - 0.03);
                    wheelGroup.add(hubCap);
                    
                    // Hub ring accent
                    const hubRingGeo = new THREE.TorusGeometry(0.04, 0.006, 8, 16);
                    const hubRing = new THREE.Mesh(hubRingGeo, spokeMat);
                    hubRing.position.z = side * (tireWidth / 2 - 0.025);
                    wheelGroup.add(hubRing);
                    
                    // --- LUG NUTS (5 visible) ---
                    for (let lugIdx = 0; lugIdx < 5; lugIdx++) {
                        const lugAngle = (lugIdx / 5) * Math.PI * 2 + Math.PI / 10;
                        const lugGeo = new THREE.CylinderGeometry(0.012, 0.014, 0.015, 6);
                        const lugNut = new THREE.Mesh(lugGeo, chromeMat);
                        lugNut.rotation.x = Math.PI / 2;
                        lugNut.position.set(
                            Math.cos(lugAngle) * 0.038,
                            Math.sin(lugAngle) * 0.038,
                            side * (tireWidth / 2 - 0.02)
                        );
                        wheelGroup.add(lugNut);
                    }
                    
                    // --- BRAKE ROTOR (cross-drilled performance style) ---
                    const rotorRadius = rimRadius - 0.06;
                    const rotorGeo = new THREE.CylinderGeometry(rotorRadius, rotorRadius, 0.03, 32);
                    const rotor = new THREE.Mesh(rotorGeo, hbRotorMat);
                    rotor.rotation.x = Math.PI / 2;
                    rotor.position.z = -side * 0.04;
                    wheelGroup.add(rotor);
                    
                    // Rotor hub
                    const rotorHubGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.035, 16);
                    const rotorHub = new THREE.Mesh(rotorHubGeo, hbRotorMat);
                    rotorHub.rotation.x = Math.PI / 2;
                    rotorHub.position.z = -side * 0.04;
                    wheelGroup.add(rotorHub);
                    
                    // Cross-drilled holes (2 rings for realism)
                    const holeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
                    for (let ring = 0; ring < 2; ring++) {
                        const holeRadius = rotorRadius - 0.04 - ring * 0.05;
                        const holeCount = 14 - ring * 4;
                        for (let h = 0; h < holeCount; h++) {
                            const angle = (h / holeCount) * Math.PI * 2;
                            const holeGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.035, 6);
                            const hole = new THREE.Mesh(holeGeo, holeMat);
                            hole.rotation.x = Math.PI / 2;
                            hole.position.set(
                                Math.cos(angle) * holeRadius,
                                Math.sin(angle) * holeRadius,
                                -side * 0.04
                            );
                            wheelGroup.add(hole);
                        }
                    }
                    
                    // Ventilation slots (curved for realism)
                    for (let v = 0; v < 18; v++) {
                        const angle = (v / 18) * Math.PI * 2;
                        const slotGeo = new THREE.BoxGeometry(0.05, 0.035, 0.005);
                        const slot = new THREE.Mesh(slotGeo, trimMat);
                        const slotR = rotorRadius - 0.12;
                        slot.position.set(
                            Math.cos(angle) * slotR,
                            Math.sin(angle) * slotR,
                            -side * 0.04
                        );
                        slot.rotation.z = angle + 0.25;
                        wheelGroup.add(slot);
                    }
                    
                    // --- RED BRAKE CALIPER (visible through spokes) ---
                    const caliperAngle = idx < 2 ? -0.4 : -0.3;
                    const caliperX = Math.cos(caliperAngle) * (rotorRadius - 0.04);
                    const caliperY = Math.sin(caliperAngle) * (rotorRadius - 0.04) + 0.02;
                    
                    // Caliper body
                    const caliperGeo = new THREE.BoxGeometry(0.12, 0.07, 0.055);
                    const caliper = new THREE.Mesh(caliperGeo, hbCaliperMat);
                    caliper.position.set(caliperX, caliperY, -side * 0.06);
                    caliper.rotation.z = caliperAngle + 0.1;
                    wheelGroup.add(caliper);
                    
                    // Caliper lettering detail (raised area)
                    const letterGeo = new THREE.BoxGeometry(0.08, 0.04, 0.008);
                    const letter = new THREE.Mesh(letterGeo, new THREE.MeshStandardMaterial({ 
                        color: 0xdd0000, metalness: 0.4, roughness: 0.45 
                    }));
                    letter.position.set(caliperX, caliperY, -side * 0.03);
                    letter.rotation.z = caliperAngle + 0.1;
                    wheelGroup.add(letter);
                    
                    // Caliper mounting bracket
                    const bracketGeo = new THREE.BoxGeometry(0.02, 0.1, 0.04);
                    const bracket = new THREE.Mesh(bracketGeo, trimMat);
                    bracket.position.set(
                        Math.cos(caliperAngle) * (rotorRadius - 0.1),
                        Math.sin(caliperAngle) * (rotorRadius - 0.1),
                        -side * 0.07
                    );
                    wheelGroup.add(bracket);
                    
                    // Brake line fitting
                    const fittingGeo = new THREE.CylinderGeometry(0.006, 0.008, 0.03, 6);
                    const fitting = new THREE.Mesh(fittingGeo, chromeMat);
                    fitting.position.set(caliperX + 0.05, caliperY + 0.02, -side * 0.06);
                    wheelGroup.add(fitting);
                    
                    wheelGroup.position.set(...pos);
                    wheelGroup.castShadow = true;
                    car.add(wheelGroup);
                });
                
                // Skip the common wheel section for hatchback (we have custom wheels)
                // Return early after adding remaining common details
                // Headlights (enhanced with better glow effects)
                [-0.65, 0.65].forEach(z => {
                    // Main headlight projector (glowing center)
                    const projectorMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffee, 
                        emissive: 0xffffcc, 
                        emissiveIntensity: 3.5,
                        roughness: 0.1
                    });
                    const hl = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 16, 12),
                        projectorMat
                    );
                    hl.scale.x = 0.5;
                    hl.position.set(-2.1, 0.82, z);
                    car.add(hl);
                    
                    // Secondary low beam
                    const lowBeam = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06, 12, 8),
                        headlightMat
                    );
                    lowBeam.position.set(-2.08, 0.74, z);
                    car.add(lowBeam);
                    
                    // Chrome housing surround
                    const housing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.24, 0.5),
                        chromeMat
                    );
                    housing.position.set(-2.13, 0.8, z);
                    car.add(housing);
                    
                    // DRL strip (modern LED look with emissive glow)
                    const drlMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        emissive: 0xffffff, 
                        emissiveIntensity: 3.0,
                        roughness: 0.1
                    });
                    const drl = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.04, 0.36),
                        drlMat
                    );
                    drl.position.set(-2.12, 0.68, z);
                    car.add(drl);
                });
                
                // (Side mirrors already added above with teardrop design)
                
                // (Front grille already added above with honeycomb mesh)
                
                // License plate
                const plate = new THREE.Mesh(
                    new THREE.BoxGeometry(0.03, 0.15, 0.45),
                    new THREE.MeshBasicMaterial({ color: 0xffffee })
                );
                plate.position.set(2.1, 0.65, 0);
                car.add(plate);
                
                return car;
                
            } else if (style === 'hover') {
                // ================================================================
                // FUTURISTIC HOVER VEHICLE (Tron/Blade Runner/F-Zero style)
                // Sleek sci-fi spaceship-style vehicle with no wheels
                // Glowing thrusters, LED strips, smooth aerodynamic curves
                // ================================================================
                
                // Enhanced materials for futuristic look
                const hoverBodyMat = new THREE.MeshStandardMaterial({ 
                    color: color, 
                    metalness: 0.85, 
                    roughness: 0.15,
                    envMapIntensity: 1.2
                });
                
                // Glowing accent color based on body color (complementary glow)
                const glowHue = (color === 0xffffff) ? 0x00ffff : 
                               (color === 0x222222) ? 0xff00ff :
                               (color === 0xff0000) ? 0xff6600 :
                               (color === 0x0066ff) ? 0x00ccff :
                               (color === 0x00cc44) ? 0x00ff88 :
                               0x00ffff;
                
                const glowMat = new THREE.MeshStandardMaterial({ 
                    color: glowHue, 
                    emissive: glowHue, 
                    emissiveIntensity: 2.5,
                    roughness: 0.2
                });
                
                const glowMatBright = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff, 
                    emissive: glowHue, 
                    emissiveIntensity: 4.0,
                    roughness: 0.1
                });
                
                const darkTrimMat = new THREE.MeshStandardMaterial({ 
                    color: 0x111122, 
                    metalness: 0.9, 
                    roughness: 0.2 
                });
                
                const canopyMat = new THREE.MeshStandardMaterial({ 
                    color: 0x112244, 
                    metalness: 0.95, 
                    roughness: 0.05,
                    transparent: true,
                    opacity: 0.75
                });
                
                // === MAIN BODY - Sleek wedge/teardrop shape ===
                const bodyShape = new THREE.Shape();
                
                // Aerodynamic side profile - low and aggressive
                bodyShape.moveTo(-2.6, 0.25);  // Front nose (low)
                bodyShape.quadraticCurveTo(-2.8, 0.35, -2.7, 0.45); // Nose curve up
                bodyShape.lineTo(-2.2, 0.5);   // Hood line
                bodyShape.quadraticCurveTo(-1.5, 0.65, -0.8, 0.95); // Rising to canopy
                bodyShape.quadraticCurveTo(-0.3, 1.2, 0.3, 1.25);   // Canopy peak
                bodyShape.quadraticCurveTo(0.9, 1.15, 1.5, 0.85);   // Rear slope
                bodyShape.quadraticCurveTo(2.0, 0.6, 2.3, 0.4);     // Tail section
                bodyShape.quadraticCurveTo(2.5, 0.3, 2.4, 0.25);    // Rear end
                bodyShape.lineTo(-2.6, 0.25);  // Bottom line (flat hover surface)
                
                const bodyExtrudeSettings = {
                    steps: 1,
                    depth: 1.8,
                    bevelEnabled: true,
                    bevelThickness: 0.12,
                    bevelSize: 0.1,
                    bevelSegments: 4
                };
                
                const bodyGeo = new THREE.ExtrudeGeometry(bodyShape, bodyExtrudeSettings);
                bodyGeo.center();
                const mainBody = new THREE.Mesh(bodyGeo, hoverBodyMat);
                mainBody.rotation.y = Math.PI / 2;
                mainBody.position.set(0, 0.5, 0);
                mainBody.castShadow = true;
                car.add(mainBody);
                
                // === COCKPIT CANOPY - Smooth bubble canopy ===
                const canopyShape = new THREE.Shape();
                canopyShape.moveTo(-0.7, 0.95);
                canopyShape.quadraticCurveTo(-0.3, 1.35, 0.3, 1.4);
                canopyShape.quadraticCurveTo(0.8, 1.35, 1.1, 1.0);
                canopyShape.lineTo(1.1, 0.95);
                canopyShape.lineTo(-0.7, 0.95);
                
                const canopyExtrudeSettings = {
                    steps: 1,
                    depth: 1.2,
                    bevelEnabled: true,
                    bevelThickness: 0.08,
                    bevelSize: 0.06,
                    bevelSegments: 3
                };
                
                const canopyGeo = new THREE.ExtrudeGeometry(canopyShape, canopyExtrudeSettings);
                canopyGeo.center();
                const canopy = new THREE.Mesh(canopyGeo, canopyMat);
                canopy.rotation.y = Math.PI / 2;
                canopy.position.set(0.2, 0.55, 0);
                car.add(canopy);
                
                // === CANOPY FRAME - Sleek black trim ===
                [-0.58, 0.58].forEach(z => {
                    const frameCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(-0.6, 0.95, z),
                        new THREE.Vector3(-0.2, 1.25, z),
                        new THREE.Vector3(0.4, 1.28, z),
                        new THREE.Vector3(0.9, 1.0, z)
                    ]);
                    const frameGeo = new THREE.TubeGeometry(frameCurve, 12, 0.025, 6, false);
                    const frame = new THREE.Mesh(frameGeo, darkTrimMat);
                    car.add(frame);
                });
                
                // === SIDE FINS / AERO WINGS ===
                [-0.95, 0.95].forEach(z => {
                    // Main side fin (swept back)
                    const finShape = new THREE.Shape();
                    finShape.moveTo(-0.5, 0);
                    finShape.lineTo(1.8, 0);
                    finShape.lineTo(2.2, 0.35);
                    finShape.lineTo(1.4, 0.4);
                    finShape.lineTo(-0.2, 0.25);
                    finShape.lineTo(-0.5, 0);
                    
                    const finExtrudeSettings = {
                        steps: 1,
                        depth: 0.08,
                        bevelEnabled: true,
                        bevelThickness: 0.02,
                        bevelSize: 0.02,
                        bevelSegments: 2
                    };
                    
                    const finGeo = new THREE.ExtrudeGeometry(finShape, finExtrudeSettings);
                    const fin = new THREE.Mesh(finGeo, hoverBodyMat);
                    fin.position.set(0, 0.55, z > 0 ? z + 0.04 : z - 0.12);
                    fin.castShadow = true;
                    car.add(fin);
                    
                    // LED accent strip on fin edge
                    const finLedCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(-0.4, 0.58, z > 0 ? z + 0.12 : z - 0.12),
                        new THREE.Vector3(0.8, 0.7, z > 0 ? z + 0.13 : z - 0.13),
                        new THREE.Vector3(1.8, 0.6, z > 0 ? z + 0.12 : z - 0.12)
                    ]);
                    const finLedGeo = new THREE.TubeGeometry(finLedCurve, 10, 0.018, 6, false);
                    const finLed = new THREE.Mesh(finLedGeo, glowMat);
                    car.add(finLed);
                });
                
                // === HOVER PADS (replacing wheels) - Glowing anti-grav emitters ===
                const hoverPadPositions = [
                    [-1.6, 0.18, 0.7],   // Front right
                    [-1.6, 0.18, -0.7],  // Front left
                    [1.4, 0.18, 0.7],    // Rear right
                    [1.4, 0.18, -0.7]    // Rear left
                ];
                
                hoverPadPositions.forEach(([px, py, pz]) => {
                    // Hover pad housing (dark disc)
                    const padHousing = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.38, 0.12, 16),
                        darkTrimMat
                    );
                    padHousing.position.set(px, py, pz);
                    car.add(padHousing);
                    
                    // Inner glow ring (main thruster)
                    const glowRing = new THREE.Mesh(
                        new THREE.TorusGeometry(0.25, 0.04, 8, 24),
                        glowMat
                    );
                    glowRing.rotation.x = Math.PI / 2;
                    glowRing.position.set(px, py - 0.02, pz);
                    car.add(glowRing);
                    
                    // Center glow core
                    const glowCore = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.15, 0.06, 12),
                        glowMatBright
                    );
                    glowCore.position.set(px, py - 0.04, pz);
                    car.add(glowCore);
                    
                    // Outer ring accent
                    const outerRing = new THREE.Mesh(
                        new THREE.TorusGeometry(0.36, 0.02, 6, 24),
                        glowMat
                    );
                    outerRing.rotation.x = Math.PI / 2;
                    outerRing.position.set(px, py + 0.04, pz);
                    car.add(outerRing);
                });
                
                // === FRONT NOSE - Aggressive LED array ===
                // Front LED bar (headlight replacement)
                const frontLedBar = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.06, 1.4),
                    glowMatBright
                );
                frontLedBar.position.set(-2.5, 0.55, 0);
                car.add(frontLedBar);
                
                // Front accent strips (triangular pattern)
                [-0.5, 0.5].forEach(z => {
                    const accentStrip = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.025, 0.08),
                        glowMat
                    );
                    accentStrip.position.set(-2.3, 0.5, z);
                    car.add(accentStrip);
                });
                
                // Nose tip glow
                const noseTip = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 6),
                    glowMat
                );
                noseTip.position.set(-2.65, 0.45, 0);
                car.add(noseTip);
                
                // === REAR THRUSTERS - Main propulsion ===
                [-0.55, 0, 0.55].forEach(z => {
                    // Thruster housing
                    const thrusterHousing = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.18, 0.22, 0.25, 12),
                        darkTrimMat
                    );
                    thrusterHousing.rotation.z = Math.PI / 2;
                    thrusterHousing.position.set(2.35, 0.45, z);
                    car.add(thrusterHousing);
                    
                    // Thruster glow (exhaust)
                    const thrusterGlow = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.08, 0.15, 10),
                        glowMatBright
                    );
                    thrusterGlow.rotation.z = Math.PI / 2;
                    thrusterGlow.position.set(2.48, 0.45, z);
                    car.add(thrusterGlow);
                    car.userData.taillights.push(thrusterGlow); // Track for brake effect
                    
                    // Thruster inner ring
                    const thrusterRing = new THREE.Mesh(
                        new THREE.TorusGeometry(0.14, 0.025, 6, 16),
                        glowMat
                    );
                    thrusterRing.rotation.y = Math.PI / 2;
                    thrusterRing.position.set(2.4, 0.45, z);
                    car.add(thrusterRing);
                });
                
                // === SIDE LED STRIPS - Running lights ===
                [-0.88, 0.88].forEach(z => {
                    // Main side LED strip (runs along body)
                    const sideLedCurve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(-2.2, 0.42, z),
                        new THREE.Vector3(-1.0, 0.48, z),
                        new THREE.Vector3(0.5, 0.55, z),
                        new THREE.Vector3(1.8, 0.48, z)
                    ]);
                    const sideLedGeo = new THREE.TubeGeometry(sideLedCurve, 16, 0.02, 6, false);
                    const sideLed = new THREE.Mesh(sideLedGeo, glowMat);
                    car.add(sideLed);
                    
                    // Secondary accent strip (lower)
                    const lowerLed = new THREE.Mesh(
                        new THREE.BoxGeometry(3.0, 0.015, 0.025),
                        glowMat
                    );
                    lowerLed.position.set(-0.2, 0.28, z);
                    car.add(lowerLed);
                });
                
                // === ROOF ACCENT - Dorsal fin/antenna ===
                const dorsalFinShape = new THREE.Shape();
                dorsalFinShape.moveTo(0, 0);
                dorsalFinShape.lineTo(0.8, 0);
                dorsalFinShape.lineTo(0.6, 0.25);
                dorsalFinShape.lineTo(0.1, 0.3);
                dorsalFinShape.lineTo(0, 0);
                
                const dorsalExtrudeSettings = {
                    steps: 1,
                    depth: 0.04,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.01,
                    bevelSegments: 1
                };
                
                const dorsalGeo = new THREE.ExtrudeGeometry(dorsalFinShape, dorsalExtrudeSettings);
                const dorsalFin = new THREE.Mesh(dorsalGeo, darkTrimMat);
                dorsalFin.rotation.y = Math.PI / 2;
                dorsalFin.position.set(0.6, 1.28, -0.02);
                car.add(dorsalFin);
                
                // Dorsal LED accent
                const dorsalLed = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.02, 0.015),
                    glowMat
                );
                dorsalLed.position.set(0.5, 1.35, 0);
                car.add(dorsalLed);
                
                // === UNDERSIDE GLOW - Hover effect ===
                const underGlow = new THREE.Mesh(
                    new THREE.BoxGeometry(3.5, 0.02, 1.2),
                    new THREE.MeshStandardMaterial({ 
                        color: glowHue, 
                        emissive: glowHue, 
                        emissiveIntensity: 1.5,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                underGlow.position.set(-0.1, 0.12, 0);
                car.add(underGlow);
                
                // === INTAKE VENTS - Cooling/power ===
                [-0.6, 0.6].forEach(z => {
                    // Vent housing
                    const ventHousing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.12, 0.25),
                        darkTrimMat
                    );
                    ventHousing.position.set(-1.8, 0.72, z);
                    car.add(ventHousing);
                    
                    // Vent glow (internal)
                    const ventGlow = new THREE.Mesh(
                        new THREE.BoxGeometry(0.35, 0.08, 0.2),
                        new THREE.MeshStandardMaterial({ 
                            color: glowHue, 
                            emissive: glowHue, 
                            emissiveIntensity: 1.0 
                        })
                    );
                    ventGlow.position.set(-1.82, 0.72, z);
                    car.add(ventGlow);
                });
                
                // === REAR SPOILER - Integrated aero ===
                const spoilerShape = new THREE.Shape();
                spoilerShape.moveTo(-0.7, 0);
                spoilerShape.lineTo(0.7, 0);
                spoilerShape.lineTo(0.65, 0.08);
                spoilerShape.lineTo(-0.65, 0.08);
                spoilerShape.lineTo(-0.7, 0);
                
                const spoilerExtrudeSettings = {
                    steps: 1,
                    depth: 0.15,
                    bevelEnabled: false
                };
                
                const spoilerGeo = new THREE.ExtrudeGeometry(spoilerShape, spoilerExtrudeSettings);
                const spoiler = new THREE.Mesh(spoilerGeo, hoverBodyMat);
                spoiler.rotation.x = -Math.PI / 2;
                spoiler.rotation.z = Math.PI / 2;
                spoiler.position.set(1.95, 0.92, -0.075);
                car.add(spoiler);
                
                // Spoiler end plates with glow
                [-0.72, 0.72].forEach(z => {
                    const endPlate = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 0.15, 0.03),
                        darkTrimMat
                    );
                    endPlate.position.set(1.95, 0.9, z);
                    car.add(endPlate);
                    
                    // End plate LED
                    const endLed = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2, 0.025, 0.01),
                        glowMat
                    );
                    endLed.position.set(1.95, 0.82, z > 0 ? z + 0.02 : z - 0.02);
                    car.add(endLed);
                });
                
                // Mark as having custom wheels (hover pads instead)
                car.userData.hasCustomWheels = true;
                car.userData.isHoverVehicle = true;
                
                // Skip common details - hover vehicles are complete
                return car;
                
            } else { // pickup
                // ===== HIGH-QUALITY LOW-POLY PICKUP TRUCK (F-150/Silverado/RAM style) =====
                // Muscular American full-size pickup with smooth curved surfaces
                
                // Material additions for pickup
                const bedLinerMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.95 });
                const grilleMeshMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.3 });
                const brakeMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6 });
                
                // === CAB - Smooth extruded shape with curved roof ===
                const cabShape = new THREE.Shape();
                // Side profile of cab (looking from side)
                cabShape.moveTo(0, 0);                          // Bottom front
                cabShape.lineTo(0, 0.85);                       // A-pillar base
                cabShape.bezierCurveTo(0, 1.3, 0.3, 1.65, 0.5, 1.7);  // Curved A-pillar to roof
                cabShape.lineTo(1.8, 1.7);                      // Roof line
                cabShape.bezierCurveTo(2.0, 1.7, 2.2, 1.55, 2.2, 1.35); // Curved rear pillar
                cabShape.lineTo(2.2, 0);                        // Cab back
                cabShape.lineTo(0, 0);                          // Close
                
                const cabExtrudeSettings = {
                    steps: 1,
                    depth: 2.15,
                    bevelEnabled: true,
                    bevelThickness: 0.12,
                    bevelSize: 0.12,
                    bevelSegments: 4
                };
                
                const cabGeo = new THREE.ExtrudeGeometry(cabShape, cabExtrudeSettings);
                const cabMesh = new THREE.Mesh(cabGeo, bodyMat);
                cabMesh.position.set(-2.2, 0.65, -1.075);
                cabMesh.castShadow = true;
                car.add(cabMesh);
                
                // === HOOD - Muscular sculpted shape ===
                const hoodShape = new THREE.Shape();
                hoodShape.moveTo(0, 0);
                hoodShape.lineTo(1.4, 0);
                hoodShape.bezierCurveTo(1.5, 0, 1.55, 0.15, 1.55, 0.25);  // Front curve
                hoodShape.lineTo(1.55, 0.55);
                hoodShape.bezierCurveTo(1.55, 0.65, 1.45, 0.72, 1.35, 0.72); // Top curve
                hoodShape.lineTo(0, 0.72);
                hoodShape.lineTo(0, 0);
                
                const hoodExtrudeSettings = {
                    steps: 1,
                    depth: 2.0,
                    bevelEnabled: true,
                    bevelThickness: 0.08,
                    bevelSize: 0.08,
                    bevelSegments: 3
                };
                
                const hoodGeo = new THREE.ExtrudeGeometry(hoodShape, hoodExtrudeSettings);
                const hoodMesh = new THREE.Mesh(hoodGeo, bodyMat);
                hoodMesh.position.set(-3.7, 0.65, -1.0);
                hoodMesh.castShadow = true;
                car.add(hoodMesh);
                
                // Hood power bulge (center raised portion)
                const bulgeShape = new THREE.Shape();
                bulgeShape.moveTo(0, 0);
                bulgeShape.bezierCurveTo(0.2, 0.15, 0.8, 0.15, 1.0, 0);
                bulgeShape.lineTo(0, 0);
                
                const bulgeGeo = new THREE.ExtrudeGeometry(bulgeShape, { 
                    steps: 1, depth: 0.6, bevelEnabled: true, bevelThickness: 0.04, bevelSize: 0.04, bevelSegments: 2 
                });
                const bulgeMesh = new THREE.Mesh(bulgeGeo, bodyMat);
                bulgeMesh.position.set(-3.3, 1.35, -0.3);
                bulgeMesh.castShadow = true;
                car.add(bulgeMesh);
                
                // === TRUCK BED - Separate from cab ===
                const bedLength = 2.0;
                const bedHeight = 0.7;
                
                // Bed floor
                const bedFloor = new THREE.Mesh(
                    new THREE.BoxGeometry(bedLength, 0.12, 1.95),
                    bedLinerMat
                );
                bedFloor.position.set(1.1, 0.95, 0);
                car.add(bedFloor);
                
                // Bed side walls (with muscular flare)
                const bedSideShape = new THREE.Shape();
                bedSideShape.moveTo(0, 0);
                bedSideShape.lineTo(bedLength, 0);
                bedSideShape.lineTo(bedLength, bedHeight);
                bedSideShape.bezierCurveTo(bedLength * 0.7, bedHeight + 0.05, bedLength * 0.3, bedHeight + 0.05, 0, bedHeight);
                bedSideShape.lineTo(0, 0);
                
                const bedSideGeo = new THREE.ExtrudeGeometry(bedSideShape, { 
                    steps: 1, depth: 0.12, bevelEnabled: true, bevelThickness: 0.03, bevelSize: 0.03, bevelSegments: 2 
                });
                
                [-1.02, 0.90].forEach((z, idx) => {
                    const bedSide = new THREE.Mesh(bedSideGeo, bodyMat);
                    bedSide.position.set(0.1, 0.95, z);
                    if (idx === 0) bedSide.scale.z = -1;
                    bedSide.castShadow = true;
                    car.add(bedSide);
                });
                
                // Bed rails (chrome trim along top edge)
                [-1.05, 1.05].forEach(z => {
                    const rail = new THREE.Mesh(
                        new THREE.BoxGeometry(bedLength + 0.1, 0.06, 0.08),
                        chromeMat
                    );
                    rail.position.set(1.1, 1.68, z);
                    car.add(rail);
                });
                
                // Stake hole accents
                [-0.95, 0.95].forEach(z => {
                    [0.5, 1.1, 1.7].forEach(x => {
                        const stake = new THREE.Mesh(
                            new THREE.BoxGeometry(0.12, 0.08, 0.06),
                            chromeMat
                        );
                        stake.position.set(x, 1.65, z);
                        car.add(stake);
                    });
                });
                
                // === TAILGATE - Integrated taillights ===
                const tailgateShape = new THREE.Shape();
                tailgateShape.moveTo(-0.9, 0);
                tailgateShape.lineTo(0.9, 0);
                tailgateShape.bezierCurveTo(0.95, 0, 0.97, 0.05, 0.97, 0.1);
                tailgateShape.lineTo(0.97, bedHeight - 0.1);
                tailgateShape.bezierCurveTo(0.97, bedHeight - 0.02, 0.92, bedHeight, 0.85, bedHeight);
                tailgateShape.lineTo(-0.85, bedHeight);
                tailgateShape.bezierCurveTo(-0.92, bedHeight, -0.97, bedHeight - 0.02, -0.97, bedHeight - 0.1);
                tailgateShape.lineTo(-0.97, 0.1);
                tailgateShape.bezierCurveTo(-0.97, 0.05, -0.95, 0, -0.9, 0);
                
                const tailgateGeo = new THREE.ExtrudeGeometry(tailgateShape, {
                    steps: 1, depth: 0.1, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02, bevelSegments: 2
                });
                const tailgateMesh = new THREE.Mesh(tailgateGeo, bodyMat);
                tailgateMesh.rotation.y = Math.PI / 2;
                tailgateMesh.position.set(2.15, 0.98, 0);
                tailgateMesh.castShadow = true;
                car.add(tailgateMesh);
                
                // Tailgate handle/badge area
                const tgHandle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.08, 0.35),
                    chromeMat
                );
                tgHandle.position.set(2.22, 1.35, 0);
                car.add(tgHandle);
                
                // Integrated taillights in tailgate corners
                [-0.75, 0.75].forEach(z => {
                    // Main taillight housing
                    const tlHousing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.5, 0.35),
                        trimMat
                    );
                    tlHousing.position.set(2.2, 1.3, z);
                    car.add(tlHousing);
                    
                    // Red brake light - clone material for independent control
                    const brakeLightMat = taillightMat.clone();
                    const brakeLight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.35, 0.28),
                        brakeLightMat
                    );
                    brakeLight.position.set(2.24, 1.35, z);
                    car.add(brakeLight);
                    car.userData.taillights.push(brakeLight); // Track for brake effect
                    
                    // Amber turn signal (bottom) - clone for independent flash control
                    const turnSignalMat = blinkerMat.clone();
                    const turnSignal = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.1, 0.28),
                        turnSignalMat
                    );
                    turnSignal.position.set(2.24, 1.05, z);
                    car.add(turnSignal);
                    // Track by side: z > 0 = right, z < 0 = left
                    if (z > 0) {
                        car.userData.rightBlinkers.push(turnSignal);
                    } else {
                        car.userData.leftBlinkers.push(turnSignal);
                    }
                });
                
                // Reverse lights (white, center)
                [-0.25, 0.25].forEach(z => {
                    const reverseLight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.12, 0.18),
                        new THREE.MeshBasicMaterial({ color: 0xffffff })
                    );
                    reverseLight.position.set(2.24, 1.55, z);
                    car.add(reverseLight);
                });
                
                // === LOWER BODY / FRAME ===
                const frameSideShape = new THREE.Shape();
                frameSideShape.moveTo(-2.4, 0);
                frameSideShape.lineTo(2.2, 0);
                frameSideShape.lineTo(2.2, 0.45);
                frameSideShape.bezierCurveTo(2.0, 0.5, 1.8, 0.55, 1.5, 0.55);
                frameSideShape.lineTo(-1.5, 0.55);
                frameSideShape.bezierCurveTo(-1.8, 0.55, -2.2, 0.5, -2.4, 0.4);
                frameSideShape.lineTo(-2.4, 0);
                
                const frameGeo = new THREE.ExtrudeGeometry(frameSideShape, {
                    steps: 1, depth: 1.9, bevelEnabled: false
                });
                const frameMesh = new THREE.Mesh(frameGeo, trimMat);
                frameMesh.position.set(0, 0.25, -0.95);
                car.add(frameMesh);
                
                // === STEP BARS / RUNNING BOARDS ===
                [-1.1, 1.1].forEach(z => {
                    // Main step bar
                    const stepBar = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.08, 0.25),
                        chromeMat
                    );
                    stepBar.position.set(-0.6, 0.45, z);
                    car.add(stepBar);
                    
                    // Step surface (textured grip)
                    const stepSurface = new THREE.Mesh(
                        new THREE.BoxGeometry(1.6, 0.04, 0.2),
                        bedLinerMat
                    );
                    stepSurface.position.set(-0.6, 0.5, z);
                    car.add(stepSurface);
                    
                    // Step bar mounting brackets
                    [-1.2, 0, 0.4].forEach(x => {
                        const bracket = new THREE.Mesh(
                            new THREE.BoxGeometry(0.12, 0.15, 0.1),
                            trimMat
                        );
                        bracket.position.set(x, 0.38, z * 0.92);
                        car.add(bracket);
                    });
                });
                
                // === FRONT GRILLE - Large aggressive design ===
                // Grille surround
                const grilleSurround = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.65, 1.7),
                    chromeMat
                );
                grilleSurround.position.set(-3.65, 1.0, 0);
                car.add(grilleSurround);
                
                // Grille mesh (dark honeycomb look)
                const grilleMesh2 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.55, 1.5),
                    grilleMeshMat
                );
                grilleMesh2.position.set(-3.7, 1.0, 0);
                car.add(grilleMesh2);
                
                // Horizontal grille bars
                for (let i = 0; i < 4; i++) {
                    const bar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.04, 1.45),
                        chromeMat
                    );
                    bar.position.set(-3.68, 0.78 + i * 0.14, 0);
                    car.add(bar);
                }
                
                // Brand badge area (center)
                const badge = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.2, 0.35),
                    chromeMat
                );
                badge.position.set(-3.72, 1.0, 0);
                car.add(badge);
                
                // === HEADLIGHTS - Modern LED-style (enhanced with glow) ===
                [-0.78, 0.78].forEach(z => {
                    // Headlight housing (dark background)
                    const hlHousing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.35, 0.38, 0.42),
                        trimMat
                    );
                    hlHousing.position.set(-3.52, 1.0, z);
                    car.add(hlHousing);
                    
                    // Main projector lens (glowing center)
                    const projectorMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffee, 
                        emissive: 0xffffcc, 
                        emissiveIntensity: 4.0,
                        metalness: 0.8, 
                        roughness: 0.05 
                    });
                    const projector = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.13, 0.11, 0.16, 20),
                        projectorMat
                    );
                    projector.rotation.z = Math.PI / 2;
                    projector.position.set(-3.68, 1.05, z);
                    car.add(projector);
                    
                    // Secondary low beam
                    const lowBeam = new THREE.Mesh(
                        new THREE.SphereGeometry(0.06, 12, 8),
                        headlightMat
                    );
                    lowBeam.position.set(-3.65, 0.95, z);
                    car.add(lowBeam);
                    
                    // LED strip (DRL - brighter)
                    const drlMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        emissive: 0xffffff, 
                        emissiveIntensity: 3.5,
                        roughness: 0.1
                    });
                    const drl = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.07, 0.32),
                        drlMat
                    );
                    drl.position.set(-3.68, 0.86, z);
                    car.add(drl);
                    
                    // Chrome bezel surround
                    const bezel = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.42, 0.46),
                        chromeMat
                    );
                    bezel.position.set(-3.7, 1.0, z);
                    car.add(bezel);
                });
                
                // Fog lights (lower bumper - with glow)
                [-0.55, 0.55].forEach(z => {
                    const fogHousing = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.11, 0.11, 0.1, 14),
                        chromeMat
                    );
                    fogHousing.rotation.z = Math.PI / 2;
                    fogHousing.position.set(-3.7, 0.55, z);
                    car.add(fogHousing);
                    
                    // Fog lens with emissive glow
                    const fogLensMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffcc, 
                        emissive: 0xffffaa, 
                        emissiveIntensity: 2.5,
                        roughness: 0.15
                    });
                    const fogLens = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.08, 0.05, 14),
                        fogLensMat
                    );
                    fogLens.rotation.z = Math.PI / 2;
                    fogLens.position.set(-3.72, 0.55, z);
                    car.add(fogLens);
                });
                
                // === FRONT BUMPER ===
                const bumperShape = new THREE.Shape();
                bumperShape.moveTo(-1.0, 0);
                bumperShape.lineTo(1.0, 0);
                bumperShape.bezierCurveTo(1.05, 0, 1.08, 0.05, 1.08, 0.12);
                bumperShape.lineTo(1.08, 0.28);
                bumperShape.bezierCurveTo(1.08, 0.32, 1.02, 0.35, 0.95, 0.35);
                bumperShape.lineTo(-0.95, 0.35);
                bumperShape.bezierCurveTo(-1.02, 0.35, -1.08, 0.32, -1.08, 0.28);
                bumperShape.lineTo(-1.08, 0.12);
                bumperShape.bezierCurveTo(-1.08, 0.05, -1.05, 0, -1.0, 0);
                
                const bumperGeo = new THREE.ExtrudeGeometry(bumperShape, {
                    steps: 1, depth: 0.25, bevelEnabled: true, bevelThickness: 0.03, bevelSize: 0.03, bevelSegments: 2
                });
                const frontBumper = new THREE.Mesh(bumperGeo, trimMat);
                frontBumper.rotation.x = -Math.PI / 2;
                frontBumper.rotation.z = Math.PI / 2;
                frontBumper.position.set(-3.8, 0.35, 1.0);
                car.add(frontBumper);
                
                // === CAB WINDOWS ===
                // Windshield (curved, angled)
                const windshieldShape = new THREE.Shape();
                windshieldShape.moveTo(-0.85, 0);
                windshieldShape.lineTo(0.85, 0);
                windshieldShape.bezierCurveTo(0.9, 0, 0.92, 0.05, 0.92, 0.12);
                windshieldShape.lineTo(0.85, 0.85);
                windshieldShape.bezierCurveTo(0.8, 0.88, 0.75, 0.9, 0.7, 0.9);
                windshieldShape.lineTo(-0.7, 0.9);
                windshieldShape.bezierCurveTo(-0.75, 0.9, -0.8, 0.88, -0.85, 0.85);
                windshieldShape.lineTo(-0.92, 0.12);
                windshieldShape.bezierCurveTo(-0.92, 0.05, -0.9, 0, -0.85, 0);
                
                const windshieldGeo = new THREE.ExtrudeGeometry(windshieldShape, {
                    steps: 1, depth: 0.06, bevelEnabled: false
                });
                const windshieldMesh = new THREE.Mesh(windshieldGeo, glassMat);
                windshieldMesh.rotation.x = -0.42;
                windshieldMesh.position.set(-2.15, 1.35, 0);
                car.add(windshieldMesh);
                
                // Side windows
                [-1.0, 1.0].forEach(z => {
                    const sideWindow = new THREE.Mesh(
                        new THREE.BoxGeometry(1.4, 0.65, 0.04),
                        glassMat
                    );
                    sideWindow.position.set(-1.1, 1.75, z);
                    car.add(sideWindow);
                    
                    // Small rear cab window
                    const rearCabWin = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.5, 0.04),
                        glassMat
                    );
                    rearCabWin.position.set(-0.15, 1.7, z);
                    car.add(rearCabWin);
                });
                
                // Rear cab window
                const rearWindow = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.6, 1.7),
                    glassMat
                );
                rearWindow.position.set(0.02, 1.7, 0);
                car.add(rearWindow);
                
                // === SIDE MIRRORS (Large towing mirrors with teardrop housing) ===
                [-1.25, 1.25].forEach(z => {
                    const side = z > 0 ? 1 : -1;
                    
                    // Mirror arm/stalk (extends from A-pillar)
                    const armGeo = new THREE.BoxGeometry(0.12, 0.05, 0.2);
                    const arm = new THREE.Mesh(armGeo, trimMat);
                    arm.position.set(-1.68, 1.88, z);
                    car.add(arm);
                    
                    // Secondary arm support (for large towing mirror stability)
                    const arm2 = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.08, 0.12),
                        trimMat
                    );
                    arm2.position.set(-1.68, 1.82, z + side * 0.12);
                    car.add(arm2);
                    
                    // Mirror housing (teardrop shape using extruded bezier)
                    const mirrorShape = new THREE.Shape();
                    mirrorShape.moveTo(0, 0);
                    mirrorShape.quadraticCurveTo(-0.08, 0.12, 0, 0.2);
                    mirrorShape.quadraticCurveTo(0.12, 0.12, 0, 0);
                    
                    const mirrorGeo = new THREE.ExtrudeGeometry(mirrorShape, {
                        steps: 1, depth: 0.08, bevelEnabled: true,
                        bevelThickness: 0.02, bevelSize: 0.02, bevelSegments: 3
                    });
                    const mirrorHousing = new THREE.Mesh(mirrorGeo, bodyMat);
                    mirrorHousing.rotation.x = Math.PI / 2;
                    mirrorHousing.position.set(-1.72, 1.72, z + side * 0.16);
                    mirrorHousing.scale.set(1.3, 1.3, 1.3);  // Larger for truck
                    car.add(mirrorHousing);
                    
                    // Mirror glass (reflective surface)
                    const glassGeo = new THREE.PlaneGeometry(0.15, 0.22);
                    const glassMirror = new THREE.Mesh(glassGeo, new THREE.MeshStandardMaterial({ 
                        color: 0x223344, 
                        metalness: 0.95, 
                        roughness: 0.05 
                    }));
                    glassMirror.rotation.y = side > 0 ? Math.PI / 2 : -Math.PI / 2;
                    glassMirror.position.set(-1.7, 1.82, z + side * 0.28);
                    car.add(glassMirror);
                    
                    // Turn signal on mirror (LED strip style)
                    const mirrorSignal = new THREE.Mesh(
                        new THREE.BoxGeometry(0.12, 0.025, 0.08),
                        blinkerMat
                    );
                    mirrorSignal.position.set(-1.72, 1.68, z + side * 0.2);
                    car.add(mirrorSignal);
                    
                    // Puddle light (under mirror - modern truck feature)
                    const puddleLight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.015, 0.06),
                        new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
                    );
                    puddleLight.position.set(-1.7, 1.64, z + side * 0.18);
                    car.add(puddleLight);
                });
                
                // === DOOR HANDLES ===
                [-1.0, 1.0].forEach(z => {
                    const handle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.18, 0.06, 0.06),
                        chromeMat
                    );
                    handle.position.set(-1.0, 1.4, z * 0.92);
                    car.add(handle);
                });
                
                // === WHEEL ARCHES / FENDER FLARES ===
                // Front wheel arches
                [-1.15, 1.15].forEach(z => {
                    const archShape = new THREE.Shape();
                    archShape.absarc(0, 0, 0.65, 0, Math.PI, false);
                    
                    const archGeo = new THREE.ExtrudeGeometry(archShape, {
                        steps: 1, depth: 0.15, bevelEnabled: true, bevelThickness: 0.04, bevelSize: 0.04, bevelSegments: 2
                    });
                    const arch = new THREE.Mesh(archGeo, bodyMat);
                    arch.rotation.y = Math.PI / 2;
                    arch.position.set(-2.5, 0.55, z > 0 ? z - 0.075 : z + 0.075);
                    if (z < 0) arch.scale.z = -1;
                    arch.castShadow = true;
                    car.add(arch);
                });
                
                // Rear wheel arches (larger for dual/single rear wheels)
                [-1.15, 1.15].forEach(z => {
                    const archShape = new THREE.Shape();
                    archShape.absarc(0, 0, 0.7, 0, Math.PI, false);
                    
                    const archGeo = new THREE.ExtrudeGeometry(archShape, {
                        steps: 1, depth: 0.18, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 2
                    });
                    const arch = new THREE.Mesh(archGeo, bodyMat);
                    arch.rotation.y = Math.PI / 2;
                    arch.position.set(1.4, 0.55, z > 0 ? z - 0.09 : z + 0.09);
                    if (z < 0) arch.scale.z = -1;
                    arch.castShadow = true;
                    car.add(arch);
                });
                
                // === HIGH-QUALITY OFF-ROAD WHEELS (LatheGeometry + detailed brakes) ===
                const wheelRadius = 0.55;  // Bigger wheels for truck stance
                const tireWidth = 0.38;
                
                // Enhanced materials for premium truck wheels
                const tireMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.88 });
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.92, roughness: 0.18 });
                const pkRotorMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.3 });
                const pkCaliperMat = new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.5, roughness: 0.4 });
                const letteringMat = new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.7 });
                
                const pickupWheelY = 0.55;
                const frontWheelX = -2.5;
                const rearWheelX = 1.4;
                const wheelZOuter = 1.15;
                const wheelZInner = -1.15;
                
                // Create wheel assembly function with LatheGeometry tires
                function createWheelAssembly(x, z, isFront) {
                    const side = z > 0 ? 1 : -1;
                    
                    // --- TIRE using LatheGeometry for proper rounded sidewall profile ---
                    const tireProfile = [];
                    const tireInner = wheelRadius - 0.1;
                    const tireOuter = wheelRadius;
                    // Create realistic off-road tire cross-section with aggressive sidewall bulge
                    for (let i = 0; i <= 14; i++) {
                        const t = i / 14;
                        const angle = t * Math.PI;
                        // Chunky sidewall bulge for truck tires
                        const bulgeFactor = Math.sin(angle) * (1 + 0.1 * Math.sin(angle * 2));
                        const r = tireInner + (tireOuter - tireInner) * bulgeFactor;
                        const y = (t - 0.5) * tireWidth;
                        tireProfile.push(new THREE.Vector2(r, y));
                    }
                    const tireGeo = new THREE.LatheGeometry(tireProfile, 32);
                    const tire = new THREE.Mesh(tireGeo, tireMat);
                    tire.rotation.x = Math.PI / 2;
                    tire.position.set(x, pickupWheelY, z);
                    tire.castShadow = true;
                    car.add(tire);
                    
                    // Tire sidewall protector ridge (raised lip for curb protection)
                    const protectorGeo = new THREE.TorusGeometry(wheelRadius - 0.06, 0.015, 6, 32);
                    const protector = new THREE.Mesh(protectorGeo, letteringMat);
                    protector.position.set(x, pickupWheelY, z + side * (tireWidth / 2 - 0.03));
                    car.add(protector);
                    
                    // Tire brand lettering (raised ridges simulating "ALL-TERRAIN")
                    for (let m = 0; m < 4; m++) {
                        const markAngle = (m / 10 + 0.05) * Math.PI * 2;
                        const markGeo = new THREE.BoxGeometry(0.1, 0.018, 0.015);
                        const mark = new THREE.Mesh(markGeo, letteringMat);
                        mark.position.set(
                            x + Math.cos(markAngle) * (wheelRadius - 0.05),
                            pickupWheelY + Math.sin(markAngle) * (wheelRadius - 0.05),
                            z + side * (tireWidth / 2 - 0.025)
                        );
                        mark.rotation.z = markAngle + Math.PI / 2;
                        car.add(mark);
                    }
                    
                    // --- RIM with deep dish and polished lip ---
                    const rimRadius = wheelRadius - 0.12;
                    
                    // Rim barrel (inner visible part)
                    const rimBarrelGeo = new THREE.CylinderGeometry(rimRadius, rimRadius - 0.02, tireWidth - 0.06, 24);
                    const rimBarrelMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7, roughness: 0.35 });
                    const rimBarrel = new THREE.Mesh(rimBarrelGeo, rimBarrelMat);
                    rimBarrel.rotation.x = Math.PI / 2;
                    rimBarrel.position.set(x, pickupWheelY, z);
                    car.add(rimBarrel);
                    
                    // Polished rim lip (outer edge)
                    const rimLipGeo = new THREE.TorusGeometry(rimRadius + 0.01, 0.025, 8, 32);
                    const rimLip = new THREE.Mesh(rimLipGeo, chromeMat);
                    rimLip.position.set(x, pickupWheelY, z + side * (tireWidth / 2 - 0.05));
                    car.add(rimLip);
                    
                    // Rim face (slightly concave dish)
                    const rimFaceGeo = new THREE.CylinderGeometry(rimRadius - 0.01, rimRadius - 0.04, 0.025, 24);
                    const rimFaceMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.9, roughness: 0.15 });
                    const rimFace = new THREE.Mesh(rimFaceGeo, rimFaceMat);
                    rimFace.rotation.x = Math.PI / 2;
                    rimFace.position.set(x, pickupWheelY, z + side * (tireWidth / 2 - 0.08));
                    car.add(rimFace);
                    
                    // --- 5-SPOKE ALLOY DESIGN (truck style) ---
                    const spokeMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.85, roughness: 0.25 });
                    for (let i = 0; i < 5; i++) {
                        const spokeAngle = (i / 5) * Math.PI * 2 + Math.PI / 10;
                        const spokeLen = rimRadius - 0.08;
                        
                        // Main spoke (wider at hub)
                        const spokeGeo = new THREE.BoxGeometry(spokeLen, 0.05, 0.03);
                        const spoke = new THREE.Mesh(spokeGeo, chromeMat);
                        spoke.position.set(
                            x + Math.cos(spokeAngle) * (spokeLen / 2),
                            pickupWheelY + Math.sin(spokeAngle) * (spokeLen / 2),
                            z + side * (tireWidth / 2 - 0.07)
                        );
                        spoke.rotation.z = spokeAngle;
                        car.add(spoke);
                        
                        // Twin spoke (for 10-spoke look)
                        const spoke2Geo = new THREE.BoxGeometry(spokeLen * 0.85, 0.035, 0.025);
                        const spoke2 = new THREE.Mesh(spoke2Geo, spokeMat);
                        spoke2.position.set(
                            x + Math.cos(spokeAngle + 0.15) * (spokeLen / 2 - 0.02),
                            pickupWheelY + Math.sin(spokeAngle + 0.15) * (spokeLen / 2 - 0.02),
                            z + side * (tireWidth / 2 - 0.075)
                        );
                        spoke2.rotation.z = spokeAngle + 0.15;
                        car.add(spoke2);
                    }
                    
                    // --- CENTER HUB CAP (domed with logo detail) ---
                    const hubCapGeo = new THREE.SphereGeometry(0.07, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                    const hubCap = new THREE.Mesh(hubCapGeo, chromeMat);
                    hubCap.rotation.x = side > 0 ? -Math.PI / 2 : Math.PI / 2;
                    hubCap.position.set(x, pickupWheelY, z + side * (tireWidth / 2 - 0.04));
                    car.add(hubCap);
                    
                    // Hub ring accent
                    const hubRingGeo = new THREE.TorusGeometry(0.05, 0.008, 8, 16);
                    const hubRing = new THREE.Mesh(hubRingGeo, spokeMat);
                    hubRing.position.set(x, pickupWheelY, z + side * (tireWidth / 2 - 0.035));
                    car.add(hubRing);
                    
                    // --- LUG NUTS (6-lug pattern - truck style) ---
                    const lugRadius = rimRadius * 0.35;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const lugGeo = new THREE.CylinderGeometry(0.018, 0.02, 0.02, 6);
                        const lugNut = new THREE.Mesh(lugGeo, chromeMat);
                        lugNut.rotation.x = Math.PI / 2;
                        lugNut.position.set(
                            x + Math.cos(angle) * lugRadius,
                            pickupWheelY + Math.sin(angle) * lugRadius,
                            z + side * (tireWidth / 2 - 0.025)
                        );
                        car.add(lugNut);
                    }
                    
                    // --- BRAKE ROTOR (cross-drilled performance style) ---
                    const rotorRadius = rimRadius - 0.08;
                    const rotorGeo = new THREE.CylinderGeometry(rotorRadius, rotorRadius, 0.04, 32);
                    const rotor = new THREE.Mesh(rotorGeo, pkRotorMat);
                    rotor.rotation.x = Math.PI / 2;
                    rotor.position.set(x, pickupWheelY, z - side * 0.06);
                    car.add(rotor);
                    
                    // Rotor hub
                    const rotorHubGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.045, 16);
                    const rotorHub = new THREE.Mesh(rotorHubGeo, pkRotorMat);
                    rotorHub.rotation.x = Math.PI / 2;
                    rotorHub.position.set(x, pickupWheelY, z - side * 0.06);
                    car.add(rotorHub);
                    
                    // Cross-drilled holes (2 rings for realism)
                    const holeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
                    for (let ring = 0; ring < 2; ring++) {
                        const holeRadius = rotorRadius - 0.05 - ring * 0.06;
                        const holeCount = 16 - ring * 4;
                        for (let h = 0; h < holeCount; h++) {
                            const angle = (h / holeCount) * Math.PI * 2;
                            const holeGeo = new THREE.CylinderGeometry(0.012, 0.012, 0.045, 6);
                            const hole = new THREE.Mesh(holeGeo, holeMat);
                            hole.rotation.x = Math.PI / 2;
                            hole.position.set(
                                x + Math.cos(angle) * holeRadius,
                                pickupWheelY + Math.sin(angle) * holeRadius,
                                z - side * 0.06
                            );
                            car.add(hole);
                        }
                    }
                    
                    // Ventilation slots (curved for realism)
                    for (let v = 0; v < 20; v++) {
                        const angle = (v / 20) * Math.PI * 2;
                        const slotGeo = new THREE.BoxGeometry(0.06, 0.04, 0.006);
                        const slot = new THREE.Mesh(slotGeo, trimMat);
                        const slotR = rotorRadius - 0.15;
                        slot.position.set(
                            x + Math.cos(angle) * slotR,
                            pickupWheelY + Math.sin(angle) * slotR,
                            z - side * 0.06
                        );
                        slot.rotation.z = angle + 0.25;
                        car.add(slot);
                    }
                    
                    // --- RED BRAKE CALIPER (heavy-duty truck style) ---
                    const caliperAngle = isFront ? -0.4 : -0.3;
                    const caliperX = x + Math.cos(caliperAngle) * (rotorRadius - 0.05);
                    const caliperY = pickupWheelY + Math.sin(caliperAngle) * (rotorRadius - 0.05) + 0.03;
                    
                    // Caliper body (larger for truck)
                    const caliperGeo = new THREE.BoxGeometry(0.16, 0.1, 0.07);
                    const caliper = new THREE.Mesh(caliperGeo, pkCaliperMat);
                    caliper.position.set(caliperX, caliperY, z - side * 0.08);
                    caliper.rotation.z = caliperAngle + 0.1;
                    car.add(caliper);
                    
                    // Caliper lettering detail (raised "BRAKE" area)
                    const letterGeo = new THREE.BoxGeometry(0.1, 0.05, 0.01);
                    const letter = new THREE.Mesh(letterGeo, new THREE.MeshStandardMaterial({ 
                        color: 0xdd0000, metalness: 0.4, roughness: 0.45 
                    }));
                    letter.position.set(caliperX, caliperY, z - side * 0.045);
                    letter.rotation.z = caliperAngle + 0.1;
                    car.add(letter);
                    
                    // Caliper mounting bracket
                    const bracketGeo = new THREE.BoxGeometry(0.025, 0.14, 0.05);
                    const bracket = new THREE.Mesh(bracketGeo, trimMat);
                    bracket.position.set(
                        x + Math.cos(caliperAngle) * (rotorRadius - 0.12),
                        pickupWheelY + Math.sin(caliperAngle) * (rotorRadius - 0.12),
                        z - side * 0.09
                    );
                    car.add(bracket);
                }
                
                // Add all 4 wheels with LatheGeometry tires
                createWheelAssembly(frontWheelX, wheelZOuter, true);
                createWheelAssembly(frontWheelX, wheelZInner, true);
                createWheelAssembly(rearWheelX, wheelZOuter, false);
                createWheelAssembly(rearWheelX, wheelZInner, false);
                
                // === REAR BUMPER ===
                const rearBumper = new THREE.Mesh(
                    new THREE.BoxGeometry(0.18, 0.3, 2.0),
                    chromeMat
                );
                rearBumper.position.set(2.35, 0.42, 0);
                car.add(rearBumper);
                
                // Rear bumper step pads
                [-0.6, 0, 0.6].forEach(z => {
                    const pad = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.04, 0.4),
                        bedLinerMat
                    );
                    pad.position.set(2.38, 0.55, z);
                    car.add(pad);
                });
                
                // Hitch receiver
                const hitch = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.15, 0.15),
                    new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 })
                );
                hitch.position.set(2.4, 0.38, 0);
                car.add(hitch);
                
                // === LICENSE PLATE (rear) ===
                const licensePlate = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.18, 0.38),
                    new THREE.MeshStandardMaterial({ color: 0xffffee, roughness: 0.5 })
                );
                licensePlate.position.set(2.28, 0.95, 0);
                car.add(licensePlate);
                
                // === ANTENNA ===
                const antenna = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.02, 0.7, 8),
                    trimMat
                );
                antenna.position.set(-0.5, 2.55, 0.85);
                antenna.rotation.z = -0.15;
                car.add(antenna);
                
                // === THIRD BRAKE LIGHT (top of cab) ===
                const thirdBrake = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.08, 0.5),
                    taillightMat
                );
                thirdBrake.position.set(-0.02, 2.38, 0);
                car.add(thirdBrake);
                
                // === SECOND ITERATION IMPROVEMENTS ===
                
                // Dual exhaust tips (chrome, visible from rear)
                [-0.45, 0.45].forEach(z => {
                    // Exhaust pipe
                    const exhaustPipe = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.06, 0.06, 0.4, 12),
                        new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 })
                    );
                    exhaustPipe.rotation.z = Math.PI / 2;
                    exhaustPipe.position.set(2.1, 0.28, z);
                    car.add(exhaustPipe);
                    
                    // Chrome tip
                    const exhaustTip = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.075, 0.065, 0.15, 16),
                        chromeMat
                    );
                    exhaustTip.rotation.z = Math.PI / 2;
                    exhaustTip.position.set(2.35, 0.28, z);
                    car.add(exhaustTip);
                    
                    // Inner dark (exhaust opening)
                    const exhaustInner = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 0.02, 12),
                        new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 1 })
                    );
                    exhaustInner.rotation.z = Math.PI / 2;
                    exhaustInner.position.set(2.42, 0.28, z);
                    car.add(exhaustInner);
                });
                
                // Front tow hooks (red, aggressive look)
                const towHookMat = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.4, metalness: 0.6 });
                [-0.75, 0.75].forEach(z => {
                    const hook = new THREE.Mesh(
                        new THREE.TorusGeometry(0.08, 0.025, 8, 12, Math.PI),
                        towHookMat
                    );
                    hook.rotation.x = Math.PI / 2;
                    hook.rotation.z = Math.PI;
                    hook.position.set(-3.75, 0.38, z);
                    car.add(hook);
                    
                    // Hook mount plate
                    const hookPlate = new THREE.Mesh(
                        new THREE.BoxGeometry(0.06, 0.12, 0.15),
                        trimMat
                    );
                    hookPlate.position.set(-3.72, 0.38, z);
                    car.add(hookPlate);
                });
                
                // Body side character lines (muscular creases)
                [-1.08, 1.08].forEach(z => {
                    // Upper body crease (runs along door)
                    const upperCrease = new THREE.Mesh(
                        new THREE.BoxGeometry(2.5, 0.015, 0.02),
                        new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 1 })
                    );
                    upperCrease.position.set(-1.0, 1.55, z);
                    car.add(upperCrease);
                    
                    // Lower body crease (muscular fender line)
                    const lowerCrease = new THREE.Mesh(
                        new THREE.BoxGeometry(4.2, 0.02, 0.02),
                        new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 1 })
                    );
                    lowerCrease.position.set(-0.5, 1.0, z);
                    car.add(lowerCrease);
                    
                    // Wheel arch highlight line
                    const archLine = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.015, 0.02),
                        trimMat
                    );
                    archLine.position.set(-2.5, 1.15, z);
                    car.add(archLine);
                });
                
                // Bed tie-down hooks (4 corners inside bed)
                [0.35, 1.85].forEach(x => {
                    [-0.75, 0.75].forEach(z => {
                        // Hook mount
                        const tieMount = new THREE.Mesh(
                            new THREE.BoxGeometry(0.1, 0.06, 0.1),
                            chromeMat
                        );
                        tieMount.position.set(x, 1.02, z);
                        car.add(tieMount);
                        
                        // Hook ring
                        const tieRing = new THREE.Mesh(
                            new THREE.TorusGeometry(0.04, 0.012, 6, 8),
                            chromeMat
                        );
                        tieRing.rotation.x = Math.PI / 2;
                        tieRing.position.set(x, 1.06, z);
                        car.add(tieRing);
                    });
                });
                
                // Cab roof light bar mounts (for off-road look)
                [-0.7, 0, 0.7].forEach(z => {
                    const lightMount = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.04, 0.08),
                        trimMat
                    );
                    lightMount.position.set(-0.8, 2.38, z);
                    car.add(lightMount);
                });
                
                // Door sill plates (chrome trim at bottom of doors)
                [-1.05, 1.05].forEach(z => {
                    const sillPlate = new THREE.Mesh(
                        new THREE.BoxGeometry(1.6, 0.04, 0.06),
                        chromeMat
                    );
                    sillPlate.position.set(-0.8, 0.68, z);
                    car.add(sillPlate);
                });
                
                // Fuel cap (driver side)
                const fuelCap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.03, 12),
                    bodyMat
                );
                fuelCap.rotation.x = Math.PI / 2;
                fuelCap.position.set(0.6, 1.3, -1.06);
                car.add(fuelCap);
                
                // Fuel cap chrome ring
                const fuelRing = new THREE.Mesh(
                    new THREE.TorusGeometry(0.08, 0.015, 8, 16),
                    chromeMat
                );
                fuelRing.rotation.x = Math.PI / 2;
                fuelRing.position.set(0.6, 1.3, -1.08);
                car.add(fuelRing);
                
                // Bed bulkhead (cab-side of bed)
                const bulkhead = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.65, 1.85),
                    bodyMat
                );
                bulkhead.position.set(0.08, 1.3, 0);
                car.add(bulkhead);
                
                // Bulkhead window (optional sliding rear window effect)
                const bulkheadWindow = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, 0.35, 1.2),
                    glassMat
                );
                bulkheadWindow.position.set(0.1, 1.4, 0);
                car.add(bulkheadWindow);
                
                // === THIRD ITERATION - FINAL POLISH ===
                
                // Front skid plate (aluminum look, protects undercarriage)
                const skidPlateMat = new THREE.MeshStandardMaterial({ color: 0x888899, metalness: 0.7, roughness: 0.35 });
                const skidPlate = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.04, 1.6),
                    skidPlateMat
                );
                skidPlate.position.set(-3.5, 0.28, 0);
                car.add(skidPlate);
                
                // Skid plate ridges (for strength)
                [-0.5, 0, 0.5].forEach(z => {
                    const ridge = new THREE.Mesh(
                        new THREE.BoxGeometry(0.55, 0.06, 0.08),
                        skidPlateMat
                    );
                    ridge.position.set(-3.5, 0.3, z);
                    car.add(ridge);
                });
                
                // Hood vents (functional air extractors)
                [-0.55, 0.55].forEach(z => {
                    // Vent housing
                    const ventHousing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.06, 0.22),
                        trimMat
                    );
                    ventHousing.position.set(-2.8, 1.4, z);
                    car.add(ventHousing);
                    
                    // Vent slats
                    for (let i = 0; i < 4; i++) {
                        const slat = new THREE.Mesh(
                            new THREE.BoxGeometry(0.35, 0.015, 0.03),
                            trimMat
                        );
                        slat.position.set(-2.8, 1.42, z - 0.08 + i * 0.05);
                        slat.rotation.x = 0.3;
                        car.add(slat);
                    }
                });
                
                // A-pillar trim (black accent from windshield to roof)
                [-1.0, 1.0].forEach(z => {
                    const aPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 0.04, 0.08),
                        trimMat
                    );
                    aPillar.rotation.z = 0.42; // Match windshield angle
                    aPillar.position.set(-1.95, 1.65, z);
                    car.add(aPillar);
                });
                
                // B-pillar (between front and rear windows)
                [-1.02, 1.02].forEach(z => {
                    const bPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.7, 0.06),
                        trimMat
                    );
                    bPillar.position.set(-0.4, 1.75, z);
                    car.add(bPillar);
                });
                
                // C-pillar (rear cab corner)
                [-1.0, 1.0].forEach(z => {
                    const cPillar = new THREE.Mesh(
                        new THREE.BoxGeometry(0.25, 0.55, 0.08),
                        trimMat
                    );
                    cPillar.position.set(0.0, 1.75, z);
                    car.add(cPillar);
                });
                
                // Roof rack rails (optional off-road accessory look)
                [-0.75, 0.75].forEach(z => {
                    const rackRail = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.04, 0.06),
                        trimMat
                    );
                    rackRail.position.set(-0.8, 2.4, z);
                    car.add(rackRail);
                    
                    // Rail feet
                    [-1.5, -0.1].forEach(x => {
                        const foot = new THREE.Mesh(
                            new THREE.BoxGeometry(0.08, 0.06, 0.08),
                            trimMat
                        );
                        foot.position.set(x, 2.36, z);
                        car.add(foot);
                    });
                });
                
                // Mud flaps (behind wheels)
                [[-2.85, -1.15], [-2.85, 1.15], [1.75, -1.15], [1.75, 1.15]].forEach(([x, z]) => {
                    const flap = new THREE.Mesh(
                        new THREE.BoxGeometry(0.04, 0.35, 0.4),
                        bedLinerMat
                    );
                    flap.position.set(x, 0.35, z);
                    car.add(flap);
                });
                
                // Side marker lights (amber, on fenders)
                [-1.12, 1.12].forEach(z => {
                    // Front markers (near headlights)
                    const frontMarker = new THREE.Mesh(
                        new THREE.BoxGeometry(0.03, 0.06, 0.12),
                        blinkerMat
                    );
                    frontMarker.position.set(-3.2, 0.85, z);
                    car.add(frontMarker);
                    
                    // Rear markers (on bed sides)
                    const rearMarker = new THREE.Mesh(
                        new THREE.BoxGeometry(0.03, 0.06, 0.12),
                        taillightMat
                    );
                    rearMarker.position.set(1.8, 1.5, z);
                    car.add(rearMarker);
                });
                
                // Tailgate brand embossing (raised letters effect)
                const brandText = new THREE.Mesh(
                    new THREE.BoxGeometry(0.03, 0.12, 0.8),
                    new THREE.MeshStandardMaterial({ color: bodyMat.color, metalness: 0.6, roughness: 0.3 })
                );
                brandText.position.set(2.2, 1.35, 0);
                car.add(brandText);
                
                // Cab clearance lights (amber, on roof - like RAM trucks)
                const cabLightMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
                [-0.6, -0.3, 0, 0.3, 0.6].forEach(z => {
                    const cabLight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.05, 0.035, 0.08),
                        cabLightMat
                    );
                    cabLight.position.set(-0.8, 2.42, z);
                    car.add(cabLight);
                });
                
                // Rear wheel well inner liner (visible through wheel arch)
                [-1.05, 1.05].forEach(z => {
                    const liner = new THREE.Mesh(
                        new THREE.BoxGeometry(0.9, 0.5, 0.04),
                        bedLinerMat
                    );
                    liner.position.set(1.4, 0.8, z * 0.88);
                    car.add(liner);
                });
            }
            
            // === COMMON DETAILS FOR ALL STYLES ===
            // Skip for vehicles with fully custom detailed parts (sports, pickup, sedan, hatchback, suv)
            // These styles have their own detailed headlights, taillights, and wheels built-in
            
            // Only add common details for styles that don't have custom lights
            const hasCustomLights = (style === 'sports' || style === 'pickup' || style === 'sedan' || style === 'hatchback' || style === 'suv');
            
            if (!hasCustomLights) {
                // Headlights (front) - fallback for any new styles
                [-0.75, 0.75].forEach(z => {
                    // Main light with enhanced emissive
                    const hl = new THREE.Mesh(
                        new THREE.BoxGeometry(0.12, 0.22, 0.45),
                        headlightMat
                    );
                    hl.position.set(-2.28, 0.75, z);
                    car.add(hl);
                    
                    // Chrome Housing
                    const housing = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.28, 0.52),
                        chromeMat
                    );
                    housing.position.set(-2.32, 0.75, z);
                    car.add(housing);
                });
                
                // Taillights (back) - these face the camera
                [-0.7, 0.7].forEach(z => {
                    const tl = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, 0.25, 0.5),
                        taillightMat
                    );
                    tl.position.set(2.28, 0.85, z);
                    car.add(tl);
                });
                
                // Turn signals (orange corners)
                [[-0.9, -2.25], [0.9, -2.25], [-0.85, 2.25], [0.85, 2.25]].forEach(([z, x]) => {
                    const blinker = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.12, 0.2),
                        blinkerMat
                    );
                    blinker.position.set(x, 0.7, z);
                    car.add(blinker);
                });
            }
            
            // Wheels - only add basic wheels if custom detailed wheels weren't already created
            if (!car.userData.hasCustomWheels) {
                    const wheelRadius = style === 'suv' ? 0.5 : 0.45;
                    const wheelWidth = 0.32;
                    const wheelGeo = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 24);
                    
                    const wheelY = style === 'suv' ? 0.5 : 0.45;
                    const wheelX = style === 'pickup' ? 1.5 : 1.4;
                    const wheelZ = style === 'suv' ? 1.05 : 0.95;
                    
                    // Store wheel references for animation
                    car.userData.wheels = [];
                    car.userData.wheelRadius = wheelRadius;
                    
                    const wheelPositions = [
                        { pos: [-wheelX, wheelY, wheelZ], isFront: true },    // Front Left
                        { pos: [-wheelX, wheelY, -wheelZ], isFront: true },   // Front Right
                        { pos: [wheelX, wheelY, wheelZ], isFront: false },    // Rear Left
                        { pos: [wheelX, wheelY, -wheelZ], isFront: false }    // Rear Right
                    ];
                    
                    wheelPositions.forEach(({ pos, isFront }) => {
                        // Create a wheel group to hold tire + rim (so they rotate together)
                        const wheelGroup = new THREE.Group();
                        wheelGroup.position.set(...pos);
                        wheelGroup.userData.isFront = isFront;
                        
                        // Tire
                        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                        wheel.rotation.x = Math.PI / 2;
                        wheel.castShadow = true;
                        wheelGroup.add(wheel);
                        
                        // Rim
                        const rimGeo = new THREE.CylinderGeometry(wheelRadius * 0.65, wheelRadius * 0.65, wheelWidth + 0.02, 16);
                        const rim = new THREE.Mesh(rimGeo, chromeMat);
                        rim.rotation.x = Math.PI / 2;
                        wheelGroup.add(rim);
                        
                        // Rim center
                        const center = new THREE.Mesh(
                            new THREE.CylinderGeometry(wheelRadius * 0.2, wheelRadius * 0.2, wheelWidth + 0.04, 8),
                            trimMat
                        );
                        center.rotation.x = Math.PI / 2;
                        wheelGroup.add(center);
                        
                        car.add(wheelGroup);
                        car.userData.wheels.push(wheelGroup);
                    });
            }
            
            // Common finishing details for all cars (only if not already present)
            // License plate, mirrors, and grille are part of the detailed implementations
            // for sedan, sports, suv, hatchback, and pickup - skip adding duplicates
            
            return car;
        }
        
        function spawnTraffic(z) {
            // Vibrant arcade colors for civilian traffic
            const colors = [
                0xff0000, // Red
                0x0066ff, // Blue  
                0xffcc00, // Yellow
                0x00cc44, // Green
                0xff4400, // Orange
                0xcc00cc, // Purple
                0x00cccc, // Teal
                0xffffff, // White
                0x222222, // Black
                0x884400, // Brown
            ];
            
            // Proper 4-lane positioning (outer lanes = slower traffic)
            const lanes = [-7.5, -2.5, 2.5, 7.5];
            
            // Determine spawn pattern: single car (70%), pair (20%), cluster (10%)
            const pattern = Math.random();
            let carsToSpawn = [];
            
            if (pattern < 0.70) {
                // Single car
                const lane = lanes[Math.floor(Math.random() * lanes.length)];
                carsToSpawn.push({ lane: lane, zOffset: 0 });
            } else if (pattern < 0.90) {
                // Pair of cars (side-by-side or staggered)
                const laneIdx1 = Math.floor(Math.random() * lanes.length);
                const laneIdx2 = (laneIdx1 + (Math.random() > 0.5 ? 1 : -1) + lanes.length) % lanes.length;
                const stagger = Math.random() > 0.5;
                carsToSpawn.push({ lane: lanes[laneIdx1], zOffset: 0 });
                carsToSpawn.push({ lane: lanes[laneIdx2], zOffset: stagger ? -(8 + Math.random() * 10) : 0 });
            } else {
                // Cluster of 2-3 cars spread out
                const numCars = 2 + Math.floor(Math.random() * 2);
                const usedLanes = new Set();
                for (let i = 0; i < numCars; i++) {
                    let laneIdx;
                    do {
                        laneIdx = Math.floor(Math.random() * lanes.length);
                    } while (usedLanes.has(laneIdx) && usedLanes.size < lanes.length);
                    usedLanes.add(laneIdx);
                    carsToSpawn.push({ 
                        lane: lanes[laneIdx], 
                        zOffset: -(i * (6 + Math.random() * 8))
                    });
                }
            }
            
            // Spawn each car in the pattern
            carsToSpawn.forEach(spawnInfo => {
                const color = colors[Math.floor(Math.random() * colors.length)];
                let car;
                
                // Always use createCivilianCar() for traffic - NOT the GLTF cop car model!
                // The GLTF model is a police car and should only be used for player/cops
                // Distribution: 5 normal car types (~17% each = 85%) + hover vehicles (~15%)
                const rand = Math.random();
                let style;
                if (rand < 0.15) {
                    // ~15% chance: Futuristic hover vehicles (Tron/F-Zero style)
                    style = 'hover';
                } else {
                    // ~85% chance: Regular vehicle types (17% each)
                    const regularStyles = ['sedan', 'sports', 'suv', 'pickup', 'hatchback'];
                    style = regularStyles[Math.floor(Math.random() * regularStyles.length)];
                }
                car = createCivilianCar(color, style);
                car.userData.carStyle = style; // Track style for debugging
                // Geometric car - createCivilianCar builds car facing -X (headlights at -X, taillights at +X)
                // +PI/2 rotates -X ‚Üí -Z (headlights forward) and +X ‚Üí +Z (taillights toward camera)
                car.rotation.y = Math.PI / 2;
                car.userData.isGltf = false;
                
                const lane = spawnInfo.lane;
                const carZ = z + spawnInfo.zOffset;
                // Store spawn curve position and intensity (like road segments do)
                car.userData.spawnCurveX = 0;
                car.userData.spawnCurve = roadCurve;  // Curve intensity at spawn time
                // Initial X position combines cumulative curve + lane offset
                car.position.set(lane, 0, carZ);
                
                // === REALISTIC SPEED PROFILES BY VEHICLE TYPE ===
                // Each style has base speed + variance for natural traffic variety
                const speedProfiles = {
                    sedan: { base: 55, variance: 15 },      // 40-70 mph - average drivers
                    suv: { base: 50, variance: 10 },        // 40-60 mph - cautious family vehicles
                    hatchback: { base: 60, variance: 20 },  // 40-80 mph - zippy commuters
                    pickup: { base: 45, variance: 12 },     // 33-57 mph - work trucks, slower
                    sports: { base: 80, variance: 25 },     // 55-105 mph - aggressive speeders
                    hover: { base: 70, variance: 20 }       // 50-90 mph - futuristic mid-range
                };
                
                const profile = speedProfiles[style] || speedProfiles.sedan;
                const baseSpeedFromType = profile.base + (Math.random() - 0.5) * 2 * profile.variance;
                
                // Lane modifier: outer lanes still tend slower, inner lanes faster
                const isOuterLane = Math.abs(lane) > 5;
                const laneModifier = isOuterLane ? 0.85 : 1.1; // Outer lanes 15% slower, inner 10% faster
                
                // Final base speed with some individual variance
                const finalBaseSpeed = baseSpeedFromType * laneModifier;
                
                // Set up speed system with currentSpeed, targetSpeed for gradual changes
                car.userData.baseSpeed = finalBaseSpeed;           // Their natural cruising speed
                car.userData.currentSpeed = finalBaseSpeed;        // Actual current speed
                car.userData.targetSpeed = finalBaseSpeed;         // What they're trying to reach
                car.userData.acceleration = 12 + Math.random() * 8; // How fast they speed up/slow down (12-20)
                car.userData.speed = finalBaseSpeed;               // Legacy compatibility
                car.userData.passed = false;
                car.userData.crashed = false;
                car.userData.baseX = lane;  // Base position on curved road
                car.userData.lane = lane;
                
                scene.add(car);
                traffic.push(car);
            });
        }
        
        // ================================================================
        // EMERGENCY VEHICLE SYSTEM
        // Ambulances and fire trucks with flashing lights
        // Other traffic yields (slows + moves aside) when nearby
        // ================================================================
        function createEmergencyVehicle(type) {
            const vehicle = new THREE.Group();
            
            // Ambulance or Fire Truck
            const isAmbulance = type === 'ambulance';
            const bodyColor = isAmbulance ? 0xffffff : 0xcc2222;
            const accentColor = isAmbulance ? 0xff0000 : 0xffcc00;
            
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor, metalness: 0.3, roughness: 0.5 });
            const accentMat = new THREE.MeshStandardMaterial({ color: accentColor, metalness: 0.4, roughness: 0.5 });
            const chromeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.2 });
            const glassMat = new THREE.MeshStandardMaterial({ color: 0x224466, transparent: true, opacity: 0.6 });
            
            // Main body (box truck style)
            const bodyLength = isAmbulance ? 5.5 : 7.0;
            const bodyHeight = isAmbulance ? 2.8 : 3.2;
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(bodyLength, bodyHeight, 2.4),
                bodyMat
            );
            body.position.set(0.5, bodyHeight / 2 + 0.5, 0);
            body.castShadow = true;
            vehicle.add(body);
            
            // Cab section (front)
            const cab = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 2.0, 2.2),
                bodyMat
            );
            cab.position.set(-2.2, 1.5, 0);
            cab.castShadow = true;
            vehicle.add(cab);
            
            // Windshield
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(1.8, 1.2),
                glassMat
            );
            windshield.rotation.y = -Math.PI / 2;
            windshield.position.set(-3.35, 1.8, 0);
            vehicle.add(windshield);
            
            // Accent stripes
            if (isAmbulance) {
                // Red cross stripe
                const stripe = new THREE.Mesh(
                    new THREE.BoxGeometry(3.5, 0.5, 2.45),
                    accentMat
                );
                stripe.position.set(0.5, 2.0, 0);
                vehicle.add(stripe);
                
                // Red cross symbol
                const crossH = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.35, 0.05), accentMat);
                crossH.position.set(1.5, 2.5, 1.23);
                vehicle.add(crossH);
                const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.2, 0.05), accentMat);
                crossV.position.set(1.5, 2.5, 1.23);
                vehicle.add(crossV);
            } else {
                // Fire truck yellow stripes
                [-0.8, 0.8].forEach(z => {
                    const stripe = new THREE.Mesh(
                        new THREE.BoxGeometry(bodyLength + 0.1, 0.3, 0.15),
                        accentMat
                    );
                    stripe.position.set(0.5, 1.5, z);
                    vehicle.add(stripe);
                });
                
                // Ladder rack on top
                const ladderMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.7 });
                const rack = new THREE.Mesh(new THREE.BoxGeometry(5, 0.15, 1.8), ladderMat);
                rack.position.set(1, bodyHeight + 0.6, 0);
                vehicle.add(rack);
            }
            
            // === FLASHING LIGHT BAR (the star feature!) ===
            const lightBarGroup = new THREE.Group();
            const barBase = new THREE.Mesh(
                new THREE.BoxGeometry(isAmbulance ? 1.8 : 2.5, 0.2, 1.0),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            lightBarGroup.add(barBase);
            
            // Red and blue flashing lights with emissive materials
            const redLightMat = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, 
                emissive: 0xff0000, 
                emissiveIntensity: 3.0 
            });
            const blueLightMat = new THREE.MeshStandardMaterial({ 
                color: 0x0066ff, 
                emissive: 0x0066ff, 
                emissiveIntensity: 3.0 
            });
            
            // Light domes
            const lightPositions = isAmbulance ? [-0.5, 0.5] : [-0.8, 0, 0.8];
            lightPositions.forEach((x, i) => {
                const mat = (i % 2 === 0) ? redLightMat : blueLightMat;
                const dome = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    mat.clone() // Clone so we can animate independently
                );
                dome.position.set(x, 0.2, 0);
                dome.userData.isRedLight = (i % 2 === 0);
                dome.userData.lightMaterial = dome.material;
                lightBarGroup.add(dome);
            });
            
            // Add point light for dramatic effect
            const sirenLight = new THREE.PointLight(0xff0044, 2, 25);
            sirenLight.position.set(0, 0.3, 0);
            lightBarGroup.add(sirenLight);
            vehicle.userData.sirenLight = sirenLight;
            vehicle.userData.lightBarGroup = lightBarGroup;
            
            lightBarGroup.position.set(isAmbulance ? -2.2 : -1.8, isAmbulance ? 2.7 : 3.5, 0);
            vehicle.add(lightBarGroup);
            
            // Wheels (larger for emergency vehicles)
            const wheelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
            const wheelGeo = new THREE.CylinderGeometry(0.55, 0.55, 0.5, 16);
            
            [[-2, -1.0], [-2, 1.0], [2, -1.0], [2, 1.0]].forEach(([x, z]) => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.rotation.x = Math.PI / 2;
                wheel.position.set(x, 0.55, z);
                wheel.castShadow = true;
                vehicle.add(wheel);
            });
            
            // Chrome bumpers
            const frontBumper = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.4, 2.4),
                chromeMat
            );
            frontBumper.position.set(-3.4, 0.6, 0);
            vehicle.add(frontBumper);
            
            // Headlights (always on for emergency)
            const headlightMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffee, 
                emissive: 0xffffcc, 
                emissiveIntensity: 2.0 
            });
            [-0.7, 0.7].forEach(z => {
                const hl = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), headlightMat);
                hl.position.set(-3.35, 1.0, z);
                vehicle.add(hl);
            });
            
            vehicle.userData.isEmergency = true;
            vehicle.userData.emergencyType = type;
            vehicle.userData.flashPhase = 0;
            
            return vehicle;
        }
        
        function spawnEmergencyVehicle(z) {
            const types = ['ambulance', 'firetruck'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const vehicle = createEmergencyVehicle(type);
            
            // Emergency vehicles use inner lanes, moving fast
            const lanes = [-2.5, 2.5];
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            
            // Store spawn curve position and intensity (like road segments do)
            vehicle.userData.spawnCurveX = 0;
            vehicle.userData.spawnCurve = roadCurve;  // Curve intensity at spawn time
            vehicle.position.set(lane, 0, z);
            // Emergency vehicles built with front at -X; +PI/2 rotates to show back (taillights) to player
            vehicle.rotation.y = Math.PI / 2;
            
            // Emergency vehicles move FAST (like they're responding to a call)
            vehicle.userData.speed = 100 + Math.random() * 40; // 100-140 mph
            vehicle.userData.passed = false;
            vehicle.userData.crashed = false;
            vehicle.userData.baseX = lane;  // Base position on curved road
            vehicle.userData.lane = lane;
            vehicle.userData.isGltf = false;
            
            scene.add(vehicle);
            traffic.push(vehicle);
            emergencyVehicles.push(vehicle);
            
            // Announce the emergency vehicle!
            announce('üö® EMERGENCY!', 800);
        }
        
        function generateInitialRoad() {
            // Start road at positive Z (behind camera) and extend into negative Z (ahead)
            // lastRoadZ represents the FAR EDGE of where we've built road to
            // First segment will be centered at lastRoadZ - segLen/2 = 70 - 17.5 = 52.5
            lastRoadZ = 70;
            
            // Reset elevation and road state for consistent starting position
            elevation = 0;
            elevationTarget = 0;
            banking = 0;
            
            // Reset segment-to-segment tracking for smooth generation
            lastSegmentWidth = 24;
            lastSegmentBanking = 0;
            lastSegmentElevation = 0;
            
            // Create enough segments to fill view (~700 units ahead for buffer)
            // 25 segments * 35 units = 875 units of road
            for (let i = 0; i < 25; i++) createRoadSegment();
            
            // Spawn initial landmarks
            spawnLandmark('lighthouse', -40, 0, -200);
            
            // Spawn a starting gate (like a race start line)
            createCheckpointGate(-50, 'START');
            
            // Create detailed start/finish line markings
            createStartFinishLine(-48);
        }
        
        // Create detailed racing start/finish line with checkered pattern and grid boxes
        function createStartFinishLine(z) {
            const startLineGroup = new THREE.Group();
            
            // === CHECKERED START/FINISH LINE (main stripe across road) ===
            const checkerCanvas = document.createElement('canvas');
            checkerCanvas.width = 512;
            checkerCanvas.height = 64;
            const cctx = checkerCanvas.getContext('2d');
            
            // Draw checkered pattern
            const squareSize = 32;
            for (let x = 0; x < 16; x++) {
                for (let y = 0; y < 2; y++) {
                    cctx.fillStyle = (x + y) % 2 === 0 ? '#ffffff' : '#000000';
                    cctx.fillRect(x * squareSize, y * squareSize, squareSize, squareSize);
                }
            }
            
            const checkerTex = new THREE.CanvasTexture(checkerCanvas);
            checkerTex.wrapS = THREE.RepeatWrapping;
            const checkerMat = new THREE.MeshStandardMaterial({ 
                map: checkerTex,
                roughness: 0.6,
                emissive: 0x222222,
                emissiveIntensity: 0.1
            });
            
            // Main checkered stripe
            const mainLine = new THREE.Mesh(
                new THREE.PlaneGeometry(24, 3),
                checkerMat
            );
            mainLine.rotation.x = -Math.PI / 2;
            mainLine.position.set(0, 0.05, z);
            startLineGroup.add(mainLine);
            
            // === STARTING GRID BOXES (race positions) ===
            const gridLineMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                emissive: 0x444444,
                emissiveIntensity: 0.2,
                roughness: 0.4
            });
            
            // Grid box positions (staggered like F1 grid)
            const gridPositions = [
                { x: -5.5, row: 0 },  // P1 (pole position)
                { x: 5.5, row: 1 },   // P2
                { x: -5.5, row: 2 },  // P3
                { x: 5.5, row: 3 },   // P4
                { x: -5.5, row: 4 },  // P5
                { x: 5.5, row: 5 },   // P6
            ];
            
            gridPositions.forEach((pos, idx) => {
                const gridZ = z + 8 + pos.row * 6;  // Behind the start line
                
                // Grid box outline
                const boxWidth = 4;
                const boxLength = 5;
                
                // Front line of grid box
                const frontLine = new THREE.Mesh(
                    new THREE.PlaneGeometry(boxWidth, 0.3),
                    gridLineMat
                );
                frontLine.rotation.x = -Math.PI / 2;
                frontLine.position.set(pos.x, 0.04, gridZ);
                startLineGroup.add(frontLine);
                
                // Side lines
                [-boxWidth/2, boxWidth/2].forEach(side => {
                    const sideLine = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.2, boxLength),
                        gridLineMat
                    );
                    sideLine.rotation.x = -Math.PI / 2;
                    sideLine.position.set(pos.x + side, 0.04, gridZ + boxLength/2);
                    startLineGroup.add(sideLine);
                });
                
                // Position number (painted on track)
                const numCanvas = document.createElement('canvas');
                numCanvas.width = 64;
                numCanvas.height = 64;
                const nctx = numCanvas.getContext('2d');
                nctx.fillStyle = '#ffffff';
                nctx.font = 'bold 48px Arial Black';
                nctx.textAlign = 'center';
                nctx.textBaseline = 'middle';
                nctx.fillText((idx + 1).toString(), 32, 32);
                
                const numTex = new THREE.CanvasTexture(numCanvas);
                const numMat = new THREE.MeshBasicMaterial({ 
                    map: numTex,
                    transparent: true
                });
                
                const posNum = new THREE.Mesh(
                    new THREE.PlaneGeometry(2, 2),
                    numMat
                );
                posNum.rotation.x = -Math.PI / 2;
                posNum.position.set(pos.x, 0.06, gridZ + boxLength/2);
                startLineGroup.add(posNum);
            });
            
            // === PRE-START WARNING STRIPES (like drag strip staging) ===
            const warningMat = new THREE.MeshStandardMaterial({ 
                color: 0xffcc00,
                emissive: 0x554400,
                emissiveIntensity: 0.3,
                roughness: 0.5
            });
            
            // Yellow warning stripes before start line
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.PlaneGeometry(24, 0.8),
                    warningMat
                );
                stripe.rotation.x = -Math.PI / 2;
                stripe.position.set(0, 0.045, z - 4 - i * 1.5);
                startLineGroup.add(stripe);
            }
            
            // === "START" TEXT PAINTED ON ROAD ===
            const startTextCanvas = document.createElement('canvas');
            startTextCanvas.width = 256;
            startTextCanvas.height = 64;
            const stctx = startTextCanvas.getContext('2d');
            stctx.fillStyle = '#00ff00';
            stctx.font = 'bold 52px Arial Black';
            stctx.textAlign = 'center';
            stctx.textBaseline = 'middle';
            stctx.shadowColor = '#004400';
            stctx.shadowBlur = 4;
            stctx.fillText('START', 128, 32);
            
            const startTextTex = new THREE.CanvasTexture(startTextCanvas);
            const startTextMat = new THREE.MeshBasicMaterial({ 
                map: startTextTex,
                transparent: true
            });
            
            const startText = new THREE.Mesh(
                new THREE.PlaneGeometry(12, 3),
                startTextMat
            );
            startText.rotation.x = -Math.PI / 2;
            startText.position.set(0, 0.055, z - 10);
            startLineGroup.add(startText);
            
            // === TIRE MARKS from previous races (visual flavor) ===
            const tireMat = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.4,
                roughness: 0.9
            });
            
            // Burnout marks at start boxes
            [-5.5, 5.5].forEach(xPos => {
                const burnout = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.2, 8),
                    tireMat
                );
                burnout.rotation.x = -Math.PI / 2;
                burnout.position.set(xPos + 0.8, 0.025, z + 12);
                startLineGroup.add(burnout);
                
                const burnout2 = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.2, 8),
                    tireMat
                );
                burnout2.rotation.x = -Math.PI / 2;
                burnout2.position.set(xPos - 0.8, 0.025, z + 12);
                startLineGroup.add(burnout2);
            });
            
            startLineGroup.userData.type = 'startLine';
            startLineGroup.userData.baseX = 0;
            startLineGroup.userData.spawnCurve = roadCurve;
            scene.add(startLineGroup);
            scenery.push(startLineGroup);
            
            return startLineGroup;
        }
        
        // Track sections define curves, elevation, and feel
        // roadWidth: 24 = standard, 32 = wide highway, 16 = narrow mountain pass
        // surface: 'asphalt' (default), 'cobblestone', 'bridge'
        const trackSections = [
            { name: 'SEASIDE SPRINT', curve: 0.1, elevation: 0, bank: 5, length: 500, roadWidth: 28 },
            { name: 'LIGHTHOUSE BEND', curve: -0.8, elevation: 5, bank: 25, length: 300, landmark: 'lighthouse', roadWidth: 24 },
            { name: 'THE PLUNGE', curve: 0.4, elevation: -40, bank: 10, length: 400, roadWidth: 24 },
            { name: 'REDWOOD TUNNEL', curve: 0, elevation: 0, bank: 0, length: 200, landmark: 'redwood', roadWidth: 20 },
            { name: 'CHICANE', curve: 0.6, elevation: 0, bank: 18, length: 150, roadWidth: 24 },
            { name: 'CHICANE 2', curve: -0.7, elevation: 0, bank: 18, length: 150, roadWidth: 24 },
            { name: 'MOUNTAIN PASS', curve: -0.5, elevation: 15, bank: 20, length: 250, roadWidth: 16, surface: 'narrow' },
            { name: 'CLIFFHANGER S', curve: -0.9, elevation: -10, bank: 30, length: 300, roadWidth: 22 },
            { name: 'CLIFFHANGER S2', curve: 0.9, elevation: -10, bank: 30, length: 300, roadWidth: 22 },
            { name: 'WIDE HIGHWAY', curve: 0.15, elevation: 0, bank: 3, length: 400, roadWidth: 32 },
            { name: 'BRIDGE APPROACH', curve: 0.2, elevation: 10, bank: 5, length: 300, landmark: 'bridge', roadWidth: 26 },
            { name: 'SUSPENSION BRIDGE', curve: 0, elevation: 12, bank: 0, length: 400, surface: 'bridge', roadWidth: 26 },
            { name: 'LAUNCH RAMP', curve: 0, elevation: 15, bank: 35, length: 100, ramp: true, roadWidth: 24 },
            { name: 'BRIDGE BLAST', curve: 0, elevation: 0, bank: 0, length: 500, roadWidth: 28 },
            { name: 'ITALIAN VILLAGE', curve: -0.3, elevation: 0, bank: 8, length: 250, surface: 'cobblestone', roadWidth: 18 },
            { name: 'FINISH APPROACH', curve: -0.5, elevation: 0, bank: 20, length: 400, landmark: 'finish', roadWidth: 26 },
        ];
        
        // Note: currentRoadWidth, targetRoadWidth, currentSurface, targetSurface,
        // lastSegmentWidth, lastSegmentBanking, lastSegmentElevation are declared 
        // earlier with other global variables (around line 770).
        
        function spawnLandmark(type, x, y, z) {
            const landmark = new THREE.Group();
            
            if (type === 'lighthouse') {
                // White lighthouse tower
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 4, 25, 12),
                    new THREE.MeshStandardMaterial({ color: 0xffffff })
                );
                tower.position.y = 12.5;
                tower.castShadow = true;
                landmark.add(tower);
                
                // Red stripes
                for (let i = 0; i < 3; i++) {
                    const stripe = new THREE.Mesh(
                        new THREE.CylinderGeometry(3.1, 3.5 - i * 0.3, 3, 12),
                        new THREE.MeshStandardMaterial({ color: 0xcc0000 })
                    );
                    stripe.position.y = 5 + i * 8;
                    landmark.add(stripe);
                }
                
                // Light housing
                const housing = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 2.5, 4, 8),
                    new THREE.MeshStandardMaterial({ color: 0x333333 })
                );
                housing.position.y = 27;
                landmark.add(housing);
                
                // Light beam
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(1.5, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffffaa })
                );
                light.position.y = 27;
                landmark.add(light);
                
                // Point light
                const pl = new THREE.PointLight(0xffffaa, 2, 100);
                pl.position.y = 27;
                landmark.add(pl);
                
            } else if (type === 'redwood') {
                // Giant hollow redwood tree tunnel
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a2810 });
                
                // Outer trunk
                const outer = new THREE.Mesh(
                    new THREE.CylinderGeometry(12, 14, 40, 12),
                    trunkMat
                );
                outer.position.y = 20;
                landmark.add(outer);
                
                // Hollow inside (dark)
                const inner = new THREE.Mesh(
                    new THREE.CylinderGeometry(8, 8, 42, 12),
                    new THREE.MeshStandardMaterial({ color: 0x1a0a00 })
                );
                inner.position.y = 20;
                landmark.add(inner);
                
                // Entrance arch
                const arch = new THREE.Mesh(
                    new THREE.TorusGeometry(8, 2, 8, 12, Math.PI),
                    trunkMat
                );
                arch.rotation.x = Math.PI / 2;
                arch.position.set(0, 8, 8);
                landmark.add(arch);
                
                // Foliage on top
                const foliage = new THREE.Mesh(
                    new THREE.SphereGeometry(18, 8, 8),
                    new THREE.MeshStandardMaterial({ color: 0x1a4a1a })
                );
                foliage.position.y = 45;
                landmark.add(foliage);
                
            } else if (type === 'bridge') {
                // Golden Gate style bridge tower
                const towerMat = new THREE.MeshStandardMaterial({ color: 0xcc4400, metalness: 0.6 });
                
                // Twin towers
                [-10, 10].forEach(side => {
                    const tower = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 60, 4),
                        towerMat
                    );
                    tower.position.set(side, 30, 0);
                    tower.castShadow = true;
                    landmark.add(tower);
                });
                
                // Cross beams
                for (let h = 20; h <= 50; h += 15) {
                    const beam = new THREE.Mesh(
                        new THREE.BoxGeometry(24, 2, 3),
                        towerMat
                    );
                    beam.position.y = h;
                    landmark.add(beam);
                }
                
                // Cables
                const cableMat = new THREE.MeshStandardMaterial({ color: 0xcc4400 });
                [-8, 8].forEach(side => {
                    const cable = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 100, 8),
                        cableMat
                    );
                    cable.rotation.z = Math.PI / 6 * (side > 0 ? 1 : -1);
                    cable.position.set(side * 2, 40, 0);
                    landmark.add(cable);
                });
                
            } else if (type === 'finish') {
                // Neon finish arch
                const archMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                
                // Arch structure
                [-12, 12].forEach(side => {
                    const pole = new THREE.Mesh(
                        new THREE.BoxGeometry(1.5, 12, 1.5),
                        archMat
                    );
                    pole.position.set(side, 6, 0);
                    landmark.add(pole);
                });
                
                const topBar = new THREE.Mesh(
                    new THREE.BoxGeometry(26, 2, 2),
                    archMat
                );
                topBar.position.y = 12;
                landmark.add(topBar);
                
                // Neon "FINISH" lights
                const neonMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                const neon = new THREE.Mesh(
                    new THREE.BoxGeometry(20, 1.5, 0.5),
                    neonMat
                );
                neon.position.set(0, 11, 1.2);
                landmark.add(neon);
                
                // Checkered flags
                const flagMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                [-14, 14].forEach(side => {
                    const flag = new THREE.Mesh(
                        new THREE.PlaneGeometry(3, 4),
                        flagMat
                    );
                    flag.position.set(side, 10, 0.5);
                    landmark.add(flag);
                });
            }
            
            landmark.position.set(x, y, z);
            landmark.userData.type = type;
            scene.add(landmark);
            landmarks.push(landmark);
        }
        
        // CHECKPOINT GATE - Classic arcade overhead structure
        function createCheckpointGate(z, gateText = 'CHECKPOINT') {
            const gate = new THREE.Group();
            
            // Main support poles (red/white striped like racing)
            const poleMat = new THREE.MeshStandardMaterial({ color: 0xcc2222 });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            [-14, 14].forEach(side => {
                const poleGroup = new THREE.Group();
                
                // Main pole
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 1.0, 14, 12),
                    poleMat
                );
                pole.position.y = 7;
                pole.castShadow = true;
                poleGroup.add(pole);
                
                // White stripes on pole
                for (let i = 0; i < 4; i++) {
                    const stripe = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.85, 0.95 - i * 0.03, 1.5, 12),
                        whiteMat
                    );
                    stripe.position.y = 2 + i * 3;
                    poleGroup.add(stripe);
                }
                
                // Flag pole extending up
                const flagPole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.15, 8, 8),
                    darkMat
                );
                flagPole.position.y = 18;
                poleGroup.add(flagPole);
                
                // American flag
                const flagGroup = new THREE.Group();
                
                // Flag cloth (waving effect via geometry)
                const flagGeo = new THREE.PlaneGeometry(3, 2, 8, 4);
                const flagVerts = flagGeo.attributes.position.array;
                for (let i = 0; i < flagVerts.length; i += 3) {
                    const x = flagVerts[i];
                    flagVerts[i + 2] = Math.sin(x * 2) * 0.15; // Wave
                }
                flagGeo.computeVertexNormals();
                
                // USA flag colors (simplified stripes + blue canton)
                const flagCanvas = document.createElement('canvas');
                flagCanvas.width = 128;
                flagCanvas.height = 80;
                const fctx = flagCanvas.getContext('2d');
                
                // Red and white stripes
                for (let i = 0; i < 13; i++) {
                    fctx.fillStyle = i % 2 === 0 ? '#bf0a30' : '#ffffff';
                    fctx.fillRect(0, i * 6.15, 128, 6.15);
                }
                
                // Blue canton
                fctx.fillStyle = '#002868';
                fctx.fillRect(0, 0, 52, 43);
                
                // Stars (simplified)
                fctx.fillStyle = '#ffffff';
                for (let row = 0; row < 5; row++) {
                    for (let col = 0; col < 6; col++) {
                        fctx.beginPath();
                        fctx.arc(4 + col * 8, 4 + row * 8, 2, 0, Math.PI * 2);
                        fctx.fill();
                    }
                }
                
                const flagTex = new THREE.CanvasTexture(flagCanvas);
                const flagMat = new THREE.MeshStandardMaterial({ 
                    map: flagTex, 
                    side: THREE.DoubleSide,
                    roughness: 0.8
                });
                
                const flag = new THREE.Mesh(flagGeo, flagMat);
                flag.position.set(side > 0 ? -1.8 : 1.8, 20, 0);
                flag.rotation.y = side > 0 ? 0 : Math.PI;
                poleGroup.add(flag);
                
                poleGroup.position.x = side;
                gate.add(poleGroup);
            });
            
            // Overhead gantry (the horizontal beam)
            const gantryMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 });
            const gantry = new THREE.Mesh(
                new THREE.BoxGeometry(30, 2, 3),
                gantryMat
            );
            gantry.position.y = 14;
            gantry.castShadow = true;
            gate.add(gantry);
            
            // Gate sign (CHECKPOINT or START)
            const signCanvas = document.createElement('canvas');
            signCanvas.width = 512;
            signCanvas.height = 128;
            const sctx = signCanvas.getContext('2d');
            
            // Gradient background - different colors for START vs CHECKPOINT
            const grad = sctx.createLinearGradient(0, 0, 0, 128);
            if (gateText === 'START') {
                grad.addColorStop(0, '#00ff00');
                grad.addColorStop(0.5, '#00cc00');
                grad.addColorStop(1, '#008800');
            } else {
                grad.addColorStop(0, '#ffcc00');
                grad.addColorStop(0.5, '#ff8800');
                grad.addColorStop(1, '#ff4400');
            }
            sctx.fillStyle = grad;
            sctx.fillRect(0, 0, 512, 128);
            
            // Border
            sctx.strokeStyle = '#ffffff';
            sctx.lineWidth = 8;
            sctx.strokeRect(4, 4, 504, 120);
            
            // Text
            sctx.fillStyle = '#ffffff';
            const fontSize = gateText.length > 8 ? 72 : 85;
            sctx.font = `bold ${fontSize}px Arial Black, Impact, sans-serif`;
            sctx.textAlign = 'center';
            sctx.textBaseline = 'middle';
            sctx.shadowColor = '#000000';
            sctx.shadowBlur = 8;
            sctx.shadowOffsetX = 4;
            sctx.shadowOffsetY = 4;
            sctx.fillText(gateText, 256, 64);
            
            const signTex = new THREE.CanvasTexture(signCanvas);
            const signMat = new THREE.MeshBasicMaterial({ map: signTex });
            
            const sign = new THREE.Mesh(
                new THREE.PlaneGeometry(20, 5),
                signMat
            );
            sign.position.set(0, 14, 1.6);
            gate.add(sign);
            
            // Back of sign (so it's visible from both sides)
            const signBack = sign.clone();
            signBack.rotation.y = Math.PI;
            signBack.position.z = -1.6;
            gate.add(signBack);
            
            // Traffic lights (3 on each side of center)
            const lightHousingMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const isStart = gateText === 'START';
            
            [-6, 0, 6].forEach(xPos => {
                const lightHousing = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 3.5, 1.2),
                    lightHousingMat
                );
                lightHousing.position.set(xPos, 10, 0);
                gate.add(lightHousing);
                
                // Red light (top) - off for start, on for checkpoint
                const redLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 16, 16),
                    new THREE.MeshBasicMaterial({ color: isStart ? 0x330000 : 0xff0000 })
                );
                redLight.position.set(xPos, 11, 0.6);
                gate.add(redLight);
                
                // Yellow light (middle) - on for checkpoint (caution ahead!)
                const yellowLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 16, 16),
                    new THREE.MeshBasicMaterial({ color: isStart ? 0x332200 : 0xffcc00 })
                );
                yellowLight.position.set(xPos, 10, 0.6);
                gate.add(yellowLight);
                
                // Green light (bottom) - always lit!
                const greenLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                greenLight.position.set(xPos, 9, 0.6);
                gate.add(greenLight);
                
                // Glow effect for green
                const glowLight = new THREE.PointLight(0x00ff00, 0.5, 10);
                glowLight.position.set(xPos, 9, 1);
                gate.add(glowLight);
                
                // Extra glow for checkpoint yellow
                if (!isStart) {
                    const yellowGlow = new THREE.PointLight(0xffcc00, 0.3, 8);
                    yellowGlow.position.set(xPos, 10, 1);
                    gate.add(yellowGlow);
                }
            });
            
            // Checkered banner strips at top
            const checkerCanvas = document.createElement('canvas');
            checkerCanvas.width = 256;
            checkerCanvas.height = 32;
            const cctx = checkerCanvas.getContext('2d');
            for (let x = 0; x < 32; x++) {
                for (let y = 0; y < 4; y++) {
                    cctx.fillStyle = (x + y) % 2 === 0 ? '#000000' : '#ffffff';
                    cctx.fillRect(x * 8, y * 8, 8, 8);
                }
            }
            const checkerTex = new THREE.CanvasTexture(checkerCanvas);
            checkerTex.wrapS = THREE.RepeatWrapping;
            const checkerMat = new THREE.MeshBasicMaterial({ map: checkerTex });
            
            const checker = new THREE.Mesh(
                new THREE.PlaneGeometry(28, 1.5),
                checkerMat
            );
            checker.position.set(0, 15.5, 1.55);
            gate.add(checker);
            
            gate.position.set(0, 0, z);
            gate.userData.baseX = 0;
            scene.add(gate);
            checkpointGates.push(gate);
            
            return gate;
        }
        
        // Background mountains for depth and atmosphere
        function createBackgroundMountains() {
            // Clear old mountains (with disposal to prevent memory leaks)
            backgroundMountains.forEach(m => removeAndDispose(m));
            backgroundMountains = [];
            
            const c = countries[currentCountry];
            
            // Determine mountain colors based on country
            let mountainColor, snowColor, hazeColor;
            
            if (c.sceneryType === 'desert' || c.sceneryType === 'outback') {
                mountainColor = 0x8b6914;
                snowColor = null; // No snow
                hazeColor = 0xdaa520;
            } else if (c.sceneryType === 'dubai') {
                mountainColor = 0x2a3a4a;
                snowColor = null;
                hazeColor = 0x1a2a3a;
            } else if (c.sceneryType === 'tropical') {
                mountainColor = 0x2d5a2d;
                snowColor = null;
                hazeColor = 0x4a8a4a;
            } else {
                mountainColor = 0x4a5568;
                snowColor = 0xffffff;
                hazeColor = 0x8899aa;
            }
            
            // Create layered mountain ranges (back to front for depth)
            const ranges = [
                { distance: -400, count: 8, scale: 2.5, opacity: 0.3 },  // Furthest, haziest
                { distance: -300, count: 6, scale: 1.8, opacity: 0.5 },
                { distance: -220, count: 5, scale: 1.3, opacity: 0.7 },  // Closest background
            ];
            
            ranges.forEach(range => {
                const mountainMat = new THREE.MeshStandardMaterial({ 
                    color: mountainColor,
                    transparent: true,
                    opacity: range.opacity,
                    flatShading: true
                });
                
                for (let i = 0; i < range.count; i++) {
                    const mountainGroup = new THREE.Group();
                    
                    // Random mountain shape
                    const height = (30 + Math.random() * 50) * range.scale;
                    const width = (20 + Math.random() * 30) * range.scale;
                    
                    // Main peak
                    const peak = new THREE.Mesh(
                        new THREE.ConeGeometry(width, height, 6 + Math.floor(Math.random() * 4)),
                        mountainMat
                    );
                    peak.position.y = height / 2;
                    peak.rotation.y = Math.random() * Math.PI;
                    mountainGroup.add(peak);
                    
                    // Snow cap on taller mountains
                    if (snowColor && height > 60 * range.scale) {
                        const snowMat = new THREE.MeshStandardMaterial({
                            color: snowColor,
                            transparent: true,
                            opacity: range.opacity
                        });
                        const snowHeight = height * 0.3;
                        const snowCap = new THREE.Mesh(
                            new THREE.ConeGeometry(width * 0.4, snowHeight, 6),
                            snowMat
                        );
                        snowCap.position.y = height - snowHeight / 2;
                        mountainGroup.add(snowCap);
                    }
                    
                    // Secondary smaller peaks
                    if (Math.random() > 0.4) {
                        const secondHeight = height * (0.5 + Math.random() * 0.3);
                        const second = new THREE.Mesh(
                            new THREE.ConeGeometry(width * 0.6, secondHeight, 5),
                            mountainMat
                        );
                        second.position.set(
                            (Math.random() - 0.5) * width * 1.5,
                            secondHeight / 2,
                            (Math.random() - 0.5) * 10
                        );
                        mountainGroup.add(second);
                    }
                    
                    // Position along the horizon
                    const spreadX = 500 * range.scale;
                    mountainGroup.position.set(
                        (i - range.count / 2) * (spreadX / range.count) + (Math.random() - 0.5) * 50,
                        -5,
                        range.distance + (Math.random() - 0.5) * 30
                    );
                    mountainGroup.userData.baseX = mountainGroup.position.x;
                    
                    scene.add(mountainGroup);
                    backgroundMountains.push(mountainGroup);
                }
            });
            
            // Add rocky hills closer to the road for desert/outback
            if (c.sceneryType === 'desert' || c.sceneryType === 'outback') {
                const hillMat = new THREE.MeshStandardMaterial({
                    color: c.sceneryType === 'desert' ? 0xc4a35a : 0xb8860b,
                    flatShading: true
                });
                
                for (let i = 0; i < 12; i++) {
                    const hillGroup = new THREE.Group();
                    const hillHeight = 8 + Math.random() * 15;
                    
                    // Mesa/butte shape
                    const hill = new THREE.Mesh(
                        new THREE.CylinderGeometry(
                            5 + Math.random() * 8, // Top
                            8 + Math.random() * 12, // Bottom
                            hillHeight,
                            6 + Math.floor(Math.random() * 3)
                        ),
                        hillMat
                    );
                    hill.position.y = hillHeight / 2;
                    hillGroup.add(hill);
                    
                    // Position on both sides of road
                    const side = i % 2 === 0 ? -1 : 1;
                    hillGroup.position.set(
                        side * (50 + Math.random() * 80),
                        0,
                        -100 - Math.random() * 200
                    );
                    hillGroup.userData.baseX = hillGroup.position.x;
                    
                    scene.add(hillGroup);
                    backgroundMountains.push(hillGroup);
                }
            }
            
            // Add distant city silhouettes for urban countries
            createCitySilhouettes();
        }
        
        // Distant city skyline silhouettes on the horizon
        function createCitySilhouettes() {
            // Clear old silhouettes (with disposal to prevent memory leaks)
            citySilhouettes.forEach(s => removeAndDispose(s));
            citySilhouettes = [];
            
            const c = countries[currentCountry];
            
            // Only add cities for urban country types
            const urbanCountries = ['tokyo', 'dubai', 'european', 'british', 'mediterranean'];
            if (!urbanCountries.includes(c.sceneryType)) return;
            
            // City colors based on time of day (ambient)
            let buildingColor, windowColor;
            if (c.sceneryType === 'dubai') {
                buildingColor = 0x1a2a3a; // Dark blue silhouette
                windowColor = 0xffffaa;   // Warm lights
            } else if (c.sceneryType === 'tokyo') {
                buildingColor = 0x2a3a4a;
                windowColor = 0xffffff;
            } else {
                buildingColor = 0x3a4a5a;
                windowColor = 0xffeecc;
            }
            
            const cityGroup = new THREE.Group();
            
            // Create a row of buildings on the distant horizon
            const buildingMat = new THREE.MeshBasicMaterial({ 
                color: buildingColor,
                transparent: true,
                opacity: 0.4
            });
            
            // Span buildings across the horizon
            for (let i = 0; i < 25; i++) {
                const height = 15 + Math.random() * 60;
                const width = 3 + Math.random() * 8;
                const depth = 3 + Math.random() * 5;
                
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    buildingMat
                );
                
                // Spread across horizon
                const xPos = (i - 12) * 25 + (Math.random() - 0.5) * 15;
                building.position.set(xPos, height / 2, -450);
                cityGroup.add(building);
                
                // Add glowing windows (sparse, for silhouette effect)
                if (Math.random() > 0.3) {
                    const windowMat = new THREE.MeshBasicMaterial({ color: windowColor });
                    const windowsPerFloor = Math.floor(width / 2);
                    const floors = Math.floor(height / 4);
                    
                    for (let f = 0; f < floors; f++) {
                        for (let w = 0; w < windowsPerFloor; w++) {
                            if (Math.random() > 0.5) {
                                const win = new THREE.Mesh(
                                    new THREE.PlaneGeometry(0.8, 1.2),
                                    windowMat
                                );
                                win.position.set(
                                    xPos + (w - windowsPerFloor/2) * 2,
                                    2 + f * 4,
                                    -449.5
                                );
                                cityGroup.add(win);
                            }
                        }
                    }
                }
            }
            
            // Add iconic spire for Dubai (Burj Khalifa silhouette)
            if (c.sceneryType === 'dubai') {
                const spireGroup = new THREE.Group();
                const spireMat = new THREE.MeshBasicMaterial({ color: 0x1a2a3a, transparent: true, opacity: 0.5 });
                
                // Tapered tower sections
                const sections = [
                    { bottom: 20, top: 18, height: 40 },
                    { bottom: 18, top: 14, height: 35 },
                    { bottom: 14, top: 10, height: 30 },
                    { bottom: 10, top: 6, height: 25 },
                    { bottom: 6, top: 2, height: 20 },
                    { bottom: 2, top: 0.5, height: 15 },
                ];
                let y = 0;
                sections.forEach(s => {
                    const section = new THREE.Mesh(
                        new THREE.CylinderGeometry(s.top, s.bottom, s.height, 6),
                        spireMat
                    );
                    section.position.y = y + s.height / 2;
                    spireGroup.add(section);
                    y += s.height;
                });
                
                spireGroup.position.set(80, 0, -480);
                cityGroup.add(spireGroup);
            }
            
            // Add Tokyo Tower silhouette
            if (c.sceneryType === 'tokyo') {
                const towerMat = new THREE.MeshBasicMaterial({ color: 0x662200, transparent: true, opacity: 0.6 });
                const tower = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 12, 80, 4),
                    towerMat
                );
                tower.position.set(-60, 40, -470);
                cityGroup.add(tower);
            }
            
            scene.add(cityGroup);
            citySilhouettes.push(cityGroup);
        }
        
        // Weather/atmosphere particle system
        function createWeatherParticles() {
            // Clear old particles (with disposal to prevent memory leaks)
            weatherParticles.forEach(p => removeAndDispose(p));
            weatherParticles = [];
            
            const c = countries[currentCountry];
            
            // Define weather type based on country
            let particleType = null;
            let particleCount = 0;
            let particleColor = 0xffffff;
            let particleSize = 0.1;
            let particleSpeed = { x: 0, y: -2, z: 0 };
            
            if (c.sceneryType === 'desert' || c.sceneryType === 'outback') {
                particleType = 'dust';
                particleCount = 80;
                particleColor = c.sceneryType === 'desert' ? 0xdaa520 : 0xc4a35a;
                particleSize = 0.15;
                particleSpeed = { x: 3, y: 0.5, z: 0 }; // Blowing horizontally
            } else if (c.sceneryType === 'british') {
                particleType = 'rain';
                particleCount = 150;
                particleColor = 0xaaccff;
                particleSize = 0.05;
                particleSpeed = { x: -1, y: -15, z: 0 }; // Fast falling rain
            } else if (c.sceneryType === 'tokyo') {
                particleType = 'sakura';
                particleCount = 60;
                particleColor = 0xffccdd;
                particleSize = 0.2;
                particleSpeed = { x: 1.5, y: -1, z: 0.5 }; // Gentle drifting
            } else if (c.sceneryType === 'dubai') {
                // UAE desert night - subtle sand haze with warm glow
                particleType = 'haze';
                particleCount = 50;
                particleColor = 0xd4a84a;
                particleSize = 0.25;
                particleSpeed = { x: 0.5, y: 0.1, z: 0 }; // Gentle drift
            } else if (c.sceneryType === 'mediterranean') {
                // Italian countryside - warm golden pollen/dust motes
                particleType = 'pollen';
                particleCount = 40;
                particleColor = 0xffffcc;
                particleSize = 0.1;
                particleSpeed = { x: 0.8, y: 0.3, z: 0.2 }; // Lazy floating
            } else if (c.sceneryType === 'american') {
                // California coast - sea mist/spray
                particleType = 'mist';
                particleCount = 35;
                particleColor = 0xccddff;
                particleSize = 0.2;
                particleSpeed = { x: 2, y: 0.2, z: 0 }; // Coastal breeze
            } else if (c.sceneryType === 'european') {
                // German autobahn - morning fog wisps
                particleType = 'fog';
                particleCount = 45;
                particleColor = 0xddddee;
                particleSize = 0.3;
                particleSpeed = { x: 0.3, y: -0.1, z: 0 }; // Low-hanging drift
            } else if (c.sceneryType === 'tropical') {
                // Brazilian humidity - warm tropical haze
                particleType = 'humidity';
                particleCount = 40;
                particleColor = 0xaaffaa;
                particleSize = 0.18;
                particleSpeed = { x: 0.5, y: 0.4, z: 0.3 }; // Rising humidity
            }
            
            if (!particleType || particleCount === 0) return;
            
            // Create particle geometry (use points for performance)
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = []; // Store individual velocities
            
            for (let i = 0; i < particleCount; i++) {
                // Spread particles in a box around the camera
                positions[i * 3] = (Math.random() - 0.5) * 60;     // X
                // Y height varies by particle type
                if (particleType === 'fog' || particleType === 'mist') {
                    positions[i * 3 + 1] = 2 + Math.random() * 8; // Low-hanging fog/mist
                } else if (particleType === 'humidity') {
                    positions[i * 3 + 1] = 1 + Math.random() * 12; // Ground to mid level
                } else if (particleType === 'rain') {
                    positions[i * 3 + 1] = Math.random() * 30; // Full height
                } else {
                    positions[i * 3 + 1] = 5 + Math.random() * 20; // Mid to high (dust, pollen, etc)
                }
                positions[i * 3 + 2] = (Math.random() - 0.5) * 80 - 20; // Z (ahead of player)
                
                // Random velocity variation
                velocities.push({
                    x: particleSpeed.x * (0.8 + Math.random() * 0.4),
                    y: particleSpeed.y * (0.8 + Math.random() * 0.4),
                    z: particleSpeed.z * (0.8 + Math.random() * 0.4)
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Material based on particle type
            let material;
            if (particleType === 'rain') {
                // Rain uses stretched particles (lines)
                material = new THREE.PointsMaterial({
                    color: particleColor,
                    size: particleSize,
                    transparent: true,
                    opacity: 0.6,
                    sizeAttenuation: true
                });
            } else {
                material = new THREE.PointsMaterial({
                    color: particleColor,
                    size: particleSize,
                    transparent: true,
                    opacity: particleType === 'dust' ? 0.4 : 0.7,
                    sizeAttenuation: true
                });
            }
            
            const points = new THREE.Points(geometry, material);
            points.userData.velocities = velocities;
            points.userData.particleType = particleType;
            points.userData.baseSpeed = particleSpeed;
            
            scene.add(points);
            weatherParticles.push(points);
        }
        
        // Update weather particles each frame
        function updateWeatherParticles(delta) {
            weatherParticles.forEach(points => {
                const positions = points.geometry.attributes.position.array;
                const velocities = points.userData.velocities;
                const type = points.userData.particleType;
                
                for (let i = 0; i < velocities.length; i++) {
                    const idx = i * 3;
                    
                    // Move particle
                    positions[idx] += velocities[i].x * delta;
                    positions[idx + 1] += velocities[i].y * delta;
                    positions[idx + 2] += velocities[i].z * delta;
                    
                    // Add swirl for sakura
                    if (type === 'sakura') {
                        positions[idx] += Math.sin(Date.now() * 0.001 + i) * delta * 2;
                        positions[idx + 2] += Math.cos(Date.now() * 0.001 + i) * delta;
                    }
                    
                    // Gentle swirl for pollen/haze particles (floating motes)
                    if (type === 'pollen' || type === 'haze' || type === 'humidity') {
                        positions[idx] += Math.sin(Date.now() * 0.0008 + i * 0.5) * delta * 0.8;
                        positions[idx + 1] += Math.sin(Date.now() * 0.001 + i) * delta * 0.3;
                        positions[idx + 2] += Math.cos(Date.now() * 0.0006 + i * 0.7) * delta * 0.5;
                    }
                    
                    // Fog wisps - horizontal drift with occasional lift
                    if (type === 'fog' || type === 'mist') {
                        positions[idx] += Math.sin(Date.now() * 0.0005 + i) * delta * 1.2;
                        positions[idx + 1] += Math.sin(Date.now() * 0.002 + i * 0.3) * delta * 0.15;
                    }
                    
                    // Reset particles that go out of bounds
                    if (positions[idx + 1] < 0 || positions[idx + 1] > 35) {
                        positions[idx] = playerCar ? playerCar.position.x + (Math.random() - 0.5) * 60 : (Math.random() - 0.5) * 60;
                        // Different reset heights based on particle type
                        if (type === 'rain') {
                            positions[idx + 1] = 30;
                        } else if (type === 'fog' || type === 'mist') {
                            positions[idx + 1] = 2 + Math.random() * 8; // Low-hanging
                        } else if (type === 'humidity') {
                            positions[idx + 1] = 1 + Math.random() * 12; // Ground to mid level
                        } else {
                            positions[idx + 1] = 15 + Math.random() * 15;
                        }
                        positions[idx + 2] = playerCar ? playerCar.position.z - 20 - Math.random() * 60 : -20 - Math.random() * 60;
                    }
                    
                    // Keep particles near camera (Z bounds)
                    if (playerCar && (positions[idx + 2] > playerCar.position.z + 20 || positions[idx + 2] < playerCar.position.z - 100)) {
                        positions[idx + 2] = playerCar.position.z - 20 - Math.random() * 60;
                    }
                }
                
                points.geometry.attributes.position.needsUpdate = true;
            });
        }
        
        // Create iconic country landmark (torii gate, pyramid, etc.)
        function createIconicLandmark(countryType) {
            const group = new THREE.Group();
            
            if (countryType === 'tokyo') {
                // Japanese Torii Gate - iconic red shrine gate
                const toriiRed = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.7 });
                const toriiBlack = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
                
                // Main vertical pillars
                [-4, 4].forEach(x => {
                    const pillar = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.6, 12, 12),
                        toriiRed
                    );
                    pillar.position.set(x, 6, 0);
                    pillar.castShadow = true;
                    group.add(pillar);
                    
                    // Black base
                    const base = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.8, 0.9, 0.5, 12),
                        toriiBlack
                    );
                    base.position.set(x, 0.25, 0);
                    group.add(base);
                });
                
                // Top beam (kasagi) - curved
                const topBeamShape = new THREE.Shape();
                topBeamShape.moveTo(-6, 0);
                topBeamShape.quadraticCurveTo(0, 1, 6, 0);
                topBeamShape.lineTo(6, -0.6);
                topBeamShape.quadraticCurveTo(0, 0.2, -6, -0.6);
                topBeamShape.lineTo(-6, 0);
                
                const topBeamGeo = new THREE.ExtrudeGeometry(topBeamShape, {
                    steps: 1, depth: 1.2, bevelEnabled: false
                });
                const topBeam = new THREE.Mesh(topBeamGeo, toriiBlack);
                topBeam.rotation.x = Math.PI / 2;
                topBeam.position.set(0, 12, 0.6);
                group.add(topBeam);
                
                // Secondary beam (nuki)
                const nuki = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 0.5, 0.6),
                    toriiRed
                );
                nuki.position.set(0, 10.5, 0);
                group.add(nuki);
                
            } else if (countryType === 'desert') {
                // Egyptian Pyramid
                const sandMat = new THREE.MeshStandardMaterial({ 
                    color: 0xd4a857, 
                    roughness: 0.9,
                    flatShading: true
                });
                
                // Main pyramid
                const pyramid = new THREE.Mesh(
                    new THREE.ConeGeometry(25, 35, 4),
                    sandMat
                );
                pyramid.rotation.y = Math.PI / 4; // Align edges
                pyramid.position.y = 17.5;
                pyramid.castShadow = true;
                group.add(pyramid);
                
                // Smaller secondary pyramid
                const pyramid2 = new THREE.Mesh(
                    new THREE.ConeGeometry(12, 18, 4),
                    sandMat
                );
                pyramid2.rotation.y = Math.PI / 4;
                pyramid2.position.set(30, 9, 15);
                group.add(pyramid2);
                
                // Sphinx silhouette (simplified)
                const sphinxBody = new THREE.Mesh(
                    new THREE.BoxGeometry(15, 5, 6),
                    sandMat
                );
                sphinxBody.position.set(-20, 2.5, 10);
                group.add(sphinxBody);
                
                const sphinxHead = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 6, 4),
                    sandMat
                );
                sphinxHead.position.set(-27, 6, 10);
                group.add(sphinxHead);
                
            } else if (countryType === 'mediterranean') {
                // Italian Colosseum / Roman ruins
                const stoneMat = new THREE.MeshStandardMaterial({ 
                    color: 0xd4c4a8, 
                    roughness: 0.9,
                    flatShading: true
                });
                
                // Colosseum arches (simplified elliptical structure)
                const archCount = 12;
                for (let i = 0; i < archCount; i++) {
                    const angle = (i / archCount) * Math.PI * 2;
                    const radius = 20;
                    
                    // Column
                    const column = new THREE.Mesh(
                        new THREE.CylinderGeometry(1, 1.2, 15, 8),
                        stoneMat
                    );
                    column.position.set(
                        Math.cos(angle) * radius,
                        7.5,
                        Math.sin(angle) * radius
                    );
                    column.castShadow = true;
                    group.add(column);
                    
                    // Partial wall between columns
                    if (i % 2 === 0) {
                        const wall = new THREE.Mesh(
                            new THREE.BoxGeometry(2, 10, 5),
                            stoneMat
                        );
                        wall.position.set(
                            Math.cos(angle) * (radius - 2),
                            5,
                            Math.sin(angle) * (radius - 2)
                        );
                        wall.rotation.y = angle;
                        group.add(wall);
                    }
                }
                
            } else if (countryType === 'british') {
                // Stonehenge
                const stoneMat = new THREE.MeshStandardMaterial({ 
                    color: 0x7a7a6a, 
                    roughness: 1.0,
                    flatShading: true
                });
                
                // Standing stones in circle
                const stoneCount = 8;
                for (let i = 0; i < stoneCount; i++) {
                    const angle = (i / stoneCount) * Math.PI * 2;
                    const radius = 8;
                    
                    const stone = new THREE.Mesh(
                        new THREE.BoxGeometry(2 + Math.random(), 6 + Math.random() * 3, 1.5),
                        stoneMat
                    );
                    stone.position.set(
                        Math.cos(angle) * radius,
                        4,
                        Math.sin(angle) * radius
                    );
                    stone.rotation.y = angle + Math.random() * 0.2;
                    stone.rotation.z = (Math.random() - 0.5) * 0.1; // Slight lean
                    stone.castShadow = true;
                    group.add(stone);
                }
                
                // Lintels on top (connecting stones)
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const lintel = new THREE.Mesh(
                        new THREE.BoxGeometry(6, 1.5, 2),
                        stoneMat
                    );
                    lintel.position.set(
                        Math.cos(angle) * 8,
                        8,
                        Math.sin(angle) * 8
                    );
                    lintel.rotation.y = angle;
                    group.add(lintel);
                }
                
            } else if (countryType === 'tropical') {
                // Christ the Redeemer silhouette (Rio)
                const whiteMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.6 });
                
                // Body/robe
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(2, 4, 18, 8),
                    whiteMat
                );
                body.position.y = 9;
                body.castShadow = true;
                group.add(body);
                
                // Arms outstretched
                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(28, 2, 2),
                    whiteMat
                );
                arm.position.y = 16;
                arm.castShadow = true;
                group.add(arm);
                
                // Head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 12, 12),
                    whiteMat
                );
                head.position.y = 20;
                group.add(head);
                
                // Pedestal
                const pedestal = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 4, 8),
                    new THREE.MeshStandardMaterial({ color: 0x666666 })
                );
                pedestal.position.y = -2;
                group.add(pedestal);
                
            } else if (countryType === 'outback') {
                // Uluru (Ayers Rock) - iconic Australian landmark
                const rockMat = new THREE.MeshStandardMaterial({ 
                    color: 0xb84c28, // Red-orange sandstone
                    roughness: 0.95,
                    flatShading: true
                });
                
                // Main monolith - distinctive rounded rectangular shape
                const uluruWidth = 40;
                const uluruHeight = 18;
                const uluruDepth = 25;
                
                // Base shape using rounded box approximation with multiple geometries
                const mainBody = new THREE.Mesh(
                    new THREE.BoxGeometry(uluruWidth, uluruHeight, uluruDepth),
                    rockMat
                );
                mainBody.position.y = uluruHeight / 2;
                mainBody.castShadow = true;
                group.add(mainBody);
                
                // Rounded top sections
                const topCap = new THREE.Mesh(
                    new THREE.SphereGeometry(uluruWidth / 2.5, 8, 6, 0, Math.PI * 2, 0, Math.PI / 2),
                    rockMat
                );
                topCap.scale.set(1, 0.3, 0.6);
                topCap.position.y = uluruHeight;
                group.add(topCap);
                
                // Side bulges for organic shape
                [-1, 1].forEach(side => {
                    const bulge = new THREE.Mesh(
                        new THREE.SphereGeometry(8, 8, 6),
                        rockMat
                    );
                    bulge.scale.set(1, 0.5, 1.2);
                    bulge.position.set(side * uluruWidth * 0.35, uluruHeight * 0.4, 0);
                    group.add(bulge);
                });
                
                // Erosion grooves (darker vertical lines)
                const grooveMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8a3820, 
                    roughness: 1 
                });
                for (let i = 0; i < 5; i++) {
                    const groove = new THREE.Mesh(
                        new THREE.BoxGeometry(1, uluruHeight * 0.8, 0.5),
                        grooveMat
                    );
                    groove.position.set(
                        (i - 2) * 6,
                        uluruHeight * 0.5,
                        uluruDepth / 2 + 0.3
                    );
                    group.add(groove);
                }
                
            } else if (countryType === 'american') {
                // Golden Gate Bridge tower
                const redMat = new THREE.MeshStandardMaterial({ color: 0xc94433, roughness: 0.6 });
                
                // Two towers
                [-6, 6].forEach(x => {
                    const tower = new THREE.Mesh(
                        new THREE.BoxGeometry(3, 40, 3),
                        redMat
                    );
                    tower.position.set(x, 20, 0);
                    tower.castShadow = true;
                    group.add(tower);
                    
                    // Cross beam
                    const cross = new THREE.Mesh(
                        new THREE.BoxGeometry(4, 2, 3),
                        redMat
                    );
                    cross.position.set(x, 35, 0);
                    group.add(cross);
                });
                
                // Top span
                const span = new THREE.Mesh(
                    new THREE.BoxGeometry(18, 1.5, 3),
                    redMat
                );
                span.position.y = 38;
                group.add(span);
                
                // Cables (simplified)
                const cableMat = new THREE.MeshStandardMaterial({ color: 0x994433 });
                const cableCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(-8, 38, 0),
                    new THREE.Vector3(0, 30, 0),
                    new THREE.Vector3(8, 38, 0)
                ]);
                const cableGeo = new THREE.TubeGeometry(cableCurve, 20, 0.3, 8, false);
                const cable = new THREE.Mesh(cableGeo, cableMat);
                group.add(cable);
                
            } else if (countryType === 'european') {
                // Neuschwanstein-style German Castle - fairy tale castle
                const stoneMat = new THREE.MeshStandardMaterial({ 
                    color: 0xe8e4dc, // Light cream/white stone
                    roughness: 0.85,
                    flatShading: true
                });
                const roofMat = new THREE.MeshStandardMaterial({ 
                    color: 0x2a4a6a, // Slate blue roof
                    roughness: 0.6
                });
                const redRoofMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8b3a3a, // Burgundy accents
                    roughness: 0.7
                });
                
                // Main keep (central tower)
                const mainKeep = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 25, 10),
                    stoneMat
                );
                mainKeep.position.y = 12.5;
                mainKeep.castShadow = true;
                group.add(mainKeep);
                
                // Main tower roof (steep, conical)
                const mainRoof = new THREE.Mesh(
                    new THREE.ConeGeometry(7, 12, 6),
                    roofMat
                );
                mainRoof.position.y = 31;
                group.add(mainRoof);
                
                // Corner turrets
                const turretPositions = [[-5, -5], [-5, 5], [5, -5], [5, 5]];
                turretPositions.forEach(([x, z]) => {
                    const turret = new THREE.Mesh(
                        new THREE.CylinderGeometry(2, 2.5, 20, 8),
                        stoneMat
                    );
                    turret.position.set(x, 10, z);
                    turret.castShadow = true;
                    group.add(turret);
                    
                    // Turret conical roof
                    const turretRoof = new THREE.Mesh(
                        new THREE.ConeGeometry(3, 6, 8),
                        roofMat
                    );
                    turretRoof.position.set(x, 23, z);
                    group.add(turretRoof);
                });
                
                // Front wing (lower building with red roof)
                const frontWing = new THREE.Mesh(
                    new THREE.BoxGeometry(16, 12, 6),
                    stoneMat
                );
                frontWing.position.set(0, 6, 10);
                group.add(frontWing);
                
                // Front wing roof
                const frontRoofShape = new THREE.Shape();
                frontRoofShape.moveTo(-9, 0);
                frontRoofShape.lineTo(0, 6);
                frontRoofShape.lineTo(9, 0);
                frontRoofShape.lineTo(-9, 0);
                
                const frontRoofGeo = new THREE.ExtrudeGeometry(frontRoofShape, {
                    steps: 1, depth: 7, bevelEnabled: false
                });
                const frontRoof = new THREE.Mesh(frontRoofGeo, redRoofMat);
                frontRoof.rotation.x = Math.PI / 2;
                frontRoof.position.set(0, 12, 6.5);
                group.add(frontRoof);
                
                // Bridge/walkway
                const bridge = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 1.5, 12),
                    stoneMat
                );
                bridge.position.set(8, 8, 4);
                group.add(bridge);
                
                // Secondary tall tower (iconic spire)
                const spireTower = new THREE.Mesh(
                    new THREE.CylinderGeometry(3, 4, 35, 8),
                    stoneMat
                );
                spireTower.position.set(-12, 17.5, 0);
                spireTower.castShadow = true;
                group.add(spireTower);
                
                // Spire roof (very tall and thin)
                const spireRoof = new THREE.Mesh(
                    new THREE.ConeGeometry(4, 15, 8),
                    roofMat
                );
                spireRoof.position.set(-12, 42, 0);
                group.add(spireRoof);
                
                // Window details (dark recesses)
                const windowMat = new THREE.MeshStandardMaterial({ color: 0x223344 });
                for (let y = 8; y < 22; y += 5) {
                    for (let x = -3; x <= 3; x += 3) {
                        const win = new THREE.Mesh(
                            new THREE.BoxGeometry(1.5, 2.5, 0.5),
                            windowMat
                        );
                        win.position.set(x, y, 5.3);
                        group.add(win);
                    }
                }
                
            } else if (countryType === 'dubai') {
                // Modern Mosque with minaret - UAE landmark
                const whiteMat = new THREE.MeshStandardMaterial({ 
                    color: 0xf5f5f0, 
                    roughness: 0.4,
                    metalness: 0.1
                });
                const goldMat = new THREE.MeshStandardMaterial({ 
                    color: 0xd4af37, 
                    roughness: 0.3,
                    metalness: 0.6
                });
                const domeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.25,
                    metalness: 0.2
                });
                
                // Main building (prayer hall base)
                const mainHall = new THREE.Mesh(
                    new THREE.BoxGeometry(25, 10, 20),
                    whiteMat
                );
                mainHall.position.y = 5;
                mainHall.castShadow = true;
                group.add(mainHall);
                
                // Central dome
                const mainDome = new THREE.Mesh(
                    new THREE.SphereGeometry(10, 24, 16, 0, Math.PI * 2, 0, Math.PI / 2),
                    domeMat
                );
                mainDome.position.y = 10;
                mainDome.castShadow = true;
                group.add(mainDome);
                
                // Dome finial (gold crescent)
                const finialBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.5, 2, 12),
                    goldMat
                );
                finialBase.position.y = 20;
                group.add(finialBase);
                
                // Crescent moon
                const crescentShape = new THREE.Shape();
                crescentShape.absarc(0, 0, 1.5, 0, Math.PI * 2, false);
                const crescentHole = new THREE.Path();
                crescentHole.absarc(0.5, 0, 1.2, 0, Math.PI * 2, true);
                crescentShape.holes.push(crescentHole);
                
                const crescentGeo = new THREE.ExtrudeGeometry(crescentShape, {
                    steps: 1, depth: 0.3, bevelEnabled: false
                });
                const crescent = new THREE.Mesh(crescentGeo, goldMat);
                crescent.rotation.x = Math.PI / 2;
                crescent.position.set(-0.3, 22, 0);
                group.add(crescent);
                
                // Smaller domes (side domes)
                [-8, 8].forEach(x => {
                    const sideDome = new THREE.Mesh(
                        new THREE.SphereGeometry(4, 16, 12, 0, Math.PI * 2, 0, Math.PI / 2),
                        domeMat
                    );
                    sideDome.position.set(x, 10, 0);
                    group.add(sideDome);
                });
                
                // Minarets (tall towers at corners)
                const minaretPositions = [[-15, -12], [-15, 12], [15, -12], [15, 12]];
                minaretPositions.forEach(([x, z]) => {
                    // Minaret base
                    const minaretBase = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.8, 2.2, 25, 12),
                        whiteMat
                    );
                    minaretBase.position.set(x, 12.5, z);
                    minaretBase.castShadow = true;
                    group.add(minaretBase);
                    
                    // Minaret balcony
                    const balcony = new THREE.Mesh(
                        new THREE.CylinderGeometry(2.8, 2.5, 1.5, 12),
                        whiteMat
                    );
                    balcony.position.set(x, 22, z);
                    group.add(balcony);
                    
                    // Upper minaret section
                    const upperMinaret = new THREE.Mesh(
                        new THREE.CylinderGeometry(1.2, 1.5, 10, 12),
                        whiteMat
                    );
                    upperMinaret.position.set(x, 28, z);
                    group.add(upperMinaret);
                    
                    // Minaret top (pointed dome)
                    const minaretTop = new THREE.Mesh(
                        new THREE.ConeGeometry(1.5, 5, 12),
                        domeMat
                    );
                    minaretTop.position.set(x, 35.5, z);
                    group.add(minaretTop);
                    
                    // Gold finial on minaret
                    const mFinial = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 8, 8),
                        goldMat
                    );
                    mFinial.position.set(x, 38.5, z);
                    group.add(mFinial);
                });
                
                // Arched windows detail
                for (let i = -3; i <= 3; i++) {
                    if (i === 0) continue; // Skip center
                    const arch = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 4, 0.5),
                        new THREE.MeshStandardMaterial({ color: 0x336699 })
                    );
                    arch.position.set(i * 3.5, 6, 10.3);
                    group.add(arch);
                }
                
                // Courtyard pillars
                for (let x = -10; x <= 10; x += 5) {
                    const pillar = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.6, 6, 8),
                        whiteMat
                    );
                    pillar.position.set(x, 3, 12);
                    group.add(pillar);
                }
            }
            
            return group;
        }
        
        // Create animated windmill (for European countryside)
        function createWindmill() {
            const windmill = new THREE.Group();
            
            // Tower (stone/brick base)
            const towerMat = new THREE.MeshStandardMaterial({ 
                color: 0x8b7355, 
                roughness: 0.9,
                flatShading: true 
            });
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(2, 3.5, 15, 8),
                towerMat
            );
            tower.position.y = 7.5;
            tower.castShadow = true;
            windmill.add(tower);
            
            // Cap (roof)
            const capMat = new THREE.MeshStandardMaterial({ color: 0x4a3a2a, roughness: 0.8 });
            const cap = new THREE.Mesh(
                new THREE.ConeGeometry(3, 4, 8),
                capMat
            );
            cap.position.y = 17;
            windmill.add(cap);
            
            // Hub (where blades connect)
            const hubMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.3 });
            const hub = new THREE.Mesh(
                new THREE.CylinderGeometry(0.6, 0.6, 0.8, 12),
                hubMat
            );
            hub.rotation.x = Math.PI / 2;
            hub.position.set(0, 15, 2.5);
            windmill.add(hub);
            
            // Blade assembly (this rotates)
            const bladeAssembly = new THREE.Group();
            bladeAssembly.position.set(0, 15, 2.8);
            
            // 4 blades
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xddddcc, roughness: 0.7 });
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x5a4a3a, roughness: 0.8 });
            
            for (let i = 0; i < 4; i++) {
                const bladeGroup = new THREE.Group();
                
                // Main blade arm (wooden frame)
                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 10, 0.2),
                    frameMat
                );
                arm.position.y = 5;
                bladeGroup.add(arm);
                
                // Sail (canvas/cloth)
                const sail = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.5, 8),
                    bladeMat
                );
                sail.position.set(0.8, 5, 0.1);
                sail.rotation.y = 0.1;
                bladeGroup.add(sail);
                
                // Cross supports
                for (let j = 1; j < 4; j++) {
                    const cross = new THREE.Mesh(
                        new THREE.BoxGeometry(2.2, 0.15, 0.1),
                        frameMat
                    );
                    cross.position.set(0.6, j * 2.5, 0);
                    bladeGroup.add(cross);
                }
                
                bladeGroup.rotation.z = (i / 4) * Math.PI * 2;
                bladeAssembly.add(bladeGroup);
            }
            
            windmill.add(bladeAssembly);
            
            // Store reference to blade assembly for animation
            windmill.userData.bladeAssembly = bladeAssembly;
            windmill.userData.rotationSpeed = 0.3 + Math.random() * 0.3; // Vary speed
            
            // Door
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x3a2a1a });
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 3, 0.3),
                doorMat
            );
            door.position.set(0, 1.5, 3.3);
            windmill.add(door);
            
            // Windows
            const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            [6, 10].forEach(y => {
                const win = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 1, 0.3),
                    windowMat
                );
                win.position.set(0, y, 2.8);
                windmill.add(win);
            });
            
            return windmill;
        }
        
        // Update animated windmills each frame
        function updateWindmills(delta) {
            animatedWindmills.forEach(windmill => {
                if (windmill.userData.bladeAssembly) {
                    windmill.userData.bladeAssembly.rotation.z += windmill.userData.rotationSpeed * delta;
                }
            });
        }
        
        // === WHEEL ANIMATION ===
        // Rotates wheels based on speed for player and traffic cars
        function animateWheels(delta) {
            // Animate player car wheels (if using wedge car fallback, not hover GLTF)
            if (playerCar && playerCar.userData.wheels && playerCar.userData.wheels.length > 0) {
                const wheelRadius = playerCar.userData.wheelRadius || 0.6;
                const wheelCircumference = Math.PI * wheelRadius * 2;
                // Convert speed (mph) to rotation: speed * 0.44704 = m/s, then / circumference = rotations/s
                const rotationSpeed = (speed * 0.44704) / wheelCircumference;
                
                playerCar.userData.wheels.forEach(wheelGroup => {
                    // Rotate wheel around its local Z axis (since wheel is rotated 90¬∞ on X)
                    wheelGroup.rotation.z -= rotationSpeed * delta;
                    
                    // Front wheels also turn with steering
                    if (wheelGroup.userData.isFront) {
                        // Steering angle: max ~25 degrees (0.44 radians)
                        const steerAngle = steering * 0.44;
                        wheelGroup.rotation.y = steerAngle;
                    }
                });
            }
            
            // Animate traffic car wheels
            traffic.forEach(car => {
                if (car.userData.wheels && car.userData.wheels.length > 0 && !car.userData.crashed) {
                    const wheelRadius = car.userData.wheelRadius || 0.45;
                    const wheelCircumference = Math.PI * wheelRadius * 2;
                    const carSpeed = car.userData.currentSpeed || car.userData.speed || 50;
                    // Traffic moves relative to player, so use their actual speed
                    const rotationSpeed = (carSpeed * 0.44704) / wheelCircumference;
                    
                    car.userData.wheels.forEach(wheelGroup => {
                        // Rotate wheel
                        wheelGroup.rotation.z -= rotationSpeed * delta;
                        
                        // Front wheels turn slightly during lane changes
                        if (wheelGroup.userData.isFront && car.userData.laneChanging) {
                            const turnDir = (car.userData.targetLane || 0) > (car.userData.lane || 0) ? 1 : -1;
                            wheelGroup.rotation.y = turnDir * 0.15; // Slight turn
                        } else if (wheelGroup.userData.isFront) {
                            // Gradually return to straight
                            wheelGroup.rotation.y *= 0.9;
                        }
                    });
                }
            });
        }
        
        // Create modern wind turbine (sleek, white, 3-blade design - common on German autobahn)
        function createModernWindTurbine() {
            const turbine = new THREE.Group();
            
            // Materials
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.4, metalness: 0.2 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.6 });
            
            // Tall tapered tower (80-100m scale equivalent)
            const towerHeight = 35;
            const tower = new THREE.Mesh(
                new THREE.CylinderGeometry(0.8, 1.5, towerHeight, 12),
                whiteMat
            );
            tower.position.y = towerHeight / 2;
            tower.castShadow = true;
            turbine.add(tower);
            
            // Nacelle (housing at top)
            const nacelle = new THREE.Mesh(
                new THREE.BoxGeometry(3, 1.5, 1.5),
                whiteMat
            );
            nacelle.position.set(0, towerHeight + 0.5, 0);
            turbine.add(nacelle);
            
            // Hub (nose cone)
            const hub = new THREE.Mesh(
                new THREE.ConeGeometry(0.6, 1.5, 12),
                whiteMat
            );
            hub.rotation.x = -Math.PI / 2;
            hub.position.set(0, towerHeight + 0.5, 1.5);
            turbine.add(hub);
            
            // Blade assembly (this rotates)
            const bladeAssembly = new THREE.Group();
            bladeAssembly.position.set(0, towerHeight + 0.5, 2);
            
            // 3 modern aerodynamic blades
            for (let i = 0; i < 3; i++) {
                const bladeGroup = new THREE.Group();
                
                // Blade shape - tapered, twisted aerodynamic profile
                const bladeLen = 18;
                const bladeShape = new THREE.Shape();
                bladeShape.moveTo(0, 0);
                bladeShape.lineTo(0.4, 0);
                bladeShape.quadraticCurveTo(0.35, bladeLen * 0.5, 0.15, bladeLen);
                bladeShape.lineTo(0, bladeLen);
                bladeShape.lineTo(0, 0);
                
                const bladeGeo = new THREE.ExtrudeGeometry(bladeShape, {
                    steps: 1, depth: 0.2, bevelEnabled: false
                });
                const blade = new THREE.Mesh(bladeGeo, whiteMat);
                blade.position.set(-0.2, 0.5, -0.1);
                blade.castShadow = true;
                bladeGroup.add(blade);
                
                bladeGroup.rotation.z = (i / 3) * Math.PI * 2;
                bladeAssembly.add(bladeGroup);
            }
            
            turbine.add(bladeAssembly);
            
            // Store for animation
            turbine.userData.bladeAssembly = bladeAssembly;
            turbine.userData.rotationSpeed = 0.4 + Math.random() * 0.3;
            
            // Red aircraft warning lights (on tower)
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const light1 = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), lightMat);
            light1.position.set(0, towerHeight * 0.7, 0.8);
            turbine.add(light1);
            
            const light2 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), lightMat);
            light2.position.set(0, towerHeight + 1.5, 0);
            turbine.add(light2);
            
            return turbine;
        }
        
        // Create palm tree oasis (cluster of palms with decorative lighting)
        function createPalmOasis() {
            const oasis = new THREE.Group();
            
            // Materials
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.9 });
            const frondMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.7, side: THREE.DoubleSide });
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x3d6b3d, roughness: 0.95 });
            
            // Green ground patch (manicured grass in desert)
            const ground = new THREE.Mesh(
                new THREE.CircleGeometry(8, 16),
                groundMat
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0.02;
            oasis.add(ground);
            
            // Cluster of 3-5 palm trees
            const palmCount = 3 + Math.floor(Math.random() * 3);
            for (let p = 0; p < palmCount; p++) {
                const palmGroup = new THREE.Group();
                
                // Curved trunk (slight lean for natural look)
                const trunkHeight = 6 + Math.random() * 4;
                const trunkCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0.3, trunkHeight * 0.4, 0.2),
                    new THREE.Vector3(0.1, trunkHeight * 0.7, 0.1),
                    new THREE.Vector3(0, trunkHeight, 0)
                ]);
                const trunkGeo = new THREE.TubeGeometry(trunkCurve, 12, 0.3, 8, false);
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.castShadow = true;
                palmGroup.add(trunk);
                
                // Fronds (palm leaves)
                const frondCount = 8 + Math.floor(Math.random() * 4);
                for (let f = 0; f < frondCount; f++) {
                    const frondLen = 3 + Math.random() * 1.5;
                    const frond = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.8, frondLen),
                        frondMat
                    );
                    frond.position.set(0, trunkHeight, 0);
                    frond.rotation.y = (f / frondCount) * Math.PI * 2;
                    frond.rotation.x = 0.6 + Math.random() * 0.3; // Droop angle
                    frond.rotation.z = (Math.random() - 0.5) * 0.2;
                    palmGroup.add(frond);
                }
                
                // Position palm within oasis
                const angle = (p / palmCount) * Math.PI * 2;
                const radius = 2 + Math.random() * 3;
                palmGroup.position.set(
                    Math.cos(angle) * radius,
                    0,
                    Math.sin(angle) * radius
                );
                palmGroup.rotation.y = Math.random() * Math.PI * 2;
                oasis.add(palmGroup);
            }
            
            // Decorative up-lights (Dubai-style landscape lighting)
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            for (let l = 0; l < 4; l++) {
                const angle = (l / 4) * Math.PI * 2 + Math.PI / 4;
                const light = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.15, 0.3, 8),
                    lightMat
                );
                light.position.set(
                    Math.cos(angle) * 5,
                    0.15,
                    Math.sin(angle) * 5
                );
                oasis.add(light);
            }
            
            return oasis;
        }
        
        // Billboard / roadside sign creation
        function createBillboard() {
            const billboard = new THREE.Group();
            
            // Support poles
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.5 });
            [-2, 2].forEach(x => {
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.25, 10, 8),
                    poleMat
                );
                pole.position.set(x, 5, 0);
                pole.castShadow = true;
                billboard.add(pole);
            });
            
            // Billboard panel
            const panelGeo = new THREE.BoxGeometry(8, 4, 0.3);
            
            // Random billboard design
            const billboardCanvas = document.createElement('canvas');
            billboardCanvas.width = 256;
            billboardCanvas.height = 128;
            const bctx = billboardCanvas.getContext('2d');
            
            const designs = [
                () => {
                    // "EAT AT JOE'S" diner sign
                    bctx.fillStyle = '#ff4444';
                    bctx.fillRect(0, 0, 256, 128);
                    bctx.fillStyle = '#ffff00';
                    bctx.font = 'bold 36px Arial';
                    bctx.textAlign = 'center';
                    bctx.fillText("EAT AT JOE'S", 128, 50);
                    bctx.font = '20px Arial';
                    bctx.fillText('BEST BURGERS!', 128, 90);
                },
                () => {
                    // Gas station
                    bctx.fillStyle = '#0066cc';
                    bctx.fillRect(0, 0, 256, 128);
                    bctx.fillStyle = '#ffffff';
                    bctx.font = 'bold 40px Arial';
                    bctx.textAlign = 'center';
                    bctx.fillText('GAS', 128, 55);
                    bctx.font = '24px Arial';
                    bctx.fillText('NEXT EXIT', 128, 95);
                },
                () => {
                    // Speed challenge
                    bctx.fillStyle = '#222222';
                    bctx.fillRect(0, 0, 256, 128);
                    const grad = bctx.createLinearGradient(0, 0, 256, 0);
                    grad.addColorStop(0, '#ff0000');
                    grad.addColorStop(1, '#ffff00');
                    bctx.fillStyle = grad;
                    bctx.font = 'bold 32px Impact';
                    bctx.textAlign = 'center';
                    bctx.fillText('SPEED ZONE', 128, 50);
                    bctx.fillStyle = '#00ff00';
                    bctx.font = 'bold 28px Impact';
                    bctx.fillText('FLOOR IT!', 128, 95);
                },
                () => {
                    // Motel
                    bctx.fillStyle = '#ff8800';
                    bctx.fillRect(0, 0, 256, 128);
                    bctx.fillStyle = '#000000';
                    bctx.font = 'bold 34px Arial';
                    bctx.textAlign = 'center';
                    bctx.fillText('MOTEL', 128, 50);
                    bctx.font = '22px Arial';
                    bctx.fillText('VACANCY $29', 128, 90);
                },
                () => {
                    // Racing sponsor
                    bctx.fillStyle = '#00aa00';
                    bctx.fillRect(0, 0, 256, 128);
                    bctx.fillStyle = '#ffffff';
                    bctx.font = 'bold 28px Arial';
                    bctx.textAlign = 'center';
                    bctx.fillText('TURBO TIRES', 128, 45);
                    bctx.font = '18px Arial';
                    bctx.fillText('GRIP THE ROAD!', 128, 75);
                    bctx.fillStyle = '#ffff00';
                    bctx.font = 'bold 20px Arial';
                    bctx.fillText('‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ', 128, 105);
                }
            ];
            
            designs[Math.floor(Math.random() * designs.length)]();
            
            // Border
            bctx.strokeStyle = '#ffffff';
            bctx.lineWidth = 6;
            bctx.strokeRect(3, 3, 250, 122);
            
            const billboardTex = new THREE.CanvasTexture(billboardCanvas);
            const panelMat = new THREE.MeshStandardMaterial({ map: billboardTex });
            
            const panel = new THREE.Mesh(panelGeo, panelMat);
            panel.position.y = 10;
            panel.castShadow = true;
            billboard.add(panel);
            
            return billboard;
        }
        
        // Mile marker sign
        function createMileMarker(miles) {
            const marker = new THREE.Group();
            
            // Post
            const postMat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const post = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 4, 0.15),
                postMat
            );
            post.position.y = 2;
            marker.add(post);
            
            // Sign
            const signCanvas = document.createElement('canvas');
            signCanvas.width = 64;
            signCanvas.height = 64;
            const sctx = signCanvas.getContext('2d');
            sctx.fillStyle = '#228b22';
            sctx.fillRect(0, 0, 64, 64);
            sctx.fillStyle = '#ffffff';
            sctx.font = 'bold 24px Arial';
            sctx.textAlign = 'center';
            sctx.fillText('MILE', 32, 25);
            sctx.font = 'bold 28px Arial';
            sctx.fillText(miles.toString(), 32, 52);
            
            const signTex = new THREE.CanvasTexture(signCanvas);
            const signMat = new THREE.MeshStandardMaterial({ map: signTex });
            const sign = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 1.5),
                signMat
            );
            sign.position.y = 3.5;
            marker.add(sign);
            
            return marker;
        }
        
        // Country-specific roadside signs (Japanese signs, European signs, etc.)
        function createCountrySign(countryType) {
            const sign = new THREE.Group();
            
            if (countryType === 'american') {
                // American Interstate/Highway sign (green with white text)
                const postMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.3 });
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 5, 8), postMat);
                post.position.y = 2.5;
                sign.add(post);
                
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 180;
                signCanvas.height = 110;
                const ctx = signCanvas.getContext('2d');
                ctx.fillStyle = '#006633';
                ctx.fillRect(0, 0, 180, 110);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 5;
                ctx.strokeRect(5, 5, 170, 100);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                const cities = ['Los Angeles', 'San Francisco', 'Las Vegas', 'San Diego', 'Phoenix'];
                ctx.fillText(cities[Math.floor(Math.random() * 5)], 90, 40);
                ctx.font = '16px Arial';
                ctx.fillText((5 + Math.floor(Math.random() * 50)) + ' mi', 90, 65);
                // Interstate shield
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.moveTo(90, 75);
                ctx.lineTo(70, 95);
                ctx.lineTo(110, 95);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = '#0033aa';
                ctx.fillRect(75, 77, 30, 15);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 11px Arial';
                ctx.fillText('I-' + (5 + Math.floor(Math.random() * 95)), 90, 89);
                
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(3.5, 2.1),
                    new THREE.MeshStandardMaterial({ map: signTex })
                );
                signMesh.position.y = 5.5;
                sign.add(signMesh);
            } else if (countryType === 'tokyo') {
                // Japanese road sign - blue rectangle with white text
                const postMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4, 8), postMat);
                post.position.y = 2;
                sign.add(post);
                
                // Blue sign panel
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 128;
                signCanvas.height = 96;
                const ctx = signCanvas.getContext('2d');
                ctx.fillStyle = '#003399';
                ctx.fillRect(0, 0, 128, 96);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.strokeRect(4, 4, 120, 88);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Êù±‰∫¨ ‚Üí', 64, 35);
                ctx.font = '14px Arial';
                ctx.fillText('TOKYO', 64, 55);
                ctx.fillText('35 km', 64, 78);
                
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.5, 1.8),
                    new THREE.MeshStandardMaterial({ map: signTex })
                );
                signMesh.position.y = 4.5;
                sign.add(signMesh);
            } else if (countryType === 'european' || countryType === 'british') {
                // European blue motorway sign
                const postMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 4.5, 8), postMat);
                post.position.y = 2.25;
                sign.add(post);
                
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 160;
                signCanvas.height = 100;
                const ctx = signCanvas.getContext('2d');
                ctx.fillStyle = countryType === 'british' ? '#006633' : '#003399';
                ctx.fillRect(0, 0, 160, 100);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                const cities = countryType === 'british' 
                    ? ['London', 'Manchester', 'Birmingham']
                    : ['Berlin', 'M√ºnchen', 'Frankfurt'];
                ctx.fillText(cities[Math.floor(Math.random() * 3)], 80, 40);
                ctx.font = '16px Arial';
                ctx.fillText((10 + Math.floor(Math.random() * 90)) + ' km', 80, 70);
                
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(3, 1.8),
                    new THREE.MeshStandardMaterial({ map: signTex })
                );
                signMesh.position.y = 5;
                sign.add(signMesh);
            } else if (countryType === 'mediterranean') {
                // Italian autostrada sign (green with white)
                const postMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4, 8), postMat);
                post.position.y = 2;
                sign.add(post);
                
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 140;
                signCanvas.height = 90;
                const ctx = signCanvas.getContext('2d');
                ctx.fillStyle = '#006633';
                ctx.fillRect(0, 0, 140, 90);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                const cities = ['Roma', 'Milano', 'Firenze', 'Napoli'];
                ctx.fillText(cities[Math.floor(Math.random() * 4)], 70, 35);
                ctx.font = '14px Arial';
                ctx.fillText('A1 ‚Üí', 70, 60);
                ctx.fillText((15 + Math.floor(Math.random() * 80)) + ' km', 70, 80);
                
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.8, 1.7),
                    new THREE.MeshStandardMaterial({ map: signTex })
                );
                signMesh.position.y = 4.5;
                sign.add(signMesh);
            } else if (countryType === 'desert' || countryType === 'outback') {
                // Warning sign (yellow diamond)
                const postMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 3.5, 8), postMat);
                post.position.y = 1.75;
                sign.add(post);
                
                // Diamond shape
                const diamondShape = new THREE.Shape();
                diamondShape.moveTo(0, 1);
                diamondShape.lineTo(1, 0);
                diamondShape.lineTo(0, -1);
                diamondShape.lineTo(-1, 0);
                diamondShape.lineTo(0, 1);
                
                const diamondGeo = new THREE.ShapeGeometry(diamondShape);
                const warnings = [0xffcc00, 0xff6600]; // Yellow or orange
                const diamondMat = new THREE.MeshStandardMaterial({ 
                    color: warnings[Math.floor(Math.random() * 2)],
                    side: THREE.DoubleSide
                });
                const diamond = new THREE.Mesh(diamondGeo, diamondMat);
                diamond.position.y = 4;
                diamond.scale.set(0.8, 0.8, 1);
                sign.add(diamond);
                
                // Warning symbol (kangaroo for outback, camel for desert)
                const symbolCanvas = document.createElement('canvas');
                symbolCanvas.width = 64;
                symbolCanvas.height = 64;
                const ctx = symbolCanvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(countryType === 'outback' ? 'ü¶ò' : 'üê™', 32, 48);
                
                const symbolTex = new THREE.CanvasTexture(symbolCanvas);
                const symbolMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.9, 0.9),
                    new THREE.MeshBasicMaterial({ map: symbolTex, transparent: true })
                );
                symbolMesh.position.y = 4;
                symbolMesh.position.z = 0.02;
                sign.add(symbolMesh);
            } else if (countryType === 'dubai') {
                // Modern UAE motorway sign
                const postMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5 });
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 5, 8), postMat);
                post.position.y = 2.5;
                sign.add(post);
                
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 180;
                signCanvas.height = 110;
                const ctx = signCanvas.getContext('2d');
                // Green gradient
                const grad = ctx.createLinearGradient(0, 0, 0, 110);
                grad.addColorStop(0, '#006644');
                grad.addColorStop(1, '#004422');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, 180, 110);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ÿØÿ®Ÿä', 90, 30);
                ctx.fillText('DUBAI', 90, 55);
                ctx.font = '14px Arial';
                ctx.fillText('Sheikh Zayed Rd', 90, 80);
                ctx.fillText('E11 ‚Üí', 90, 100);
                
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(3.5, 2.1),
                    new THREE.MeshStandardMaterial({ map: signTex })
                );
                signMesh.position.y = 5.5;
                sign.add(signMesh);
            } else if (countryType === 'tropical') {
                // Brazilian road sign
                const postMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
                const post = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 4, 8), postMat);
                post.position.y = 2;
                sign.add(post);
                
                const signCanvas = document.createElement('canvas');
                signCanvas.width = 140;
                signCanvas.height = 90;
                const ctx = signCanvas.getContext('2d');
                ctx.fillStyle = '#006633';
                ctx.fillRect(0, 0, 140, 90);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                const cities = ['Rio de Janeiro', 'S√£o Paulo', 'Bras√≠lia'];
                ctx.fillText(cities[Math.floor(Math.random() * 3)], 70, 35);
                ctx.font = '14px Arial';
                ctx.fillText('BR-101 ‚Üí', 70, 60);
                ctx.fillText((20 + Math.floor(Math.random() * 100)) + ' km', 70, 80);
                
                const signTex = new THREE.CanvasTexture(signCanvas);
                const signMesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.8, 1.7),
                    new THREE.MeshStandardMaterial({ map: signTex })
                );
                signMesh.position.y = 4.5;
                sign.add(signMesh);
            }
            
            return sign;
        }
        
        // Ground vegetation clusters (grass, flowers, small rocks)
        function createGroundVegetation(countryType) {
            const group = new THREE.Group();
            
            // Determine vegetation style based on country
            const isDesert = countryType === 'desert' || countryType === 'outback' || countryType === 'dubai';
            const isTropical = countryType === 'tropical';
            
            if (isDesert) {
                // Desert scrub and small rocks
                const scrubColors = [0x6b6b3a, 0x7a7a4a, 0x5a5a2a];
                const rockColors = [0x9e8b6e, 0xb8a07a, 0x8b7355];
                
                // Scattered small rocks
                for (let i = 0; i < 3 + Math.floor(Math.random() * 4); i++) {
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.15 + Math.random() * 0.25),
                        new THREE.MeshStandardMaterial({ 
                            color: rockColors[Math.floor(Math.random() * 3)],
                            roughness: 0.95
                        })
                    );
                    rock.position.set(
                        (Math.random() - 0.5) * 4,
                        0.1,
                        (Math.random() - 0.5) * 4
                    );
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    rock.scale.y = 0.5 + Math.random() * 0.3;
                    group.add(rock);
                }
                
                // Dry grass tufts
                for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                    const tuft = new THREE.Mesh(
                        new THREE.ConeGeometry(0.2, 0.4, 4),
                        new THREE.MeshStandardMaterial({ color: scrubColors[Math.floor(Math.random() * 3)] })
                    );
                    tuft.position.set(
                        (Math.random() - 0.5) * 3,
                        0.2,
                        (Math.random() - 0.5) * 3
                    );
                    group.add(tuft);
                }
            } else if (isTropical) {
                // Tropical vegetation - ferns, flowers
                const greenColors = [0x228b22, 0x32cd32, 0x2e8b57];
                const flowerColors = [0xff69b4, 0xff4500, 0xffd700, 0x9932cc];
                
                // Small ferns
                for (let i = 0; i < 4 + Math.floor(Math.random() * 4); i++) {
                    const fern = new THREE.Mesh(
                        new THREE.ConeGeometry(0.25, 0.5, 5),
                        new THREE.MeshStandardMaterial({ color: greenColors[Math.floor(Math.random() * 3)] })
                    );
                    fern.position.set(
                        (Math.random() - 0.5) * 4,
                        0.25,
                        (Math.random() - 0.5) * 4
                    );
                    fern.rotation.x = (Math.random() - 0.5) * 0.3;
                    group.add(fern);
                }
                
                // Tropical flowers
                for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                    const flower = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12, 6, 6),
                        new THREE.MeshStandardMaterial({ 
                            color: flowerColors[Math.floor(Math.random() * 4)],
                            emissive: flowerColors[Math.floor(Math.random() * 4)],
                            emissiveIntensity: 0.2
                        })
                    );
                    flower.position.set(
                        (Math.random() - 0.5) * 3,
                        0.3 + Math.random() * 0.2,
                        (Math.random() - 0.5) * 3
                    );
                    group.add(flower);
                }
            } else {
                // Temperate grass and wildflowers
                const grassColors = [0x3d6b3d, 0x4a7a4a, 0x2d5a2d];
                const flowerColors = [0xffff00, 0xffffff, 0xff6699, 0x6699ff];
                
                // Grass tufts
                for (let i = 0; i < 5 + Math.floor(Math.random() * 5); i++) {
                    const grass = new THREE.Mesh(
                        new THREE.ConeGeometry(0.15, 0.35, 4),
                        new THREE.MeshStandardMaterial({ color: grassColors[Math.floor(Math.random() * 3)] })
                    );
                    grass.position.set(
                        (Math.random() - 0.5) * 4,
                        0.17,
                        (Math.random() - 0.5) * 4
                    );
                    group.add(grass);
                }
                
                // Small wildflowers
                if (Math.random() > 0.4) {
                    for (let i = 0; i < 3 + Math.floor(Math.random() * 4); i++) {
                        const flower = new THREE.Mesh(
                            new THREE.SphereGeometry(0.08, 5, 5),
                            new THREE.MeshStandardMaterial({ 
                                color: flowerColors[Math.floor(Math.random() * 4)] 
                            })
                        );
                        flower.position.set(
                            (Math.random() - 0.5) * 3,
                            0.25,
                            (Math.random() - 0.5) * 3
                        );
                        group.add(flower);
                    }
                }
                
                // Small pebbles
                for (let i = 0; i < 2 + Math.floor(Math.random() * 3); i++) {
                    const pebble = new THREE.Mesh(
                        new THREE.SphereGeometry(0.08 + Math.random() * 0.1, 5, 5),
                        new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.9 })
                    );
                    pebble.position.set(
                        (Math.random() - 0.5) * 4,
                        0.05,
                        (Math.random() - 0.5) * 4
                    );
                    pebble.scale.y = 0.4;
                    group.add(pebble);
                }
            }
            
            return group;
        }
        
        function triggerCrash(text, intensity) {
            if (crashCooldown > 0) return;
            crashCooldown = 1;
            screenShake = intensity;
            announce(text, 800);
            
            for (let i = 0; i < 15; i++) {
                const p = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.1),
                    new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff4400 : 0xffaa00 })
                );
                p.position.set(playerX + (Math.random() - 0.5) * 2, 0.5 + Math.random(), (Math.random() - 0.5) * 2);
                p.userData = { vel: new THREE.Vector3((Math.random()-0.5)*0.4, Math.random()*0.3, Math.random()*0.2), life: 0.6 };
                scene.add(p);
                particles.push(p);
            }
        }
        
        // Spark particle effect for metal-on-metal collisions
        function spawnSparks(posX, posZ, count, collisionType) {
            const sparkColors = collisionType === 'sideswipe' ? [0xffdd00, 0xffaa00, 0xffffff] : [0xff6600, 0xffaa00, 0xff4400];
            for (let i = 0; i < count; i++) {
                const spark = new THREE.Mesh(
                    new THREE.BoxGeometry(0.04, 0.04, 0.04),
                    new THREE.MeshBasicMaterial({ color: sparkColors[Math.floor(Math.random() * sparkColors.length)] })
                );
                spark.position.set(posX, 0.3 + Math.random() * 0.3, posZ);
                // Sparks spray outward and upward
                const angle = Math.random() * Math.PI * 2;
                const spraySpeed = 0.3 + Math.random() * 0.4;
                spark.userData = { 
                    vel: new THREE.Vector3(
                        Math.cos(angle) * spraySpeed,
                        0.2 + Math.random() * 0.4, // Upward
                        Math.sin(angle) * spraySpeed * 0.5
                    ), 
                    life: 0.2 + Math.random() * 0.3,
                    isSpark: true
                };
                scene.add(spark);
                particles.push(spark);
            }
        }
        
        function announce(text, duration = 1500) {
            const el = document.getElementById('announcer');
            if (!el) return; // Defensive check for missing DOM element
            el.textContent = text;
            el.classList.add('show');
            setTimeout(() => { if (el) el.classList.remove('show'); }, duration);
        }
        
        function updateGame(delta) {
            if (!gameRunning) return;
            
            time -= delta;
            if (time <= 0) { gameOver(); return; }
            hudCache.updateTime(time);
            
            // === COLLISION RECOVERY TIME ===
            // Decrement recovery timer and apply reduced control
            if (playerRecoveryTime > 0) {
                playerRecoveryTime -= delta;
            }
            
            // Steering - ARCADE STYLE: snappy, responsive, fun!
            // Steering effectiveness scales with speed but stays responsive
            // At low speed: tight turns. At high speed: still controllable but requires commitment
            const speedFactor = 0.6 + (speed / maxSpeed) * 0.6; // 0.6 to 1.2 range
            let turnSpeed = handling * speedFactor;
            
            // Reduce steering control during recovery period (after collision)
            if (playerRecoveryTime > 0) {
                const recoveryFactor = 0.4 + (1 - playerRecoveryTime) * 0.6; // 40% to 100% control
                turnSpeed *= recoveryFactor;
            }
            
            // Direct steering input - no dampening multiplier (was * 0.7, killed responsiveness)
            // Higher max steering angle for sharper turns
            if (isLeft) steering = Math.max(steering - turnSpeed, -1.0);
            else if (isRight) steering = Math.min(steering + turnSpeed, 1.0);
            else { 
                // Quick snap back to center - arcade cars don't drift lazily
                if (Math.abs(steering) < 0.02) steering = 0; 
                else steering *= 0.82; // Was 0.92 - now snaps back faster
            }
            
            // Speed - ARCADE ACCELERATION: punchy and immediate
            const targetSpeed = isBoosting && boost > 0 ? maxSpeed * 1.4 : maxSpeed;
            
            if (isAccel) {
                // More linear acceleration - only slight reduction near max speed
                // This gives that satisfying "push back in your seat" feeling
                const speedRatio = speed / targetSpeed;
                const accelRate = accel * delta * (1 - speedRatio * 0.4); // Much less dampening (was * 0.67)
                speed = Math.min(speed + accelRate, targetSpeed);
            } else if (isBrake) {
                // STRONG brakes - arcade racers need to stop on a dime
                // Braking is 3x accel (was 2x) and allows faster reverse
                speed = Math.max(speed - accel * 3 * delta, -50);
            } else {
                // Light engine braking when coasting - not too aggressive
                speed = Math.max(0, speed - accel * 0.2 * delta);
            }
            
            topSpeed = Math.max(topSpeed, speed);
            
            // Boost - TUNED for arcade fun!
            // Drain: 22/sec = ~4.5s full boost duration (was 25/sec = 4s)
            // Recharge: 16/sec = ~6.3s to full (was 12/sec = 8.3s - felt too slow)
            // This gives players more frequent nitro bursts for exciting gameplay
            if (isBoosting && boost > 0 && speed > 60) {
                boost = Math.max(0, boost - 22 * delta);
            } else {
                boost = Math.min(100, boost + 16 * delta);
            }
            hudCache.updateBoost(boost);
            
            // Show/hide nitro flames
            if (playerCar && playerCar.userData.nitroFlames) {
                const showFlames = isBoosting && boost > 0;
                playerCar.userData.nitroFlames.forEach(flame => {
                    flame.visible = showFlames;
                });
            }
            document.getElementById('speed-lines').classList.toggle('active', speed > 200);
            
            // Movement - Lateral movement from steering
            // Increased coefficient for more responsive lane changes (was 0.012)
            playerX += steering * speed * 0.018 * delta;
            
            // Smooth road width transition every frame (for collision consistency)
            // This ensures barrier limits change smoothly, not in discrete jumps
            currentRoadWidth += (targetRoadWidth - currentRoadWidth) * delta * 3;
            
            // Barriers - edge of road with rumble strips (dynamic width)
            const barrierLimit = (currentRoadWidth / 2) - 2; // 2 units inside road edge
            if (playerX < -barrierLimit) { playerX = -barrierLimit; if (speed > 30 && crashCooldown <= 0) { triggerCrash('RUMBLE!', 0.3); speed *= 0.8; } }
            if (playerX > barrierLimit) { playerX = barrierLimit; if (speed > 30 && crashCooldown <= 0) { triggerCrash('RUMBLE!', 0.3); speed *= 0.8; } }
            
            distance += speed * delta * 0.008;
            
            // Spawn checkpoint gate as we approach checkpoint distance
            if (distance >= nextCheckpointSpawn - 100 && nextCheckpointSpawn <= checkpointDist) {
                createCheckpointGate(lastRoadZ - 150);
                nextCheckpointSpawn = checkpointDist + 100; // Set next spawn after current checkpoint
            }
            
            // Checkpoint & Country change - BALANCED DIFFICULTY CURVE
            // Time bonus: 20s base (was 18) - more forgiving, encourages aggressive play
            // Score: 750 base (was 500) - feels more rewarding
            // Distance scaling: +550 base + capped at +300 extra (was +600 + uncapped)
            //   This prevents late-game checkpoints from being impossibly far
            if (distance >= checkpointDist) {
                time += 20;
                score += 750;
                
                // Change to random new country
                const countryKeys = Object.keys(countries);
                let newCountry;
                do { newCountry = countryKeys[Math.floor(Math.random() * countryKeys.length)]; } 
                while (newCountry === currentCountry);
                
                setCountry(newCountry);
                if (!visitedCountries.has(newCountry)) {
                    visitedCountries.add(newCountry);
                    countriesVisited++;
                    score += 300; // Boosted new country bonus (was 200)
                }
                
                announce(`${countries[newCountry].flag} ${countries[newCountry].name}!`, 2500);
                // Checkpoint distance: 550m base + progressive scaling (capped)
                // Formula: +550 + min(300, distance/1000 * 80)
                // At 0m: +550, at 3750m: +850 (max), beyond: stays at +850
                const distanceBonus = Math.min(300, Math.floor(distance / 1000) * 80);
                checkpointDist += 550 + distanceBonus;
                nextCheckpointSpawn = checkpointDist - 100; // Queue up next gate
            }
            hudCache.updateCheckpoint(`CHECKPOINT: ${Math.max(0, Math.floor(checkpointDist - distance))}m`);
            
            // Cooldowns
            if (crashCooldown > 0) crashCooldown -= delta;
            if (screenShake > 0) screenShake -= delta * 2;
            
            // Jump/airborne physics - TUNED for exciting jumps!
            const currentSect = trackSections[trackSection % trackSections.length];
            if (currentSect.ramp && speed > 80 && !playerAirborne) {
                // Launch! Speed threshold lowered to 80 (was 100) for easier jumps
                playerAirborne = true;
                verticalVelocity = speed * 0.08;
                announce('üöÄ BIG AIR!', 1000);
                score += 400; // Boosted from 300 - jumping is fun!
            }
            
            if (playerAirborne) {
                airTime += delta;
                verticalVelocity -= 25 * delta; // Gravity
                playerCar.position.y += verticalVelocity * delta;
                
                // Land - TUNED airtime rewards
                if (playerCar.position.y <= 0) {
                    playerCar.position.y = 0;
                    playerAirborne = false;
                    // Airtime multiplier boosted: 250/sec (was 200)
                    // At 1.5s air: 375 points. At 2.5s: 625 points!
                    if (airTime > 0.4) { // Lowered threshold (was 0.5)
                        const airScore = Math.floor(airTime * 250);
                        score += airScore;
                        announce(`LANDED! +${airScore}`, 800);
                    }
                    airTime = 0;
                    verticalVelocity = 0;
                }
            } else {
                // Follow road elevation
                playerCar.position.y = Math.max(0, elevation * 0.05);
            }
            
            // Update car - stays straight, only rotates with player steering
            playerCar.position.x = playerX;
            playerCar.position.z = 0; // Car stays at z=0, world moves toward it
            
            // Keep car on the road (follows road elevation)
            const roadSurfaceY = elevation * 0.1 + 0.5; // Road elevation + hover height
            if (!playerAirborne) {
                playerCar.position.y = Math.max(roadSurfaceY, 0.5); // Never go below ground
            } else if (playerCar.position.y < roadSurfaceY) {
                // If airborne but below road, land
                playerCar.position.y = roadSurfaceY;
                playerAirborne = false;
                verticalVelocity = 0;
            }
            
            // === WEIGHT TRANSFER PHYSICS ===
            // Smooth, realistic body motion that responds to inputs over time
            
            // Target pitch: nose dives on braking, squats (nose up) on acceleration
            // Airborne has its own pitch override
            let targetPitch;
            if (playerAirborne) {
                targetPitch = -0.4; // Nose up when airborne
            } else if (isBrake && speed > 10) {
                targetPitch = 0.35; // Strong nose dive on braking
            } else if (isAccel) {
                targetPitch = -0.18; // Squat (nose up) on acceleration
            } else {
                targetPitch = 0; // Neutral when coasting
            }
            
            // Target roll: lean into turns, more at higher speeds
            const speedRatio = speed / maxSpeed;
            const targetRoll = -steering * speedRatio * 0.5; // Lean into turns
            
            // Smooth interpolation toward targets (different rates for pitch vs roll)
            // Pitch responds faster (8) for snappy brake/accel feel
            // Roll responds slightly slower (6) for smooth cornering lean
            weightTransferPitch += (targetPitch - weightTransferPitch) * delta * 8;
            weightTransferRoll += (targetRoll - weightTransferRoll) * delta * 6;
            
            // Grip modeling - breaks during hard cornering at speed
            // corneringForce is high when steering hard AND going fast
            const corneringForce = Math.abs(steering) * speedRatio;
            // Grip starts dropping when corneringForce > 0.5, bottoms at 0.3
            const targetGrip = corneringForce > 0.5 ? Math.max(0.3, 1 - (corneringForce - 0.5) * 1.4) : 1.0;
            gripFactor += (targetGrip - gripFactor) * delta * 4;
            
            // Apply reduced grip effect: slightly wider turns when grip is low
            if (gripFactor < 0.9 && speed > 50) {
                // Slide outward slightly when grip breaks
                const slideAmount = (1 - gripFactor) * steering * speed * 0.0003 * delta;
                playerX += slideAmount;
            }
            
            // Apply visual rotation to car
            // Car faces AWAY from camera (toward -Z) - we see the back/taillights
            if (gltfCarModel) {
                // GLTF model at œÄ/2 (90¬∞) shows back of car (taillights toward camera)
                playerCar.rotation.y = Math.PI / 2 + steering * 0.4;  // Yaw from steering
                playerCar.rotation.z = weightTransferRoll * 0.2;       // Body roll from weight transfer
                playerCar.rotation.x = weightTransferPitch * 0.1;      // Pitch from weight transfer
            } else {
                // Wedge car rotated 90¬∞ to face -Z (away from camera)
                playerCar.rotation.y = Math.PI / 2 + steering * 0.4;
                playerCar.rotation.z = weightTransferRoll * 0.2;       // Body roll
                playerCar.rotation.x = weightTransferPitch * 0.12;     // Pitch (slightly more for wedge car)
            }
            
            // Camera - FIXED behind the car, world moves toward it
            // Camera stays locked behind car, only shifts when player steers
            const shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake * 2 : 0;
            const shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake * 1.5 : 0;
            
            // Check if player is ACTIVELY steering
            const isActivelySteering = isLeft || isRight;
            
            // Camera X position:
            // - When steering: follow the player car smoothly
            // - When NOT steering: stay centered (world curves around camera/car)
            // This means the car stays in center of screen when going straight,
            // and the road appears to curve around the player
            const camTargetX = isActivelySteering ? playerX * 0.4 + steering * 2 : 0;
            const camY = 5 + (playerAirborne ? playerCar.position.y + 1 : 0) + shakeY;
            const camZ = 11; // Fixed distance behind
            
            // Smooth camera movement - faster return to center when not steering
            const cameraLerpSpeed = isActivelySteering ? 0.06 : 0.15;
            camera.position.x += (camTargetX - camera.position.x) * cameraLerpSpeed + shakeX;
            camera.position.y += (camY - camera.position.y) * 0.1;
            camera.position.z = camZ; // Fixed Z - no movement along Z
            
            // Look straight ahead - NO tilt when going straight
            // Only add slight look offset when actively steering
            const lookOffsetX = isActivelySteering ? steering * 2 : 0;
            camera.lookAt(lookOffsetX, 1.5, -30);
            
            // CRITICAL: No camera roll/banking - perfectly level at all times
            camera.rotation.z = 0;
            
            // Dynamic FOV - increases with speed for tunnel vision effect
            // Base 65¬∞ at rest, up to 80¬∞ at max speed, 90¬∞ during boost
            // (reusing speedRatio from weight transfer calculation above)
            const baseFOV = 65;
            const speedFOVBonus = speedRatio * 15; // +15¬∞ at max speed
            const boostFOVBonus = (isBoosting && boost > 0 && speed > maxSpeed) ? 10 : 0; // +10¬∞ during active boost
            camera.fov = baseFOV + speedFOVBonus + boostFOVBonus;
            camera.updateProjectionMatrix();
            
            // === MOTION BLUR OVERLAY ===
            // Radial blur intensifies at high speeds (>60% max speed)
            const motionBlurEl = document.getElementById('motion-blur');
            if (motionBlurEl) {
                if (speedRatio > 0.6) {
                    const blurIntensity = (speedRatio - 0.6) / 0.4; // 0-1 range above 60% speed
                    const boostMultiplier = (isBoosting && boost > 0) ? 1.3 : 1.0;
                    motionBlurEl.style.opacity = blurIntensity * 0.35 * boostMultiplier;
                    // Dynamic gradient - tighter center at higher speeds
                    const centerClear = 30 - blurIntensity * 10; // 30% down to 20% clear center
                    motionBlurEl.style.background = `radial-gradient(ellipse at center, 
                        transparent ${centerClear}%, 
                        rgba(0,0,0,${0.3 + blurIntensity * 0.3}) 100%)`;
                } else {
                    motionBlurEl.style.opacity = 0;
                }
            }
            
            // === CHROMATIC ABERRATION ===
            // RGB split effect during boost at high speed
            const gameContainer = document.getElementById('game-container');
            if (gameContainer) {
                const isExtremeSpeed = speed > maxSpeed * 1.2;
                const shouldChromatic = isBoosting && boost > 0 && isExtremeSpeed;
                gameContainer.classList.toggle('chromatic-boost', shouldChromatic);
                // Speed distortion (subtle blur) at very high speeds
                gameContainer.classList.toggle('speed-distort', speedRatio > 0.9 && !shouldChromatic);
            }
            
            // Move background elements (clouds, Mt. Fuji, ocean) WITH the camera
            // This makes them appear stationary - "infinitely far away"
            // The road moves toward us, but the sky/mountains stay put
            clouds.forEach(cloud => {
                if (cloud.userData.baseX === undefined) {
                    cloud.userData.baseX = cloud.position.x;
                }
                // Background follows camera X so it appears fixed in the sky
                cloud.position.x = cloud.userData.baseX + camera.position.x;
            });
            
            if (mtFuji) {
                if (mtFuji.userData.baseX === undefined) {
                    mtFuji.userData.baseX = mtFuji.position.x;
                }
                // Mt. Fuji follows camera X - appears stationary on horizon
                mtFuji.position.x = mtFuji.userData.baseX + camera.position.x;
            }
            
            // Track section progression
            sectionDistance += speed * delta * 0.3;
            const currentSection = trackSections[trackSection % trackSections.length];
            
            if (sectionDistance >= currentSection.length) {
                sectionDistance = 0;
                trackSection++;
                const newSection = trackSections[trackSection % trackSections.length];
                announce(newSection.name, 1500);
                
                // Update road width and surface for new section
                // Surface changes are immediate (segments ahead should use new surface)
                targetRoadWidth = newSection.roadWidth || 24;
                targetSurface = newSection.surface || 'asphalt';
                currentSurface = targetSurface; // Update both for consistency
                
                // Spawn landmark if section has one
                if (newSection.landmark) {
                    const side = newSection.curve > 0 ? -35 : 35;
                    spawnLandmark(newSection.landmark, side, 0, lastRoadZ - 100);
                }
            }
            
            // Smooth transitions to section targets
            roadCurveTarget = currentSection.curve;
            elevationTarget = currentSection.elevation;
            const targetBank = currentSection.bank * (Math.PI / 180); // Convert to radians
            
            roadCurve += (roadCurveTarget - roadCurve) * delta * 0.8;
            elevation += (elevationTarget - elevation) * delta * 0.5;
            banking += (targetBank - banking) * delta * 2;
            
            // Apply curve force to player (centrifugal effect)
            playerX += roadCurve * speed * delta * 0.02;
            
            // Move world
            const moveZ = speed * delta * 0.35;
            
            // Performance optimization: cache curve state for this frame
            // Skip expensive curve calculations when road is straight
            const curveIsActive = Math.abs(roadCurve) > 0.001;
            const aheadMult = 0.004, behindMult = 0.002, blendRange = 15;  // Arcade curve
            
            // Update road segments - curve them properly with elevation
            // Uses quadratic distance scaling for smooth, natural-feeling curves
            // Based on Frenet frame principles: curve intensity increases with square of distance
            roadSegments.forEach(seg => {
                seg.position.z += moveZ;
                
                const distFromPlayer = -seg.position.z;
                const absDistance = Math.abs(distFromPlayer);
                
                // Curve offset: blend segment's spawnCurve with current roadCurve
                // Near segments use current roadCurve (responsive feel)
                // Far segments use their spawnCurve (prevents snap when entering curves)
                const curveStrength = 0.00015;
                let curveOffset = 0;
                const segCurve = seg.userData.spawnCurve !== undefined ? seg.userData.spawnCurve : roadCurve;
                // Blend: 0-30 units = mostly roadCurve, 30-150 units = transition, 150+ = spawnCurve
                const curveLerp = Math.min(1, Math.max(0, (absDistance - 30) / 120));
                const effectiveCurve = segCurve * curveLerp + roadCurve * (1 - curveLerp);
                if (Math.abs(effectiveCurve) > 0.001) {
                    curveOffset = effectiveCurve * absDistance * absDistance * curveStrength;
                    curveOffset = Math.sign(curveOffset) * Math.min(Math.abs(curveOffset), 80);
                }
                const baseX = seg.userData.baseX !== undefined ? seg.userData.baseX : 0;
                seg.position.x = baseX - curveOffset;

                // Elevation - use segment's spawn elevation as base, smooth transition for distant segments
                const segElevation = seg.userData.segmentElevation !== undefined ? seg.userData.segmentElevation : 0;
                const baseYOffset = seg.userData.baseY !== undefined ? (seg.userData.baseY - segElevation) : 0;
                
                // Blend between segment's spawn elevation and current global elevation based on distance
                // For segments ahead: blend toward current elevation (prevents horizon pop-in)
                // For segments behind: gentle blend that smoothly transitions from ahead behavior
                let elevLerp;
                if (distFromPlayer > 0) {
                    // Ahead of player: full blend over 200 units for smooth horizon
                    elevLerp = Math.min(1, distFromPlayer / 200);
                } else {
                    // Behind player: start at 0% (matching ahead at dist=0), peak at 15% around -25 units,
                    // then fade back to 0% by -50 units. Uses smooth sine curve to avoid discontinuity.
                    const behindDist = -distFromPlayer; // Convert to positive distance behind
                    if (behindDist < 50) {
                        // Smooth sine curve: sin(œÄ * t) where t goes 0‚Üí1 over 50 units
                        // Peaks at t=0.5 (behindDist=25) with elevLerp=0.15
                        const t = behindDist / 50;
                        elevLerp = 0.15 * Math.sin(Math.PI * t);
                    } else {
                        elevLerp = 0;
                    }
                }
                const blendedElevation = segElevation * (1 - elevLerp) + elevation * 0.1 * elevLerp;
                seg.position.y = blendedElevation + baseYOffset;
                
                // Rotate non-road elements to match curve tangent
                // Road surfaces use vertex warping instead (smoother)
                if (!seg.userData.isRoadSurface) {
                    const tangent = 2 * effectiveCurve * curveStrength * distFromPlayer;
                    seg.rotation.y = Math.atan(tangent);
                } else {
                    seg.rotation.y = 0;
                }

                // Warp road surface vertices so the segment bends along the curve
                // PlaneGeometry(w, h, 1, 4) rotated -PI/2 on X:
                //   local X = world X (left/right)
                //   local Y = world -Z (along road, Y+ = toward player)
                // With widthSegments=1, heightSegments=4: 2 columns √ó 5 rows = 10 verts
                // Row order: local Y from +segLen/2 (near) to -segLen/2 (far)
                if (seg.userData.isRoadSurface) {
                    const posAttr = seg.geometry.attributes.position;
                    const halfW = seg.geometry.parameters.width / 2;
                    if (Math.abs(effectiveCurve) > 0.001) {
                        for (let v = 0; v < posAttr.count; v++) {
                            const origX = (v % 2 === 0) ? -halfW : halfW;
                            const localY = posAttr.getY(v);
                            const vertWorldZ = seg.position.z - localY;
                            const vertDist = -vertWorldZ;
                            const vertAbsDist = Math.abs(vertDist);
                            // Per-vertex blend uses vertex distance, not segment distance
                            const vertLerp = Math.min(1, Math.max(0, (vertAbsDist - 30) / 120));
                            const vertEffCurve = segCurve * vertLerp + roadCurve * (1 - vertLerp);
                            let vertCurve = vertEffCurve * vertAbsDist * vertAbsDist * curveStrength;
                            vertCurve = Math.sign(vertCurve) * Math.min(Math.abs(vertCurve), 80);
                            posAttr.setX(v, origX - (vertCurve - curveOffset));
                        }
                    } else {
                        // Reset to flat when straight
                        for (let v = 0; v < posAttr.count; v++) {
                            posAttr.setX(v, (v % 2 === 0) ? -halfW : halfW);
                        }
                    }
                    posAttr.needsUpdate = true;
                }

                // Banking on curves ‚Äî blend with segment's spawnCurve for smooth transitions
                if (seg.userData.banking !== undefined) {
                    const currentBankAngle = banking * Math.sign(effectiveCurve) * Math.min(1, Math.abs(effectiveCurve) * 1.5);
                    seg.rotation.z = currentBankAngle;
                }
            });
            roadSegments = roadSegments.filter(seg => { if (seg.position.z > 80) { removeAndDispose(seg); return false; } return true; });
            
            scenery.forEach(obj => {
                obj.position.z += moveZ;
                
                // Use object's spawn curve for offset - matches road curve formula
                const objCurve = obj.userData.spawnCurve !== undefined ? obj.userData.spawnCurve : roadCurve;
                if (Math.abs(objCurve) > 0.001) {
                    const distFromPlayer = -obj.position.z;
                    const absDistance = Math.abs(distFromPlayer);
                    // Quadratic curve matching road segments for consistent parallax
                    const curveStrength = 0.00015;
                    let curveOffset = objCurve * absDistance * absDistance * curveStrength;
                    curveOffset = Math.sign(curveOffset) * Math.min(Math.abs(curveOffset), 80);
                    const baseX = obj.userData.baseX !== undefined ? obj.userData.baseX : obj.position.x;
                    obj.position.x = baseX - curveOffset;
                }
                
                // Keep original variable names for elevation code below
                const distFromPlayer = -obj.position.z;
                const absDistance = Math.abs(distFromPlayer);
                
                // Apply elevation blending to prevent floating/clipping on hills
                // Uses same logic as road segments for consistent ground alignment
                if (obj.userData.segmentElevation !== undefined) {
                    const segElevation = obj.userData.segmentElevation;
                    const baseYOffset = obj.userData.baseY !== undefined ? (obj.userData.baseY - segElevation) : 0;
                    
                    // Calculate elevation lerp based on distance from player
                    let elevLerp;
                    if (distFromPlayer > 0) {
                        elevLerp = Math.min(1, distFromPlayer / 200);
                    } else {
                        const behindDist = -distFromPlayer;
                        if (behindDist < 50) {
                            const t = behindDist / 50;
                            elevLerp = 0.15 * Math.sin(Math.PI * t);
                        } else {
                            elevLerp = 0;
                        }
                    }
                    const blendedElevation = segElevation * (1 - elevLerp) + elevation * 0.1 * elevLerp;
                    obj.position.y = blendedElevation + baseYOffset;
                }
            });
            scenery = scenery.filter(obj => { if (obj.position.z > 80) { removeAndDispose(obj); return false; } return true; });
            
            // Move iconic landmarks with smooth curve transition (uses spawn curve)
            iconicLandmarks.forEach(obj => {
                obj.position.z += moveZ;
                const objCurve = obj.userData.spawnCurve !== undefined ? obj.userData.spawnCurve : 0;
                if (Math.abs(objCurve) > 0.001) {
                    const distFromPlayer = -obj.position.z;
                    const absDistance = Math.abs(distFromPlayer);
                    const blendFactor = Math.max(0, Math.min(1, (distFromPlayer + blendRange) / (2 * blendRange)));
                    const curveMultiplier = behindMult + (aheadMult - behindMult) * blendFactor;
                    const curveOffset = objCurve * absDistance * absDistance * curveMultiplier;
                    const baseX = obj.userData.baseX !== undefined ? obj.userData.baseX : obj.position.x;
                    obj.position.x = baseX - curveOffset;
                }
            });
            iconicLandmarks = iconicLandmarks.filter(obj => { if (obj.position.z > 100) { removeAndDispose(obj); return false; } return true; });
            
            // Move animated windmills with smooth curve transition (uses spawn curve)
            animatedWindmills.forEach(obj => {
                obj.position.z += moveZ;
                const objCurve = obj.userData.spawnCurve !== undefined ? obj.userData.spawnCurve : 0;
                if (Math.abs(objCurve) > 0.001) {
                    const distFromPlayer = -obj.position.z;
                    const absDistance = Math.abs(distFromPlayer);
                    const blendFactor = Math.max(0, Math.min(1, (distFromPlayer + blendRange) / (2 * blendRange)));
                    const curveMultiplier = behindMult + (aheadMult - behindMult) * blendFactor;
                    const curveOffset = objCurve * absDistance * absDistance * curveMultiplier;
                    const baseX = obj.userData.baseX !== undefined ? obj.userData.baseX : obj.position.x;
                    obj.position.x = baseX - curveOffset;
                }
            });
            animatedWindmills = animatedWindmills.filter(obj => { if (obj.position.z > 100) { removeAndDispose(obj); return false; } return true; });
            
            // Update crash sites (decay over time, move with world)
            crashSites.forEach(site => {
                site.z += moveZ;
                site.time -= delta;
            });
            crashSites = crashSites.filter(site => site.time > 0 && site.z < 100);
            
            // Update emergency vehicle lights animation
            emergencyVehicles.forEach(ev => {
                if (ev.userData.flashPhase !== undefined) {
                    // Wrap flashPhase to prevent unbounded growth (stays in 0 to 2œÄ range)
                    ev.userData.flashPhase = (ev.userData.flashPhase + delta * 8) % (Math.PI * 2);
                    
                    // Animate light bar
                    if (ev.userData.lightBarGroup) {
                        ev.userData.lightBarGroup.children.forEach(child => {
                            if (child.userData.isRedLight !== undefined) {
                                const isOn = Math.sin(ev.userData.flashPhase + (child.userData.isRedLight ? 0 : Math.PI)) > 0;
                                child.userData.lightMaterial.emissiveIntensity = isOn ? 4.0 : 0.3;
                            }
                        });
                    }
                    
                    // Animate siren point light color
                    if (ev.userData.sirenLight) {
                        const phase = Math.sin(ev.userData.flashPhase);
                        ev.userData.sirenLight.color.setHex(phase > 0 ? 0xff0000 : 0x0066ff);
                        ev.userData.sirenLight.intensity = 2 + Math.abs(phase);
                    }
                }
            });
            emergencyVehicles = emergencyVehicles.filter(ev => traffic.includes(ev));
            
            traffic.forEach(car => {
                // === CRASH REACTION SYSTEM ===
                // Cars slow down and swerve when approaching a crash site
                let crashReactionSpeed = 1.0; // Multiplier (1.0 = normal, <1 = slowing)
                let crashAvoidX = 0; // Lateral dodge offset
                
                if (!car.userData.crashed && !car.userData.spinOut && !car.userData.isEmergency) {
                    crashSites.forEach(site => {
                        const distZ = site.z - car.position.z; // Positive = crash is ahead
                        const distX = Math.abs(site.x - car.position.x);
                        
                        // React if crash is 15-80 units ahead and within 10 units laterally
                        if (distZ > 15 && distZ < 80 && distX < 10) {
                            // Slow down proportionally to distance
                            const slowFactor = 1 - (80 - distZ) / 80 * 0.6; // Up to 60% slower
                            crashReactionSpeed = Math.min(crashReactionSpeed, slowFactor);
                            
                            // Swerve away from crash (if close enough laterally)
                            if (distX < 6 && distZ < 50) {
                                const dodgeDir = car.position.x < site.x ? -1 : 1;
                                crashAvoidX += dodgeDir * (1 - distZ / 50) * 2.5 * delta;
                            }
                        }
                    });
                    
                    // Apply crash avoidance lateral movement (clamp lane to road bounds)
                    if (crashAvoidX !== 0 && !car.userData.laneChanging) {
                        const spawnCurve = car.userData.spawnCurveX || 0;
                        const currentLane = car.userData.baseX - spawnCurve;
                        const newLane = Math.max(-9, Math.min(9, currentLane + crashAvoidX));
                        car.userData.baseX = spawnCurve + newLane;
                    }
                }
                
                // === EMERGENCY VEHICLE YIELD SYSTEM ===
                // Regular traffic yields to emergency vehicles approaching from behind
                if (!car.userData.isEmergency && !car.userData.crashed) {
                    // Initialize yield timer if not present (prevents frame-rate dependent behavior)
                    if (car.userData.yieldCheckTimer === undefined) {
                        car.userData.yieldCheckTimer = 0;
                        car.userData.hasYielded = false; // Track if already yielded to avoid repeated attempts
                    }
                    car.userData.yieldCheckTimer -= delta;
                    
                    emergencyVehicles.forEach(ev => {
                        const evDistZ = car.position.z - ev.position.z; // Positive = emergency is behind
                        const evDistX = Math.abs(car.position.x - ev.position.x);
                        
                        // Yield if emergency is behind (5-40 units) and in nearby lane
                        if (evDistZ > 5 && evDistZ < 40 && evDistX < 5) {
                            // Slow down significantly
                            crashReactionSpeed *= 0.5;
                            
                            // Move aside (change lanes away from emergency)
                            // Use timer-based check instead of per-frame random to avoid frame-rate dependency
                            if (!car.userData.laneChanging && !car.userData.hasYielded && car.userData.yieldCheckTimer <= 0) {
                                car.userData.yieldCheckTimer = 0.3 + Math.random() * 0.4; // Check every 0.3-0.7 seconds
                                
                                // 60% chance to yield on each timed check
                                if (Math.random() < 0.6) {
                                    const yieldDir = car.position.x < ev.position.x ? -1 : 1;
                                    const lanes = [-7.5, -2.5, 2.5, 7.5];
                                    const currentLaneIdx = lanes.findIndex(l => Math.abs(l - car.userData.lane) < 2);
                                    const newLaneIdx = currentLaneIdx + yieldDir;
                                    
                                    if (newLaneIdx >= 0 && newLaneIdx < lanes.length) {
                                        car.userData.targetLane = lanes[newLaneIdx];
                                        car.userData.laneChanging = true;
                                        car.userData.laneChangeProgress = 0;
                                        car.userData.hasYielded = true; // Don't try again for this emergency
                                    }
                                }
                            }
                        } else if (evDistZ >= 40 || evDistZ <= 5) {
                            // Reset yield state when emergency is no longer in range
                            car.userData.hasYielded = false;
                        }
                    });
                }
                
                // === FOLLOWING DISTANCE & GRADUAL SPEED CHANGES ===
                // Check for slower car ahead in same lane
                if (!car.userData.crashed && !car.userData.spinOut) {
                    // Reset target to base speed by default
                    car.userData.targetSpeed = car.userData.baseSpeed || car.userData.speed;
                    
                    // Look for car ahead (same lane, within 30 units ahead)
                    for (let i = 0; i < traffic.length; i++) {
                        const other = traffic[i];
                        if (other === car) continue;
                        
                        // Check if other car is ahead and in same lane
                        const distZ = car.position.z - other.position.z; // Positive = other is ahead
                        const distX = Math.abs(car.position.x - other.position.x);
                        
                        // React if car is 5-30 units ahead and within 3 units laterally (same lane)
                        if (distZ > 5 && distZ < 30 && distX < 3) {
                            // Match speed of car ahead (minus small buffer to maintain distance)
                            const otherSpeed = other.userData.currentSpeed || other.userData.speed || 50;
                            const desiredSpeed = otherSpeed - 5;
                            
                            // Only slow down, don't speed up to match a faster car ahead
                            if (desiredSpeed < car.userData.targetSpeed) {
                                car.userData.targetSpeed = Math.max(15, desiredSpeed); // Minimum 15 mph
                            }
                            break; // Only react to closest car ahead
                        }
                    }
                    
                    // Gradual speed changes (accelerate/decelerate toward target)
                    const accelRate = car.userData.acceleration || 15;
                    const speedDiff = car.userData.targetSpeed - car.userData.currentSpeed;
                    
                    if (Math.abs(speedDiff) > 0.5) {
                        // Smooth acceleration/deceleration
                        const change = Math.sign(speedDiff) * Math.min(Math.abs(speedDiff), accelRate * delta);
                        car.userData.currentSpeed += change;
                    }
                    
                    // Sync legacy speed property
                    car.userData.speed = car.userData.currentSpeed;
                }
                
                // Apply crash/yield reaction speed modifier
                const effectiveSpeed = (car.userData.currentSpeed || car.userData.speed) * crashReactionSpeed;
                car.position.z += moveZ - effectiveSpeed * delta * 0.35;
                
                // --- LANE CHANGE BEHAVIOR ---
                // Initialize lane change state if not present
                if (car.userData.laneChangeTimer === undefined) {
                    car.userData.laneChangeTimer = 2 + Math.random() * 8; // Wait 2-10 seconds before first possible change
                    car.userData.laneChanging = false;
                    car.userData.targetLane = car.userData.lane;
                }
                
                const lanes = [-7.5, -2.5, 2.5, 7.5];
                
                // Only consider lane changes if not already changing and not crashed
                if (!car.userData.laneChanging && !car.userData.crashed && !car.userData.spinOut) {
                    car.userData.laneChangeTimer -= delta;
                    
                    // Time to consider a lane change? (8% chance when timer expires, only when ahead of player)
                    if (car.userData.laneChangeTimer <= 0 && car.position.z < -20 && Math.random() < 0.08) {
                        // Find current lane index
                        const currentLaneIdx = lanes.findIndex(l => Math.abs(l - car.userData.lane) < 1);
                        if (currentLaneIdx !== -1) {
                            // Pick adjacent lane (left or right)
                            const direction = Math.random() > 0.5 ? 1 : -1;
                            const newLaneIdx = currentLaneIdx + direction;
                            
                            // Check if new lane is valid (within road bounds)
                            if (newLaneIdx >= 0 && newLaneIdx < lanes.length) {
                                car.userData.targetLane = lanes[newLaneIdx];
                                car.userData.laneChanging = true;
                                car.userData.laneChangeProgress = 0;
                            }
                        }
                    }
                    
                    // Reset timer for next check
                    if (car.userData.laneChangeTimer <= 0) {
                        car.userData.laneChangeTimer = 3 + Math.random() * 6;
                    }
                }
                
                // Execute lane change (smooth lerp over ~1.5 seconds)
                if (car.userData.laneChanging) {
                    car.userData.laneChangeProgress += delta * 0.7; // Takes ~1.4s to complete
                    const spawnCurve = car.userData.spawnCurveX || 0;
                    
                    if (car.userData.laneChangeProgress >= 1) {
                        // Lane change complete
                        car.userData.lane = car.userData.targetLane;
                        car.userData.baseX = spawnCurve + car.userData.targetLane;
                        car.userData.laneChanging = false;
                        car.userData.laneChangeTimer = 5 + Math.random() * 10; // Longer wait after completing a change
                    } else {
                        // Smooth interpolation between lanes (ease-in-out)
                        const t = car.userData.laneChangeProgress;
                        const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                        const interpolatedLane = car.userData.lane + (car.userData.targetLane - car.userData.lane) * ease;
                        car.userData.baseX = spawnCurve + interpolatedLane;
                    }
                }
                
                // === DYNAMIC LIGHT ANIMATION (Brake lights & Turn signals) ===
                // Only for geometric cars with tracked lights (GLTF cars don't have these)
                if (car.userData.taillights && car.userData.taillights.length > 0) {
                    // --- BRAKE LIGHTS ---
                    // Brighten when car is slowing (crashReactionSpeed < 1 means braking)
                    // Also brighten fully when crashed (car is stopped/spinning)
                    const isBraking = crashReactionSpeed < 0.95 || car.userData.crashed;
                    const targetTailIntensity = isBraking ? 
                        car.userData.brakeLightIntensity || 5.0 : 
                        car.userData.baseTaillightIntensity || 2.0;
                    
                    car.userData.taillights.forEach(light => {
                        if (light.material && light.material.emissiveIntensity !== undefined) {
                            // Smooth transition for natural brake light response
                            const currentIntensity = light.material.emissiveIntensity;
                            const lerpSpeed = isBraking ? 12 : 4; // Snap on quickly, fade off slowly
                            light.material.emissiveIntensity += (targetTailIntensity - currentIntensity) * lerpSpeed * delta;
                        }
                    });
                    
                    // --- TURN SIGNALS ---
                    // Flash when lane changing (determine direction from target vs current lane)
                    if (car.userData.laneChanging && !car.userData.crashed) {
                        // Update blinker phase for flashing (3Hz = typical blinker rate)
                        // Use modulo to keep phase bounded (cleaner than conditional reset)
                        car.userData.blinkerPhase = ((car.userData.blinkerPhase || 0) + delta * 6 * Math.PI) % (Math.PI * 2);
                        
                        const blinkerOn = Math.sin(car.userData.blinkerPhase) > 0;
                        const activeIntensity = car.userData.activeBlinkerIntensity || 4.0;
                        const dimIntensity = car.userData.baseBlinkerIntensity || 0.3;
                        
                        // Determine which side to flash based on lane change direction
                        const changingRight = (car.userData.targetLane || 0) > (car.userData.lane || 0);
                        
                        // Flash the appropriate side, dim the other
                        if (car.userData.rightBlinkers) {
                            const rightIntensity = changingRight ? (blinkerOn ? activeIntensity : dimIntensity) : dimIntensity;
                            car.userData.rightBlinkers.forEach(blinker => {
                                if (blinker.material && blinker.material.emissiveIntensity !== undefined) {
                                    blinker.material.emissiveIntensity = rightIntensity;
                                }
                            });
                        }
                        if (car.userData.leftBlinkers) {
                            const leftIntensity = !changingRight ? (blinkerOn ? activeIntensity : dimIntensity) : dimIntensity;
                            car.userData.leftBlinkers.forEach(blinker => {
                                if (blinker.material && blinker.material.emissiveIntensity !== undefined) {
                                    blinker.material.emissiveIntensity = leftIntensity;
                                }
                            });
                        }
                    } else {
                        // Not lane changing - ensure blinkers are dim
                        const dimIntensity = car.userData.baseBlinkerIntensity || 0.3;
                        if (car.userData.rightBlinkers) {
                            car.userData.rightBlinkers.forEach(blinker => {
                                if (blinker.material && blinker.material.emissiveIntensity !== undefined) {
                                    blinker.material.emissiveIntensity = dimIntensity;
                                }
                            });
                        }
                        if (car.userData.leftBlinkers) {
                            car.userData.leftBlinkers.forEach(blinker => {
                                if (blinker.material && blinker.material.emissiveIntensity !== undefined) {
                                    blinker.material.emissiveIntensity = dimIntensity;
                                }
                            });
                        }
                        // Reset phase for next lane change
                        car.userData.blinkerPhase = 0;
                    }
                }
                
                // Use car's spawn curve for offset (matches road segments - quadratic formula)
                const distFromPlayer = -car.position.z;
                const absDistance = Math.abs(distFromPlayer);
                const lane = car.userData.lane || 0;
                const carCurve = car.userData.spawnCurve !== undefined ? car.userData.spawnCurve : roadCurve;
                // Quadratic curve matching road for smooth parallax (same strength as road)
                const curveStrength = 0.00015;
                let curveOffset = carCurve * absDistance * absDistance * curveStrength;
                curveOffset = Math.sign(curveOffset) * Math.min(Math.abs(curveOffset), 80);
                car.position.x = lane - curveOffset;
                // Cars facing away from player (showing taillights)
                // Both GLTF and geometric cars use +PI/2 for taillights toward camera
                // (Geometric cars: -X is front, +X is rear; +PI/2 rotates rear toward +Z/camera)
                const baseRot = Math.PI / 2;
                // Add slight rotation when lane changing (car turns into the direction of change)
                let laneChangeRotation = 0;
                if (car.userData.laneChanging) {
                    const changeDir = car.userData.targetLane > car.userData.lane ? -1 : 1;
                    // Subtle turn during the middle of lane change (peaks at 50% progress)
                    const progress = car.userData.laneChangeProgress || 0;
                    laneChangeRotation = changeDir * 0.08 * Math.sin(progress * Math.PI);
                }
                // Car rotation follows curve with distance-based scaling for perspective
                const rotationScale = Math.min(1, absDistance / 100);
                car.rotation.y = baseRot + carCurve * 0.15 * rotationScale * Math.sign(distFromPlayer) + laneChangeRotation;
                
                // Tighter collision - must actually be close to hit
                const dx = Math.abs(playerX - car.position.x);
                const dz = Math.abs(car.position.z);
                const dy = Math.abs(playerCar.position.y - car.position.y);
                
                // Solid collision - push player away if too close (prevent clipping)
                if (dx < 2.2 && dz < 3.0 && dy < 1.5) {
                    // Push player away from car to prevent clipping through
                    const pushX = Math.sign(playerX - car.position.x) * (2.2 - dx) * 0.5;
                    playerX += pushX;
                }
                
                // Only collide if within 1.8 units X, 2.5 units Z, and 1.5 units Y (tighter box)
                if (dx < 1.8 && dz < 2.5 && dy < 1.5 && crashCooldown <= 0 && !car.userData.crashed) {
                    car.userData.crashed = true;
                    
                    // === COLLISION ANGLE ANALYSIS ===
                    // Calculate relative position to determine collision type
                    const relativeX = playerX - car.position.x; // Positive = player is to the right
                    const relativeZ = car.position.z; // Negative = car is ahead, positive = car is behind
                    const collisionAngle = Math.atan2(Math.abs(relativeX), Math.abs(relativeZ));
                    
                    // Categorize collision type based on angle and relative positions
                    const isSideswipe = collisionAngle > 0.5 && collisionAngle < 1.2; // ~30-70 degrees
                    const isRearEnd = collisionAngle < 0.3 && relativeZ < 0; // Hit from behind (car ahead)
                    const isHeadOn = collisionAngle < 0.3 && relativeZ > 0; // Rare: hit car coming toward us
                    const trafficSpeed = car.userData.currentSpeed || car.userData.speed || 50;
                    const impactForce = Math.abs(speed - trafficSpeed) / maxSpeed;
                    
                    // === COLLISION-TYPE SPECIFIC RESPONSE ===
                    if (isSideswipe) {
                        // Glancing blow - less speed penalty, push player laterally
                        speed *= 0.85;
                        time -= 1;
                        // Push player away from collision
                        const pushDir = Math.sign(relativeX); // Push away from car
                        playerX += pushDir * (1.5 + impactForce);
                        triggerCrash('SCRAPE!', 0.4);
                        spawnSparks(car.position.x + relativeX * 0.5, car.position.z, 12, 'sideswipe');
                        // Traffic car gets nudged too
                        car.userData.spinDir = -pushDir;
                        car.userData.spinOut = true;
                        playerRecoveryTime = 0.3; // Brief loss of control
                    } else if (isRearEnd) {
                        // Rear-ended a slower car - moderate impact, transfer momentum
                        const speedDiff = speed - trafficSpeed;
                        speed = Math.max(speed * 0.6, trafficSpeed * 0.8);
                        time -= 2;
                        // Push the traffic car forward
                        car.userData.currentSpeed = (car.userData.currentSpeed || 50) + speedDiff * 0.3;
                        triggerCrash('BUMP!', 0.6);
                        spawnSparks(car.position.x, car.position.z + 1, 8, 'rearend');
                        car.userData.spinOut = false; // Bumped car doesn't spin, just accelerates
                        playerRecoveryTime = 0.4;
                        // Slight random deflection
                        playerX += (Math.random() - 0.5) * 1.5;
                    } else {
                        // Head-on or severe T-bone - heavy penalty
                        speed *= 0.3;
                        time -= 3;
                        // Random deflection from severe impact
                        playerX += (Math.random() - 0.5) * 3;
                        triggerCrash('CRASH!', 1.0);
                        spawnSparks(car.position.x, car.position.z, 20, 'headon');
                        car.userData.spinOut = true;
                        car.userData.spinDir = playerX > car.position.x ? 1 : -1;
                        playerRecoveryTime = 0.6; // Longer recovery for bad crashes
                    }
                    
                    // Record crash site so nearby traffic can react!
                    crashSites.push({
                        x: car.position.x,
                        z: car.position.z,
                        time: 8.0, // Crash site affects traffic for 8 seconds
                        lane: car.userData.lane
                    });
                }
                
                if (car.userData.spinOut) {
                    car.rotation.y += car.userData.spinDir * delta * 5;
                    car.position.x += car.userData.spinDir * delta * 10;
                }
                
                if (!car.userData.passed && !car.userData.crashed && car.position.z > 3) {
                    car.userData.passed = true;
                    carsPassed++;
                    
                    // TUNED SCORING: Speed bonus rewards aggressive play!
                    // Base points + speed bonus (10% of current speed added to score)
                    // At 200mph: base + 20 bonus. At 300mph with nitro: base + 30 bonus
                    const speedBonus = Math.floor(speed * 0.1);
                    
                    // Emergency vehicles give HUGE bonus!
                    if (car.userData.isEmergency) {
                        const total = 600 + speedBonus; // Boosted from 500
                        score += total;
                        announce(`üö® OVERTOOK EMERGENCY! +${total}`, 800);
                    } else {
                        const total = 175 + speedBonus; // Boosted from 150, plus speed bonus
                        score += total;
                        // Only show score in announce if going fast (less visual spam)
                        if (speed > 150) {
                            announce(`PASSED! +${total}`, 400);
                        }
                    }
                }
            });
            traffic = traffic.filter(car => { if (car.position.z > 90) { removeAndDispose(car); return false; } return true; });
            
            // Move landmarks - smooth curve transition
            landmarks.forEach(lm => {
                lm.position.z += moveZ;
                const distFromPlayer = -lm.position.z;
                const absDistance = Math.abs(distFromPlayer);
                const aheadMult = 0.0004, behindMult = 0.0002, blendRange = 15;
                const blendFactor = Math.max(0, Math.min(1, (distFromPlayer + blendRange) / (2 * blendRange)));
                const curveMultiplier = behindMult + (aheadMult - behindMult) * blendFactor;
                const curveOffset = roadCurve * absDistance * absDistance * curveMultiplier;
                if (lm.userData.baseX === undefined) {
                    lm.userData.baseX = lm.position.x;
                }
                lm.position.x = lm.userData.baseX - curveOffset;
            });
            landmarks = landmarks.filter(lm => { if (lm.position.z > 150) { removeAndDispose(lm); return false; } return true; });
            
            // Move checkpoint gates - smooth curve transition
            checkpointGates.forEach(gate => {
                gate.position.z += moveZ;
                const distFromPlayer = -gate.position.z;
                const absDistance = Math.abs(distFromPlayer);
                const aheadMult = 0.0004, behindMult = 0.0002, blendRange = 15;
                const blendFactor = Math.max(0, Math.min(1, (distFromPlayer + blendRange) / (2 * blendRange)));
                const curveMultiplier = behindMult + (aheadMult - behindMult) * blendFactor;
                const curveOffset = roadCurve * absDistance * absDistance * curveMultiplier;
                if (gate.userData.baseX === undefined) {
                    gate.userData.baseX = gate.position.x;
                }
                gate.position.x = gate.userData.baseX - curveOffset;
            });
            checkpointGates = checkpointGates.filter(gate => { 
                if (gate.position.z > 100) { 
                    removeAndDispose(gate); 
                    return false; 
                } 
                return true; 
            });
            
            // Move background mountains with camera (parallax - depth-based movement)
            backgroundMountains.forEach(mountain => {
                if (mountain.userData.baseX === undefined) {
                    mountain.userData.baseX = mountain.position.x;
                    mountain.userData.baseZ = mountain.position.z;
                }
                // Parallax factor based on distance - further mountains move slower
                // Creates depth illusion: distant mountains barely move, closer ones shift more
                const depthFactor = Math.abs(mountain.userData.baseZ) / 400; // 0.5-1.0 range
                const parallaxX = 0.95 - depthFactor * 0.3; // Further = less X movement
                
                // X follows camera for horizon stability - creates parallax panning effect
                mountain.position.x = mountain.userData.baseX + camera.position.x * parallaxX;
                // Z stays fixed - mountains on horizon shouldn't drift forward/back
                // This prevents the visual "popping" that occurred with the old Z drift/reset logic
            });
            
            // Move city silhouettes with camera (similar to clouds - appear stationary on horizon)
            citySilhouettes.forEach(city => {
                if (city.userData.baseX === undefined) {
                    city.userData.baseX = city.position.x;
                }
                // City skyline follows camera X to appear fixed on the distant horizon
                city.position.x = city.userData.baseX + camera.position.x;
            });
            
            particles.forEach(p => { 
                if (p.userData && p.userData.vel) {
                    p.position.add(p.userData.vel); 
                    p.userData.vel.y -= 0.015; 
                    p.userData.life -= delta; 
                } else {
                    // Mark invalid particle for removal
                    if (!p.userData) p.userData = {};
                    p.userData.life = -1;
                }
            });
            particles = particles.filter(p => { if (!p.userData || p.userData.life <= 0) { removeAndDispose(p); return false; } return true; });
            
            // Keep road extending ahead - spawn new segments as needed
            // lastRoadZ tracks where the FAR EDGE of the last segment is (in world coordinates)
            // As segments move toward player (their z increases), we need to update lastRoadZ accordingly
            lastRoadZ += moveZ;
            
            // Ensure we always have road extending at least 600 units ahead
            // Use a slightly larger buffer to prevent any gaps
            while (lastRoadZ > -650) createRoadSegment();
            
            // Safety check: ensure lastRoadZ doesn't drift too far
            // This prevents accumulating floating point errors over long play sessions
            if (roadSegments.length > 0) {
                // Find the furthest segment's position
                let minZ = 0;
                roadSegments.forEach(seg => {
                    if (seg.position.z < minZ) minZ = seg.position.z;
                });
                // lastRoadZ should be approximately minZ - 17.5 (half segment length)
                // If it's drifted, correct it
                const expectedLastRoadZ = minZ - 17.5;
                if (Math.abs(lastRoadZ - expectedLastRoadZ) > 35) {
                    lastRoadZ = expectedLastRoadZ;
                }
            }
            
            // Update weather/atmosphere particles
            updateWeatherParticles(delta);
            
            // Update animated windmills
            updateWindmills(delta);
            
            // Animate wheels (player car and traffic)
            animateWheels(delta);
            
            // HUD (using cached updates to avoid redundant DOM writes)
            hudCache.updateSpeed(speed);
            hudCache.updateScore(score);
            
            // Update audio engine
            updateAudio();
            
            // Debug display
            const sectionName = currentSection ? currentSection.name : 'none';
            document.getElementById('debug-info').innerHTML =
                `Speed: ${Math.floor(speed)} | Section: ${sectionName}<br>` +
                `Curve: ${roadCurve.toFixed(3)} ‚Üí ${roadCurveTarget.toFixed(3)} | Bank: ${(banking * 180/Math.PI).toFixed(1)}¬∞ | Elev: ${elevation.toFixed(1)}<br>` +
                `Segments: ${roadSegments.length} | Delta: ${delta.toFixed(3)}`;

            // Log curve transitions to console
            if (Math.abs(roadCurveTarget - roadCurve) > 0.05) {
                console.log(`[CURVE] section="${sectionName}" curve=${roadCurve.toFixed(3)} target=${roadCurveTarget.toFixed(3)} delta=${delta.toFixed(3)} segments=${roadSegments.length}`);
            }
            
            updateMinimap();
        }
        
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 140; canvas.height = 140;
            
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, 140, 140);
            
            // Draw curved road with proper perspective
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 50;
            ctx.beginPath();
            ctx.moveTo(70, 145);
            // Bezier curve for smooth road
            ctx.bezierCurveTo(
                70, 100,
                70 - roadCurve * 200, 50,
                70 - roadCurve * 350, -10
            );
            ctx.stroke();
            
            // Road edges
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 3;
            [-22, 22].forEach(offset => {
                ctx.beginPath();
                ctx.moveTo(70 + offset, 145);
                ctx.bezierCurveTo(
                    70 + offset, 100,
                    70 + offset - roadCurve * 200, 50,
                    70 + offset - roadCurve * 350, -10
                );
                ctx.stroke();
            });
            
            // Player
            ctx.fillStyle = '#ff0';
            ctx.shadowColor = '#ff0';
            ctx.shadowBlur = 8;
            ctx.fillRect(65 + playerX * 2, 115, 10, 16);
            ctx.shadowBlur = 0;
            
            // Traffic on the curved road
            ctx.fillStyle = '#f33';
            traffic.forEach(car => {
                const dist = -car.position.z;
                const ty = 115 - dist * 0.6;
                // Position along the curve
                const curveAmount = roadCurve * dist * dist * 0.00015;
                const tx = 65 + (car.userData.baseX || 0) * 2 - curveAmount * 100;
                if (ty > -15 && ty < 140) ctx.fillRect(tx, ty, 9, 13);
            });
        }
        
        // Leaderboard
        let leaderboard = [];
        
        function loadLeaderboard() {
            try {
                const saved = localStorage.getItem('cruisinLeaderboard');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Validate that parsed data is an array with valid entries
                    if (Array.isArray(parsed)) {
                        leaderboard = parsed.filter(entry => 
                            entry && typeof entry.score === 'number' && typeof entry.name === 'string'
                        );
                    }
                }
            } catch (e) {
                console.warn('Failed to load leaderboard:', e);
                leaderboard = [];
            }
        }
        
        function saveLeaderboard() {
            try {
                localStorage.setItem('cruisinLeaderboard', JSON.stringify(leaderboard));
            } catch (e) {
                console.warn('Failed to save leaderboard:', e);
            }
        }
        
        function showLeaderboard() {
            const tbody = document.getElementById('leaderboard-body');
            tbody.innerHTML = '';
            
            leaderboard.slice(0, 10).forEach((entry, i) => {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td class="rank">${i + 1}</td><td>${entry.name}</td><td>${countries[entry.country]?.flag || 'üèÅ'}</td><td class="score">${entry.score}</td>`;
                tbody.appendChild(tr);
            });
            
            if (leaderboard.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;color:#666">No scores yet!</td></tr>';
            }
            
            document.getElementById('leaderboard').classList.add('show');
        }
        
        function hideLeaderboard() {
            document.getElementById('leaderboard').classList.remove('show');
        }
        
        function isHighScore() {
            // If leaderboard is empty or has fewer than 10 entries, any score qualifies
            if (!leaderboard || leaderboard.length === 0) return score > 0;
            if (leaderboard.length < 10) return score > 0;
            // Otherwise, must beat the lowest score on the board
            const lowestEntry = leaderboard[leaderboard.length - 1];
            return lowestEntry && typeof lowestEntry.score === 'number' && score > lowestEntry.score;
        }
        
        function submitScore() {
            const nameInputEl = document.getElementById('name-input');
            const name = (nameInputEl ? nameInputEl.value.trim() : '') || 'Anonymous';
            
            // Validate score before adding to leaderboard
            if (typeof score === 'number' && score > 0) {
                leaderboard.push({ name, score, country: selectedCountry || 'usa' });
                leaderboard.sort((a, b) => b.score - a.score);
                leaderboard = leaderboard.slice(0, 10);
                saveLeaderboard();
            }
            
            restartGame();
        }
        
        function gameOver() {
            gameRunning = false;
            
            // Defensive DOM updates - check elements exist before updating
            const finalScoreEl = document.getElementById('final-score');
            const finalDistanceEl = document.getElementById('final-distance');
            const finalPassedEl = document.getElementById('final-passed');
            const finalCountriesEl = document.getElementById('final-countries');
            const newRecordEl = document.getElementById('new-record');
            const nameInputEl = document.getElementById('name-input');
            const gameOverEl = document.getElementById('game-over');
            
            if (finalScoreEl) finalScoreEl.textContent = score;
            if (finalDistanceEl) finalDistanceEl.textContent = distance.toFixed(1);
            if (finalPassedEl) finalPassedEl.textContent = carsPassed;
            if (finalCountriesEl) finalCountriesEl.textContent = countriesVisited;
            if (newRecordEl) newRecordEl.style.display = isHighScore() ? 'block' : 'none';
            if (nameInputEl) nameInputEl.value = '';
            if (gameOverEl) gameOverEl.classList.remove('hidden');
        }
        
        // === AUDIO SYSTEM FUNCTIONS ===
        function initAudio() {
            if (audioInitialized) return;
            
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Engine sound using sawtooth oscillator (V8 rumble character)
                engineOscillator = audioContext.createOscillator();
                engineOscillator.type = 'sawtooth';
                engineOscillator.frequency.value = 60; // Base idle frequency
                
                // Low-pass filter to smooth the harshness
                engineFilter = audioContext.createBiquadFilter();
                engineFilter.type = 'lowpass';
                engineFilter.frequency.value = 800;
                engineFilter.Q.value = 1;
                
                // Gain node for volume control
                engineGain = audioContext.createGain();
                engineGain.gain.value = 0; // Start silent
                
                // Connect the audio graph: oscillator -> filter -> gain -> output
                engineOscillator.connect(engineFilter);
                engineFilter.connect(engineGain);
                engineGain.connect(audioContext.destination);
                
                // Start the oscillator (runs continuously, volume controls audibility)
                engineOscillator.start();
                
                audioInitialized = true;
                console.log('Audio system initialized');
            } catch (e) {
                console.warn('Audio initialization failed:', e);
            }
        }
        
        function updateAudio() {
            if (!audioContext || !audioInitialized || !gameRunning || audioMuted) {
                // Silence when not playing
                if (engineGain && audioContext) {
                    engineGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
                }
                return;
            }
            
            // Engine pitch scales with speed: 60Hz (idle) to 200Hz (max speed)
            const speedRatio = Math.max(0, speed) / maxSpeed;
            const targetFreq = 60 + speedRatio * 140;
            engineOscillator.frequency.setTargetAtTime(targetFreq, audioContext.currentTime, 0.1);
            
            // Filter opens up at higher speeds for more aggressive tone
            const filterFreq = 600 + speedRatio * 1200;
            engineFilter.frequency.setTargetAtTime(filterFreq, audioContext.currentTime, 0.1);
            
            // Volume: louder when accelerating, quieter when coasting
            // Base volume scales with speed, throttle adds presence
            const baseVolume = 0.03 + speedRatio * 0.07;
            const throttleBoost = isAccel ? 0.05 : 0;
            const boostBoost = isBoosting && boost > 0 ? 0.03 : 0;
            const targetGain = Math.min(0.18, baseVolume + throttleBoost + boostBoost);
            
            engineGain.gain.setTargetAtTime(targetGain, audioContext.currentTime, 0.1);
        }

        function toggleSound() {
            audioMuted = !audioMuted;
            document.getElementById('sound-toggle').textContent = audioMuted ? 'üîá' : 'üîä';
            if (audioMuted && engineGain && audioContext) {
                engineGain.gain.setTargetAtTime(0, audioContext.currentTime, 0.05);
            }
        }

        function onKeyDown(e) {
            // Initialize audio on first user interaction (browser requirement)
            if (!audioInitialized) initAudio();
            
            console.log('KeyDown:', e.code, 'gameRunning:', gameRunning);
            if (e.code === 'KeyW' || e.code === 'ArrowUp') isAccel = true;
            if (e.code === 'KeyS' || e.code === 'ArrowDown') isBrake = true;
            if (e.code === 'KeyA' || e.code === 'ArrowLeft') isLeft = true;
            if (e.code === 'KeyD' || e.code === 'ArrowRight') isRight = true;
            if (e.code === 'Space') { isBoosting = true; e.preventDefault(); }
        }
        
        function onKeyUp(e) {
            if (e.code === 'KeyW' || e.code === 'ArrowUp') isAccel = false;
            if (e.code === 'KeyS' || e.code === 'ArrowDown') isBrake = false;
            if (e.code === 'KeyA' || e.code === 'ArrowLeft') isLeft = false;
            if (e.code === 'KeyD' || e.code === 'ArrowRight') isRight = false;
            if (e.code === 'Space') isBoosting = false;
        }
        
        // Touch controls for mobile
        let touchStartX = 0;
        function setupTouchControls() {
            const container = document.getElementById('game-container');
            
            container.addEventListener('touchstart', (e) => {
                // Initialize audio on first touch (browser requirement)
                if (!audioInitialized) initAudio();
                
                if (!gameRunning) return;
                e.preventDefault();
                isAccel = true; // Always accelerate while touching
                touchStartX = e.touches[0].clientX;
                
                // Boost if touching right side of screen
                if (e.touches[0].clientX > window.innerWidth * 0.8) {
                    isBoosting = true;
                }
            }, { passive: false });
            
            container.addEventListener('touchmove', (e) => {
                if (!gameRunning) return;
                e.preventDefault();
                const touchX = e.touches[0].clientX;
                const diff = touchX - touchStartX;
                const threshold = 20;
                
                isLeft = diff < -threshold;
                isRight = diff > threshold;
            }, { passive: false });
            
            container.addEventListener('touchend', (e) => {
                isAccel = false;
                isLeft = false;
                isRight = false;
                isBoosting = false;
            });
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function startGame() {
            // Initialize audio on game start (browser requires user interaction)
            if (!audioInitialized) initAudio();
            
            const startScreenEl = document.getElementById('start-screen');
            if (startScreenEl) startScreenEl.classList.add('hidden');
            
            // Ensure canvas has focus for keyboard input
            if (renderer && renderer.domElement) {
                renderer.domElement.tabIndex = 0;
                renderer.domElement.focus();
            }
            
            score = 0; time = 65; distance = 0; carsPassed = 0; topSpeed = 0; countriesVisited = 1; // Tuned starting time
            speed = 0; steering = 0; playerX = 0;
            boost = 100; checkpointDist = 500;
            crashCooldown = 0; screenShake = 0;
            playerRecoveryTime = 0; // Reset collision recovery
            
            // Reset weight transfer physics
            weightTransferPitch = 0; weightTransferRoll = 0; gripFactor = 1.0;
            hudCache.reset(); // Reset HUD cache for fresh DOM updates
            
            // Reset input states (in case keys were held when previous game ended)
            isAccel = false; isBrake = false; isLeft = false; isRight = false;
            isBoosting = false;
            roadCurve = 0; roadCurveTarget = 0;
            elevation = 0; elevationTarget = 0; banking = 0;
            trackSection = 0; sectionDistance = 0;
            
            // Reset road transition tracking for smooth segment generation
            currentRoadWidth = 24; targetRoadWidth = 24;
            currentSurface = 'asphalt'; targetSurface = 'asphalt';
            lastSegmentWidth = 24; lastSegmentBanking = 0; lastSegmentElevation = 0;
            playerAirborne = false; airTime = 0; verticalVelocity = 0;
            nextCheckpointSpawn = 400; // Reset checkpoint gate spawning
            lastEmergencySpawn = 0; // Reset emergency vehicle spawning
            
            // Clear crash sites and emergency vehicle tracking
            crashSites = [];
            emergencyVehicles = [];
            
            // Clear landmarks (with proper disposal to prevent memory leaks)
            landmarks.forEach(lm => removeAndDispose(lm));
            landmarks = [];
            
            // Clear checkpoint gates
            checkpointGates.forEach(gate => removeAndDispose(gate));
            checkpointGates = [];
            
            // Clear background mountains (will be recreated by setCountry)
            backgroundMountains.forEach(m => removeAndDispose(m));
            backgroundMountains = [];
            
            // Clear old track if exists
            if (trackMesh) {
                removeAndDispose(trackMesh);
                trackMesh = null;
            }
            visitedCountries = new Set([selectedCountry]);
            
            // Dispose all game objects to prevent memory leaks on restart
            traffic.forEach(c => removeAndDispose(c));
            roadSegments.forEach(r => removeAndDispose(r));
            scenery.forEach(s => removeAndDispose(s));
            particles.forEach(p => removeAndDispose(p));
            iconicLandmarks.forEach(l => removeAndDispose(l));
            weatherParticles.forEach(w => removeAndDispose(w));
            citySilhouettes.forEach(c => removeAndDispose(c));
            animatedWindmills.forEach(w => removeAndDispose(w));
            traffic = []; roadSegments = []; scenery = []; particles = [];
            iconicLandmarks = []; weatherParticles = []; citySilhouettes = [];
            animatedWindmills = [];
            
            setCountry(selectedCountry);
            createPlayerCar();
            generateInitialRoad();
            
            announce('3', 900);
            setTimeout(() => announce('2', 900), 900);
            setTimeout(() => announce('1', 900), 1800);
            setTimeout(() => { announce('GO!', 1000); gameRunning = true; }, 2700);
        }
        
        function restartGame() {
            const gameOverEl = document.getElementById('game-over');
            const startScreenEl = document.getElementById('start-screen');
            if (gameOverEl) gameOverEl.classList.add('hidden');
            if (startScreenEl) startScreenEl.classList.remove('hidden');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            
            // Update debug info based on state
            if (!gameRunning) {
                const carStatus = gltfCarModel ? 'GLTF Cop Car ‚úì' : 'Wedge Car (fallback)';
                document.getElementById('debug-info').innerHTML = `Ready | ${carStatus} | Click START RACE`;
            }
            
            updateGame(delta);
            renderer.render(scene, camera);
        }
        
        init();
    </script>
</body>
</html>
