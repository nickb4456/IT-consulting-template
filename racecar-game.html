<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon-192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.png">
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="shortcut icon" href="/favicon.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>APEX DRIFT ‚Äî 3D Racing</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; cursor: default; }
  canvas { display: block; }

  #blocker {
    position: fixed; inset: 0; z-index: 100;
    background: radial-gradient(ellipse at 30% 40%, #1a0a2e 0%, #0a0014 50%, #000 100%);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    transition: opacity 0.8s ease;
  }
  #blocker.hidden { opacity: 0; pointer-events: none; }

  #blocker h1 {
    font-size: 5rem; font-weight: 900; letter-spacing: 0.3em;
    background: linear-gradient(135deg, #ff2d55, #ff6b35, #ffcc02, #ff2d55);
    background-size: 300% 300%;
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    animation: shimmer 3s ease infinite;
    margin-bottom: 0.1em;
  }
  #blocker h2 {
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.1rem; color: #ff6b35; letter-spacing: 0.5em;
    margin-bottom: 1.5em; opacity: 0.8;
  }

  @keyframes shimmer {
    0%,100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }

  /* Car Selection */
  #car-select {
    display: flex; gap: 2em; margin-bottom: 2em; justify-content: center;
  }
  .car-option {
    width: 200px; padding: 1.2em; text-align: center;
    background: rgba(255,255,255,0.04); border: 2px solid rgba(255,255,255,0.1);
    border-radius: 16px; cursor: pointer; transition: all 0.3s ease;
    position: relative;
  }
  .car-option:hover {
    border-color: rgba(255,107,53,0.5);
    background: rgba(255,107,53,0.08);
    transform: translateY(-4px);
  }
  .car-option.selected {
    border-color: #ff6b35;
    background: rgba(255,107,53,0.15);
    box-shadow: 0 0 30px rgba(255,107,53,0.2);
  }
  .car-option.selected::after {
    content: '‚úì'; position: absolute; top: 8px; right: 12px;
    color: #ff6b35; font-size: 1.2rem; font-weight: 900;
  }
  .car-preview {
    width: 160px; height: 100px; margin: 0 auto 0.8em;
    background: rgba(255,255,255,0.03); border-radius: 10px;
    display: flex; align-items: center; justify-content: center;
    overflow: hidden;
  }
  .car-preview canvas { width: 100%; height: 100%; }
  .car-name {
    font-size: 1rem; font-weight: 700; color: #fff;
    margin-bottom: 0.3em; letter-spacing: 0.1em;
  }
  .car-desc {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem; color: #888; line-height: 1.4;
  }

  #loading-text {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.9rem; color: #ff6b35; margin-bottom: 2em;
    letter-spacing: 0.2em;
  }

  .controls-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 1em 3em;
    margin-bottom: 2em;
  }
  .control-item {
    display: flex; align-items: center; gap: 1em;
    font-family: 'Share Tech Mono', monospace; font-size: 0.8rem; color: #aaa;
  }
  .key-badge {
    background: linear-gradient(180deg, #2a2a3a, #1a1a2a);
    border: 1px solid #444; border-radius: 6px;
    padding: 0.3em 0.7em; color: #ff6b35; font-weight: 700;
    min-width: 2.2em; text-align: center;
    box-shadow: 0 2px 0 #000, inset 0 1px 0 rgba(255,255,255,0.05);
  }

  #start-btn {
    font-family: 'Orbitron', sans-serif; font-size: 1.2rem; font-weight: 700;
    background: linear-gradient(135deg, #ff2d55, #ff6b35);
    color: #fff; border: none; padding: 1em 3em;
    border-radius: 50px; cursor: pointer; letter-spacing: 0.2em;
    box-shadow: 0 0 40px rgba(255,45,85,0.3), 0 4px 15px rgba(0,0,0,0.5);
    transition: all 0.3s ease;
    display: none; /* hidden until models load */
  }
  #start-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 60px rgba(255,45,85,0.5), 0 6px 20px rgba(0,0,0,0.5);
  }
  #start-btn.visible { display: inline-block; }

  /* HUD */
  #hud {
    position: fixed; inset: 0; z-index: 10; pointer-events: none;
    opacity: 0; transition: opacity 0.5s;
  }
  #hud.visible { opacity: 1; }

  #speedo {
    position: absolute; bottom: 30px; right: 30px;
    width: 200px; height: 200px;
  }
  #speedo canvas { width: 100%; height: 100%; }

  #lap-info {
    position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
    text-align: center;
  }
  #lap-info .lap-num {
    font-size: 1.4rem; font-weight: 700; color: #fff;
    text-shadow: 0 0 20px rgba(255,107,53,0.5);
  }
  #lap-info .lap-time {
    font-family: 'Share Tech Mono', monospace;
    font-size: 2.2rem; color: #ffcc02;
    text-shadow: 0 0 15px rgba(255,204,2,0.4);
  }
  #lap-info .best-time {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.9rem; color: #888; margin-top: 4px;
  }

  #minimap {
    position: absolute; top: 20px; right: 20px;
    width: 160px; height: 160px;
    background: rgba(0,0,0,0.6); border: 1px solid rgba(255,107,53,0.3);
    border-radius: 10px; overflow: hidden;
  }
  #minimap canvas { width: 100%; height: 100%; }

  #gear-display {
    position: absolute; bottom: 40px; right: 240px;
    font-size: 3rem; font-weight: 900; color: #ff2d55;
    text-shadow: 0 0 20px rgba(255,45,85,0.5);
    opacity: 0.9;
  }

  #drift-indicator {
    position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
    font-size: 1.8rem; font-weight: 900; color: #ffcc02;
    text-shadow: 0 0 30px rgba(255,204,2,0.6);
    opacity: 0; transition: opacity 0.2s;
    letter-spacing: 0.3em;
  }
  #drift-indicator.active { opacity: 1; }

  #speed-lines {
    position: fixed; inset: 0; pointer-events: none; z-index: 5;
    opacity: 0; transition: opacity 0.3s;
  }

  #countdown {
    position: fixed; inset: 0; z-index: 50;
    display: flex; align-items: center; justify-content: center;
    font-size: 8rem; font-weight: 900; color: #fff;
    text-shadow: 0 0 60px rgba(255,45,85,0.8);
    pointer-events: none; opacity: 0;
  }

  #lap-flash {
    position: fixed; inset: 0; z-index: 15; pointer-events: none;
    background: radial-gradient(ellipse, rgba(255,204,2,0.15), transparent 70%);
    opacity: 0; transition: opacity 0.1s;
  }

  #position-bar {
    position: absolute; top: 80px; left: 20px;
    font-family: 'Share Tech Mono', monospace;
  }
  .pos-item {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 0; font-size: 0.8rem;
  }
  .pos-dot {
    width: 8px; height: 8px; border-radius: 50%;
  }
  .pos-name { color: #aaa; }
  .pos-name.player { color: #ff6b35; font-weight: 700; }
</style>
</head>
<body>

<div id="blocker">
  <h1>APEX DRIFT</h1>
  <h2>3D RACING</h2>
  <div id="loading-text">LOADING VEHICLES...</div>
  <div id="car-select" style="display:none">
    <div class="car-option selected" data-car="0" onclick="selectCar(0)">
      <div class="car-preview" id="preview-0"></div>
      <div class="car-name">CONVERTIBLE</div>
      <div class="car-desc">Open top cruiser<br>Balanced handling</div>
    </div>
    <div class="car-option" data-car="1" onclick="selectCar(1)">
      <div class="car-preview" id="preview-1"></div>
      <div class="car-name">JEEP</div>
      <div class="car-desc">Off-road beast<br>Heavy &amp; tough</div>
    </div>
    <div class="car-option" data-car="2" onclick="selectCar(2)">
      <div class="car-preview" id="preview-2"></div>
      <div class="car-name">RACECAR</div>
      <div class="car-desc">Pure speed<br>Sharp cornering</div>
    </div>
  </div>
  <div class="controls-grid">
    <div class="control-item"><span class="key-badge">W / ‚Üë</span> Accelerate</div>
    <div class="control-item"><span class="key-badge">S / ‚Üì</span> Brake / Reverse</div>
    <div class="control-item"><span class="key-badge">A / ‚Üê</span> Steer Left</div>
    <div class="control-item"><span class="key-badge">D / ‚Üí</span> Steer Right</div>
    <div class="control-item"><span class="key-badge">SPACE</span> Handbrake / Drift</div>
    <div class="control-item"><span class="key-badge">R</span> Reset Car</div>
  </div>
  <button id="start-btn">START RACE</button>
</div>

<div id="hud">
  <div id="lap-info">
    <div class="lap-num">LAP <span id="lap-current">0</span> / <span id="lap-total">3</span></div>
    <div class="lap-time" id="lap-timer">0:00.000</div>
    <div class="best-time">BEST: <span id="best-time">--:--.---</span></div>
  </div>
  <div id="minimap"><canvas id="minimap-canvas" width="320" height="320"></canvas></div>
  <div id="speedo"><canvas id="speedo-canvas" width="400" height="400"></canvas></div>
  <div id="gear-display">1</div>
  <div id="drift-indicator">DRIFT!</div>
  <div id="position-bar"></div>
</div>

<div id="speed-lines"></div>
<div id="countdown"></div>
<div id="lap-flash"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
// ============================================================
// APEX DRIFT ‚Äî Full 3D Racing Game with GLB Models
// ============================================================

const { Scene, PerspectiveCamera, WebGLRenderer, Vector3, Vector2,
  CatmullRomCurve3, MeshStandardMaterial, MeshPhongMaterial, MeshBasicMaterial,
  BoxGeometry, CylinderGeometry, SphereGeometry, PlaneGeometry, CircleGeometry,
  Mesh, Group, AmbientLight, DirectionalLight, HemisphereLight, PointLight,
  FogExp2, Color, Raycaster, BufferGeometry, BufferAttribute, Float32BufferAttribute,
  DoubleSide, FrontSide, BackSide, Shape, ShapeGeometry, ExtrudeGeometry,
  TextureLoader, RepeatWrapping, MathUtils, Clock, LineBasicMaterial, Line,
  AdditiveBlending, NormalBlending, Box3 } = THREE;

// ---- GLB Car Models ----
const CAR_DEFS = [
  { name: 'CONVERTIBLE', file: 'https://draftbridge-addin.s3.amazonaws.com/assets/Meshy_AI_make_a_convertible_b_0216034646_texture.glb', color: '#ff6b35' },
  { name: 'JEEP', file: 'https://draftbridge-addin.s3.amazonaws.com/assets/Meshy_AI_Make_a_black_jeep_for_0216034637_texture.glb', color: '#3388FF' },
  { name: 'RACECAR', file: 'https://draftbridge-addin.s3.amazonaws.com/assets/Meshy_AI_Make_a_red_racecar_0216034631_texture.glb', color: '#ff2d55' },
];
const loadedModels = [null, null, null]; // Stores the loaded GLTF scenes
let selectedCarIndex = 0;

// ---- Audio Context ----
let audioCtx = null;
let engineOsc = null, engineGain = null;
let screeching = false, screechNode = null, screechGain = null;

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  engineOsc = audioCtx.createOscillator();
  engineOsc.type = 'sawtooth';
  engineOsc.frequency.value = 80;
  engineGain = audioCtx.createGain();
  engineGain.gain.value = 0.06;
  const engineFilter = audioCtx.createBiquadFilter();
  engineFilter.type = 'lowpass';
  engineFilter.frequency.value = 600;
  engineOsc.connect(engineFilter);
  engineFilter.connect(engineGain);
  engineGain.connect(audioCtx.destination);
  engineOsc.start();
}

function updateEngineSound(speed, maxSpeed) {
  if (!audioCtx) return;
  const ratio = Math.abs(speed) / maxSpeed;
  engineOsc.frequency.value = 60 + ratio * 300;
  engineGain.gain.value = 0.03 + ratio * 0.07;
}

function startScreech() {
  if (!audioCtx || screeching) return;
  screeching = true;
  screechNode = audioCtx.createOscillator();
  screechNode.type = 'sawtooth';
  screechNode.frequency.value = 200 + Math.random() * 100;
  screechGain = audioCtx.createGain();
  screechGain.gain.value = 0.04;
  const filter = audioCtx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 800;
  filter.Q.value = 5;
  screechNode.connect(filter);
  filter.connect(screechGain);
  screechGain.connect(audioCtx.destination);
  screechNode.start();
}

function stopScreech() {
  if (!screeching || !screechNode) return;
  screeching = false;
  try { screechGain.gain.value = 0; screechNode.stop(); } catch(e) {}
}

// ---- Scene Setup ----
const scene = new Scene();
scene.background = new Color(0x87CEEB);
scene.fog = new FogExp2(0x87CEEB, 0.0008);

const camera = new PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

// ---- Lighting ----
const ambientLight = new AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const hemiLight = new HemisphereLight(0x87CEEB, 0x556B2F, 0.4);
scene.add(hemiLight);

const sunLight = new DirectionalLight(0xFFF5E1, 1.2);
sunLight.position.set(200, 300, 100);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 10;
sunLight.shadow.camera.far = 800;
sunLight.shadow.camera.left = -400;
sunLight.shadow.camera.right = 400;
sunLight.shadow.camera.top = 400;
sunLight.shadow.camera.bottom = -400;
scene.add(sunLight);

// ---- Track Definition ----
const trackPoints = [
  new Vector3(0, 0, 0),
  new Vector3(80, 0, -30),
  new Vector3(160, 0, -20),
  new Vector3(220, 0, 30),
  new Vector3(250, 0, 110),
  new Vector3(230, 0, 200),
  new Vector3(170, 0, 250),
  new Vector3(80, 0, 230),
  new Vector3(30, 0, 280),
  new Vector3(-40, 0, 320),
  new Vector3(-120, 0, 290),
  new Vector3(-170, 0, 220),
  new Vector3(-200, 0, 130),
  new Vector3(-220, 0, 40),
  new Vector3(-180, 0, -30),
  new Vector3(-100, 0, -60),
  new Vector3(-40, 0, -40),
];

const trackCurve = new CatmullRomCurve3(trackPoints, true, 'catmullrom', 0.5);
const TRACK_WIDTH = 22;
const CURB_WIDTH = 2;
const TRACK_SEGMENTS = 600;
const ROAD_Y = 0.15;

// ---- Build Track Mesh ----
function buildTrack() {
  const roadGeo = new BufferGeometry();
  const roadVerts = [], roadColors = [], roadIndices = [];

  const edgeLGeo = new BufferGeometry();
  const edgeLVerts = [];
  const edgeRGeo = new BufferGeometry();
  const edgeRVerts = [];
  const EDGE_LINE_W = 0.4;

  const curbLGeo = new BufferGeometry();
  const curbLVerts = [], curbLColors = [];
  const curbRGeo = new BufferGeometry();
  const curbRVerts = [], curbRColors = [];

  for (let i = 0; i <= TRACK_SEGMENTS; i++) {
    const t = i / TRACK_SEGMENTS;
    const p = trackCurve.getPointAt(t);
    const tangent = trackCurve.getTangentAt(t).normalize();
    const normal = new Vector3(-tangent.z, 0, tangent.x);

    const left = p.clone().add(normal.clone().multiplyScalar(TRACK_WIDTH / 2));
    const right = p.clone().add(normal.clone().multiplyScalar(-TRACK_WIDTH / 2));

    roadVerts.push(left.x, ROAD_Y, left.z, right.x, ROAD_Y, right.z);

    const v = 0.18 + Math.random() * 0.06;
    roadColors.push(v, v, v * 0.95, v, v, v * 0.95);

    if (i < TRACK_SEGMENTS) {
      const base = i * 2;
      roadIndices.push(base, base + 1, base + 2, base + 1, base + 3, base + 2);
    }

    const elInner = left.clone().sub(normal.clone().multiplyScalar(EDGE_LINE_W));
    const erInner = right.clone().add(normal.clone().multiplyScalar(EDGE_LINE_W));
    edgeLVerts.push(left.x, ROAD_Y + 0.01, left.z, elInner.x, ROAD_Y + 0.01, elInner.z);
    edgeRVerts.push(right.x, ROAD_Y + 0.01, right.z, erInner.x, ROAD_Y + 0.01, erInner.z);

    const curbOuterL = left.clone().add(normal.clone().multiplyScalar(CURB_WIDTH));
    const curbOuterR = right.clone().add(normal.clone().multiplyScalar(-CURB_WIDTH));

    curbLVerts.push(left.x, ROAD_Y + 0.01, left.z, curbOuterL.x, ROAD_Y - 0.05, curbOuterL.z);
    curbRVerts.push(right.x, ROAD_Y + 0.01, right.z, curbOuterR.x, ROAD_Y - 0.05, curbOuterR.z);

    const segColor = (Math.floor(i / 6) % 2 === 0) ? [1, 0.15, 0.1] : [1, 1, 1];
    curbLColors.push(...segColor, ...segColor);
    curbRColors.push(...segColor, ...segColor);
  }

  roadGeo.setAttribute('position', new Float32BufferAttribute(roadVerts, 3));
  roadGeo.setAttribute('color', new Float32BufferAttribute(roadColors, 3));
  roadGeo.setIndex(roadIndices);
  roadGeo.computeVertexNormals();

  const roadMat = new MeshStandardMaterial({ vertexColors: true, roughness: 0.92, metalness: 0.0 });
  const roadMesh = new Mesh(roadGeo, roadMat);
  roadMesh.receiveShadow = true;
  scene.add(roadMesh);

  [{ geo: edgeLGeo, verts: edgeLVerts }, { geo: edgeRGeo, verts: edgeRVerts }].forEach(({ geo, verts }) => {
    geo.setAttribute('position', new Float32BufferAttribute(verts, 3));
    const indices = [];
    for (let i = 0; i < TRACK_SEGMENTS; i++) {
      const b = i * 2;
      indices.push(b, b + 1, b + 2, b + 1, b + 3, b + 2);
    }
    geo.setIndex(indices);
    geo.computeVertexNormals();
    const mat = new MeshStandardMaterial({ color: 0xDDDDDD, roughness: 0.5 });
    scene.add(new Mesh(geo, mat));
  });

  [{ geo: curbLGeo, verts: curbLVerts, colors: curbLColors },
   { geo: curbRGeo, verts: curbRVerts, colors: curbRColors }].forEach(({ geo, verts, colors }) => {
    geo.setAttribute('position', new Float32BufferAttribute(verts, 3));
    geo.setAttribute('color', new Float32BufferAttribute(colors, 3));
    const indices = [];
    for (let i = 0; i < TRACK_SEGMENTS; i++) {
      const b = i * 2;
      indices.push(b, b + 1, b + 2, b + 1, b + 3, b + 2);
    }
    geo.setIndex(indices);
    geo.computeVertexNormals();
    const mat = new MeshStandardMaterial({ vertexColors: true, roughness: 0.6 });
    const mesh = new Mesh(geo, mat);
    mesh.receiveShadow = true;
    scene.add(mesh);
  });

  // Start/finish line
  const startP = trackCurve.getPointAt(0);
  const startTan = trackCurve.getTangentAt(0).normalize();
  const startNorm = new Vector3(-startTan.z, 0, startTan.x);

  const sfGeo = new PlaneGeometry(TRACK_WIDTH, 4);
  const sfMat = new MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.5 });
  const sfMesh = new Mesh(sfGeo, sfMat);
  sfMesh.rotation.x = -Math.PI / 2;
  sfMesh.position.set(startP.x, ROAD_Y + 0.02, startP.z);
  sfMesh.rotation.z = -Math.atan2(startTan.z, startTan.x);
  sfMesh.receiveShadow = true;
  scene.add(sfMesh);

  for (let cx = -5; cx < 5; cx++) {
    for (let cz = 0; cz < 2; cz++) {
      if ((cx + cz) % 2 === 0) {
        const checkGeo = new PlaneGeometry(TRACK_WIDTH / 10, 2);
        const checkMat = new MeshStandardMaterial({ color: 0x111111 });
        const checkMesh = new Mesh(checkGeo, checkMat);
        checkMesh.rotation.x = -Math.PI / 2;
        const offset = startNorm.clone().multiplyScalar((cx + 0.5) * TRACK_WIDTH / 10);
        const fwdOffset = startTan.clone().multiplyScalar((cz - 0.5) * 2);
        checkMesh.position.set(startP.x + offset.x + fwdOffset.x, ROAD_Y + 0.03, startP.z + offset.z + fwdOffset.z);
        checkMesh.rotation.z = -Math.atan2(startTan.z, startTan.x);
        scene.add(checkMesh);
      }
    }
  }

  // Center line dashes
  for (let i = 0; i < TRACK_SEGMENTS; i += 8) {
    if (i % 16 < 8) {
      const t1 = i / TRACK_SEGMENTS;
      const t2 = Math.min((i + 4) / TRACK_SEGMENTS, 1);
      const p1 = trackCurve.getPointAt(t1);
      const p2 = trackCurve.getPointAt(t2);
      const mid = p1.clone().add(p2).multiplyScalar(0.5);
      const dir = p2.clone().sub(p1);
      const len = dir.length();

      const dashGeo = new PlaneGeometry(0.4, len);
      const dashMat = new MeshStandardMaterial({ color: 0xCCCCCC, roughness: 0.5 });
      const dashMesh = new Mesh(dashGeo, dashMat);
      dashMesh.rotation.x = -Math.PI / 2;
      dashMesh.position.set(mid.x, ROAD_Y + 0.02, mid.z);
      dashMesh.rotation.z = -Math.atan2(dir.z, dir.x) + Math.PI / 2;
      scene.add(dashMesh);
    }
  }
}

// ---- Ground ----
function buildGround() {
  const groundGeo = new PlaneGeometry(1200, 1200);
  const groundMat = new MeshStandardMaterial({ color: 0x4a7c3f, roughness: 0.95 });
  const ground = new Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.1;
  ground.receiveShadow = true;
  scene.add(ground);
}

// ---- Trackside Objects ----
function buildTrackside() {
  const treeMat = new MeshStandardMaterial({ color: 0x2d5a1e });
  const trunkMat = new MeshStandardMaterial({ color: 0x5a3a1a });

  for (let i = 0; i < 120; i++) {
    const t = Math.random();
    const p = trackCurve.getPointAt(t);
    const tan = trackCurve.getTangentAt(t).normalize();
    const normal = new Vector3(-tan.z, 0, tan.x);
    const side = Math.random() > 0.5 ? 1 : -1;
    const dist = TRACK_WIDTH / 2 + CURB_WIDTH + 8 + Math.random() * 60;

    const pos = p.clone().add(normal.clone().multiplyScalar(side * dist));
    const tree = new Group();

    const trunkH = 3 + Math.random() * 4;
    const trunk = new Mesh(new CylinderGeometry(0.3, 0.5, trunkH, 6), trunkMat);
    trunk.position.y = trunkH / 2;
    trunk.castShadow = true;
    tree.add(trunk);

    const foliageR = 2 + Math.random() * 2;
    const foliage = new Mesh(new SphereGeometry(foliageR, 8, 6), treeMat.clone());
    foliage.material.color.setHSL(0.28 + Math.random() * 0.08, 0.6, 0.25 + Math.random() * 0.15);
    foliage.position.y = trunkH + foliageR * 0.6;
    foliage.castShadow = true;
    tree.add(foliage);

    tree.position.copy(pos);
    scene.add(tree);
  }

  // Barriers along sharp turns
  const barrierMat = new MeshStandardMaterial({ color: 0xCC0000 });
  const barrierWhiteMat = new MeshStandardMaterial({ color: 0xEEEEEE });

  for (let i = 0; i < TRACK_SEGMENTS; i += 3) {
    const t1 = ((i - 2 + TRACK_SEGMENTS) % TRACK_SEGMENTS) / TRACK_SEGMENTS;
    const t2 = ((i + 2) % TRACK_SEGMENTS) / TRACK_SEGMENTS;
    const tan1 = trackCurve.getTangentAt(t1);
    const tan2 = trackCurve.getTangentAt(t2);
    const curvature = 1 - tan1.dot(tan2);

    if (curvature > 0.015) {
      const t = i / TRACK_SEGMENTS;
      const p = trackCurve.getPointAt(t);
      const tan = trackCurve.getTangentAt(t).normalize();
      const normal = new Vector3(-tan.z, 0, tan.x);

      for (const side of [-1, 1]) {
        const bPos = p.clone().add(normal.clone().multiplyScalar(side * (TRACK_WIDTH / 2 + CURB_WIDTH + 1.5)));
        const barrier = new Mesh(
          new BoxGeometry(1, 1.2, 3),
          (Math.floor(i / 6) % 2 === 0) ? barrierMat : barrierWhiteMat
        );
        barrier.position.copy(bPos);
        barrier.position.y = 0.6;
        barrier.rotation.y = Math.atan2(tan.x, tan.z);
        barrier.castShadow = true;
        scene.add(barrier);
      }
    }
  }

  // Grandstand
  const standGeo = new BoxGeometry(40, 8, 6);
  const standMat = new MeshStandardMaterial({ color: 0x888899 });
  const stand = new Mesh(standGeo, standMat);
  stand.position.set(0, 4, -30);
  stand.castShadow = true;
  scene.add(stand);

  const roofGeo = new BoxGeometry(44, 0.5, 8);
  const roofMat = new MeshStandardMaterial({ color: 0xDD3333 });
  const roof = new Mesh(roofGeo, roofMat);
  roof.position.set(0, 9, -30);
  scene.add(roof);
}

// ---- Normalize a GLB model to fit a standard car size ----
function normalizeModel(model, targetSize) {
  const box = new Box3().setFromObject(model);
  const size = new Vector3();
  box.getSize(size);
  const maxDim = Math.max(size.x, size.y, size.z);
  const scale = targetSize / maxDim;
  model.scale.set(scale, scale, scale);

  // Recalculate after scale
  const box2 = new Box3().setFromObject(model);
  const center = new Vector3();
  box2.getCenter(center);
  const min = box2.min;

  // Center horizontally, sit on ground
  model.position.x = -center.x;
  model.position.z = -center.z;
  model.position.y = -min.y;

  // Enable shadows
  model.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
      child.receiveShadow = true;
    }
  });

  return model;
}

// ---- Create a car wrapper group from a loaded model ----
function createCarFromModel(modelIndex) {
  const car = new Group();
  const modelClone = loadedModels[modelIndex].clone();

  // Deep clone materials and brighten car textures
  modelClone.traverse(child => {
    if (child.isMesh) {
      child.material = child.material.clone();
      child.castShadow = true;
      // Brighten dark GLB materials ‚Äî reduce metalness, boost color
      if (child.material.isMeshStandardMaterial) {
        child.material.metalness = Math.min(child.material.metalness, 0.4);
        child.material.roughness = Math.max(child.material.roughness, 0.3);
        child.material.envMapIntensity = 2.0;
      }
    }
  });

  normalizeModel(modelClone, 12); // car size in world units
  // Rotate GLB model to face forward along +Z
  modelClone.rotation.y = Math.PI / 2;
  car.add(modelClone);
  car.userData.modelIndex = modelIndex;
  return car;
}

// ---- Smoke Particles ----
const smokeParticles = [];
const smokeGeo = new SphereGeometry(0.3, 4, 4);
const smokeMat = new MeshBasicMaterial({ color: 0xcccccc, transparent: true, opacity: 0.5 });

function spawnSmoke(pos) {
  if (smokeParticles.length > 60) return;
  const p = new Mesh(smokeGeo, smokeMat.clone());
  p.position.copy(pos);
  p.position.y = 0.3;
  p.userData.life = 1.0;
  p.userData.vel = new Vector3((Math.random() - 0.5) * 0.5, 0.5 + Math.random() * 0.5, (Math.random() - 0.5) * 0.5);
  scene.add(p);
  smokeParticles.push(p);
}

function updateSmoke(dt) {
  for (let i = smokeParticles.length - 1; i >= 0; i--) {
    const p = smokeParticles[i];
    p.userData.life -= dt * 1.5;
    p.position.add(p.userData.vel.clone().multiplyScalar(dt));
    p.scale.setScalar(1 + (1 - p.userData.life) * 2);
    p.material.opacity = p.userData.life * 0.4;
    if (p.userData.life <= 0) {
      scene.remove(p);
      smokeParticles.splice(i, 1);
    }
  }
}

// ---- Game State ----
const keys = {};
const MAX_SPEED = 120;
const ACCELERATION = 45;
const BRAKE_FORCE = 60;
const FRICTION = 12;
const TOTAL_LAPS = 3;

let gameState = 'menu';
let speed = 0;
let steerAngle = 0;
let carAngle = 0;
let driftAmount = 0;
let lapCount = 0;
let lapStartTime = 0;
let bestLapTime = Infinity;
let raceStartTime = 0;
let lastCheckpointT = 0;
let handbrakeActive = false;

// AI racers
const aiCars = [];
const aiStates = [];

let playerCar;

// ---- Car Selection ----
function selectCar(index) {
  selectedCarIndex = index;
  document.querySelectorAll('.car-option').forEach((el, i) => {
    el.classList.toggle('selected', i === index);
  });
}

// ---- Load GLB Models ----
function loadAllModels() {
  const loader = new THREE.GLTFLoader();
  let loaded = 0;

  CAR_DEFS.forEach((def, i) => {
    loader.load(
      def.file,
      (gltf) => {
        loadedModels[i] = gltf.scene;
        loaded++;
        document.getElementById('loading-text').textContent = `LOADED ${loaded}/3 VEHICLES...`;

        if (loaded === 3) {
          onAllModelsLoaded();
        }
      },
      undefined,
      (err) => {
        console.error(`Failed to load ${def.file}:`, err);
        // Fallback: create a primitive car
        const fallback = new Group();
        const body = new Mesh(
          new BoxGeometry(2, 0.7, 4.5),
          new MeshStandardMaterial({ color: parseInt(def.color.replace('#', '0x')) })
        );
        body.position.y = 0.6;
        fallback.add(body);
        const cabin = new Mesh(
          new BoxGeometry(1.6, 0.5, 1.8),
          new MeshStandardMaterial({ color: 0x222244 })
        );
        cabin.position.set(0, 1.15, -0.3);
        fallback.add(cabin);
        loadedModels[i] = fallback;
        loaded++;
        if (loaded === 3) onAllModelsLoaded();
      }
    );
  });
}

function onAllModelsLoaded() {
  document.getElementById('loading-text').style.display = 'none';
  document.getElementById('car-select').style.display = 'flex';
  document.getElementById('start-btn').classList.add('visible');

  // Create preview renders for each car
  CAR_DEFS.forEach((def, i) => {
    createPreview(i);
  });
}

// ---- Preview renders for selection screen ----
function createPreview(index) {
  const container = document.getElementById(`preview-${index}`);
  const w = 320, h = 200;

  const prevRenderer = new WebGLRenderer({ antialias: true, alpha: true });
  prevRenderer.setSize(w, h);
  prevRenderer.setPixelRatio(2);
  prevRenderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(prevRenderer.domElement);

  const prevScene = new Scene();
  prevScene.add(new AmbientLight(0xffffff, 1.0));
  const dLight = new DirectionalLight(0xffffff, 1.2);
  dLight.position.set(5, 8, 5);
  prevScene.add(dLight);
  const dLight2 = new DirectionalLight(0xffffff, 0.6);
  dLight2.position.set(-5, 4, -3);
  prevScene.add(dLight2);

  const prevCam = new PerspectiveCamera(40, w / h, 0.1, 100);
  prevCam.position.set(4, 3, 5);
  prevCam.lookAt(0, 0.5, 0);

  const model = loadedModels[index].clone();
  normalizeModel(model, 5);
  prevScene.add(model);

  // Render once + rotate animation
  let angle = 0;
  function animatePreview() {
    requestAnimationFrame(animatePreview);
    angle += 0.008;
    model.rotation.y = angle;
    prevRenderer.render(prevScene, prevCam);
  }
  animatePreview();
}

// ---- Init Game ----
function initGame() {
  buildGround();
  buildTrack();
  buildTrackside();

  // Player gets selected car
  playerCar = createCarFromModel(selectedCarIndex);
  const startPos = trackCurve.getPointAt(0);
  const startTan = trackCurve.getTangentAt(0);
  playerCar.position.copy(startPos);
  playerCar.position.y = ROAD_Y;
  carAngle = Math.atan2(startTan.x, startTan.z);
  playerCar.rotation.y = carAngle;
  scene.add(playerCar);

  // Other cars become AI
  const aiModelIndices = [];
  for (let i = 0; i < 3; i++) {
    if (i !== selectedCarIndex) aiModelIndices.push(i);
  }

  const AI_NAMES_LIST = ['NOVA', 'BLITZ', 'VENOM'];
  aiModelIndices.forEach((modelIdx, i) => {
    const ai = createCarFromModel(modelIdx);
    const offset = 0.01 + i * 0.015;
    const aiPos = trackCurve.getPointAt(offset);
    ai.position.copy(aiPos);
    ai.position.y = ROAD_Y;
    const aiTan = trackCurve.getTangentAt(offset);
    ai.rotation.y = Math.atan2(aiTan.x, aiTan.z);

    const norm = new Vector3(-aiTan.z, 0, aiTan.x).normalize();
    ai.position.add(norm.multiplyScalar((i % 2 === 0 ? -1 : 1) * 5));

    scene.add(ai);
    aiCars.push(ai);
    aiStates.push({
      t: offset,
      speed: 0,
      baseSpeed: 55 + Math.random() * 20,
      wobble: Math.random() * 1000,
      lapCount: 0,
      lastT: offset,
      name: AI_NAMES_LIST[i] || CAR_DEFS[modelIdx].name,
      color: CAR_DEFS[modelIdx].color,
    });
  });

  camera.position.set(startPos.x, 8, startPos.z - 15);
  camera.lookAt(startPos);
}

// ---- HUD Drawing ----
const speedoCanvas = document.getElementById('speedo-canvas');
const speedoCtx = speedoCanvas.getContext('2d');

function drawSpeedometer(speedKmh) {
  const ctx = speedoCtx;
  const w = 400, h = 400;
  const cx = w / 2, cy = h / 2 + 20;
  const r = 150;

  ctx.clearRect(0, 0, w, h);

  ctx.beginPath();
  ctx.arc(cx, cy, r, Math.PI * 0.8, Math.PI * 2.2, false);
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 20;
  ctx.stroke();

  const maxAngle = Math.PI * 1.4;
  const speedRatio = Math.min(Math.abs(speedKmh) / 280, 1);
  const sweepAngle = speedRatio * maxAngle;

  const gradient = ctx.createLinearGradient(0, 0, w, 0);
  gradient.addColorStop(0, '#33CC55');
  gradient.addColorStop(0.5, '#FFCC00');
  gradient.addColorStop(1, '#FF2D55');

  ctx.beginPath();
  ctx.arc(cx, cy, r, Math.PI * 0.8, Math.PI * 0.8 + sweepAngle, false);
  ctx.strokeStyle = gradient;
  ctx.lineWidth = 20;
  ctx.lineCap = 'round';
  ctx.stroke();

  for (let i = 0; i <= 280; i += 20) {
    const a = Math.PI * 0.8 + (i / 280) * maxAngle;
    const inner = r - 30;
    const outer = i % 60 === 0 ? r - 10 : r - 20;
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(a) * inner, cy + Math.sin(a) * inner);
    ctx.lineTo(cx + Math.cos(a) * outer, cy + Math.sin(a) * outer);
    ctx.strokeStyle = i % 60 === 0 ? '#fff' : 'rgba(255,255,255,0.3)';
    ctx.lineWidth = i % 60 === 0 ? 2.5 : 1.5;
    ctx.stroke();

    if (i % 60 === 0) {
      ctx.font = '16px Orbitron';
      ctx.fillStyle = '#aaa';
      ctx.textAlign = 'center';
      ctx.fillText(i.toString(), cx + Math.cos(a) * (inner - 18), cy + Math.sin(a) * (inner - 18) + 5);
    }
  }

  const needleAngle = Math.PI * 0.8 + speedRatio * maxAngle;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(needleAngle) * (r - 35), cy + Math.sin(needleAngle) * (r - 35));
  ctx.strokeStyle = '#FF2D55';
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(cx, cy, 8, 0, Math.PI * 2);
  ctx.fillStyle = '#FF2D55';
  ctx.fill();

  ctx.font = 'bold 48px Orbitron';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText(Math.floor(Math.abs(speedKmh)).toString(), cx, cy + 60);

  ctx.font = '14px Share Tech Mono';
  ctx.fillStyle = '#888';
  ctx.fillText('KM/H', cx, cy + 80);
}

// Minimap
const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');
let minimapTrackPoints = [];

function initMinimap() {
  const pts = trackCurve.getPoints(200);
  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
  pts.forEach(p => {
    minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
    minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
  });
  const padding = 30;
  const rangeX = maxX - minX + padding * 2;
  const rangeZ = maxZ - minZ + padding * 2;
  const scale = 300 / Math.max(rangeX, rangeZ);

  minimapTrackPoints = pts.map(p => ({
    x: 10 + (p.x - minX + padding) * scale,
    y: 10 + (p.z - minZ + padding) * scale,
  }));
  minimapTrackPoints.scale = scale;
  minimapTrackPoints.minX = minX - padding;
  minimapTrackPoints.minZ = minZ - padding;
}

function drawMinimap() {
  const ctx = minimapCtx;
  ctx.clearRect(0, 0, 320, 320);

  ctx.beginPath();
  minimapTrackPoints.forEach((p, i) => {
    i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
  });
  ctx.closePath();
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 6;
  ctx.stroke();

  const s = minimapTrackPoints.scale;
  const oX = minimapTrackPoints.minX;
  const oZ = minimapTrackPoints.minZ;

  aiCars.forEach((ai, i) => {
    const mx = 10 + (ai.position.x - oX) * s;
    const my = 10 + (ai.position.z - oZ) * s;
    ctx.beginPath();
    ctx.arc(mx, my, 4, 0, Math.PI * 2);
    ctx.fillStyle = aiStates[i].color;
    ctx.fill();
  });

  const px = 10 + (playerCar.position.x - oX) * s;
  const py = 10 + (playerCar.position.z - oZ) * s;
  ctx.beginPath();
  ctx.arc(px, py, 5, 0, Math.PI * 2);
  ctx.fillStyle = '#FF2D55';
  ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

// ---- Lap Timer ----
function formatTime(ms) {
  if (ms === Infinity || ms <= 0) return '--:--.---';
  const mins = Math.floor(ms / 60000);
  const secs = Math.floor((ms % 60000) / 1000);
  const millis = Math.floor(ms % 1000);
  return `${mins}:${secs.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
}

// ---- Find closest point on track ----
function getTrackT(pos) {
  let bestT = 0, bestDist = Infinity;
  for (let i = 0; i <= 200; i++) {
    const t = i / 200;
    const p = trackCurve.getPointAt(t);
    const d = pos.distanceTo(p);
    if (d < bestDist) { bestDist = d; bestT = t; }
  }
  for (let i = -20; i <= 20; i++) {
    const t = bestT + i / 4000;
    const tt = ((t % 1) + 1) % 1;
    const p = trackCurve.getPointAt(tt);
    const d = pos.distanceTo(p);
    if (d < bestDist) { bestDist = d; bestT = tt; }
  }
  return bestT;
}

// ---- Position ranking ----
function getPositions() {
  const racers = [];
  const playerT = getTrackT(playerCar.position);
  racers.push({
    name: 'YOU',
    progress: lapCount + playerT,
    color: CAR_DEFS[selectedCarIndex].color,
    isPlayer: true
  });
  aiStates.forEach((ai, i) => {
    racers.push({
      name: ai.name,
      progress: ai.lapCount + ai.t,
      color: ai.color,
      isPlayer: false
    });
  });
  racers.sort((a, b) => b.progress - a.progress);
  return racers;
}

function updatePositionBar() {
  const positions = getPositions();
  const bar = document.getElementById('position-bar');
  bar.innerHTML = positions.map((r, i) =>
    `<div class="pos-item">
      <span style="color:${r.color};font-weight:700;width:24px;">${i + 1}.</span>
      <span class="pos-dot" style="background:${r.color}"></span>
      <span class="pos-name ${r.isPlayer ? 'player' : ''}">${r.name}</span>
    </div>`
  ).join('');
}

// ---- Input ----
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.code] = false; });

// ---- Start ----
document.getElementById('start-btn').addEventListener('click', () => {
  initAudio();
  initGame();
  initMinimap();
  document.getElementById('blocker').classList.add('hidden');
  startCountdown();
});

function startCountdown() {
  gameState = 'countdown';
  document.getElementById('hud').classList.add('visible');

  const countEl = document.getElementById('countdown');
  const steps = ['3', '2', '1', 'GO!'];
  let step = 0;

  function nextStep() {
    if (step >= steps.length) {
      countEl.style.opacity = '0';
      gameState = 'racing';
      raceStartTime = performance.now();
      lapStartTime = raceStartTime;
      lapCount = 1;
      lastCheckpointT = 0;
      return;
    }
    countEl.textContent = steps[step];
    countEl.style.opacity = '1';
    countEl.style.color = step === 3 ? '#33CC55' : '#fff';
    countEl.style.transform = 'scale(1.5)';
    countEl.style.transition = 'transform 0.4s ease-out, opacity 0.3s';
    setTimeout(() => {
      countEl.style.transform = 'scale(0.8)';
      countEl.style.opacity = '0.5';
    }, 500);
    step++;
    setTimeout(nextStep, 1000);
  }
  nextStep();
}

// ---- Game Loop ----
const clock = new Clock();
let frameCount = 0;

function gameLoop() {
  requestAnimationFrame(gameLoop);
  const dt = Math.min(clock.getDelta(), 0.05);
  frameCount++;

  if (gameState === 'racing') {
    updatePlayer(dt);
    updateAI(dt);
    checkLap();
    updateSmoke(dt);
    updateEngineSound(speed, MAX_SPEED);

    const now = performance.now();
    const elapsed = now - lapStartTime;
    document.getElementById('lap-timer').textContent = formatTime(elapsed);
    document.getElementById('lap-current').textContent = Math.min(lapCount, TOTAL_LAPS);

    const speedKmh = Math.abs(speed) * 2.4;
    drawSpeedometer(speedKmh);

    const gear = speed < 0 ? 'R' : speed < 5 ? '1' : speed < 20 ? '2' : speed < 40 ? '3' : speed < 65 ? '4' : speed < 90 ? '5' : '6';
    document.getElementById('gear-display').textContent = gear;

    const driftEl = document.getElementById('drift-indicator');
    driftEl.classList.toggle('active', driftAmount > 0.3);

    if (frameCount % 5 === 0) {
      drawMinimap();
      updatePositionBar();
    }

    const speedLineEl = document.getElementById('speed-lines');
    if (Math.abs(speed) > 80) {
      speedLineEl.style.opacity = (Math.abs(speed) - 80) / 40 * 0.3;
      speedLineEl.style.background = `radial-gradient(ellipse at center, transparent 30%, rgba(255,255,255,${(Math.abs(speed) - 80) / 40 * 0.08}) 100%)`;
    } else {
      speedLineEl.style.opacity = '0';
    }
  } else if (gameState === 'countdown') {
    drawSpeedometer(0);
    if (frameCount % 10 === 0) drawMinimap();
  }

  if (playerCar) updateCamera(dt);
  renderer.render(scene, camera);
}

// ---- Player Update ----
function updatePlayer(dt) {
  const accel = keys['ArrowUp'] || keys['KeyW'];
  const brake = keys['ArrowDown'] || keys['KeyS'];
  const left = keys['ArrowLeft'] || keys['KeyA'];
  const right = keys['ArrowRight'] || keys['KeyD'];
  handbrakeActive = keys['Space'];

  // Reset
  if (keys['KeyR'] && gameState === 'racing') {
    const t = getTrackT(playerCar.position);
    const p = trackCurve.getPointAt(t);
    const tan = trackCurve.getTangentAt(t);
    playerCar.position.copy(p);
    playerCar.position.y = ROAD_Y;
    carAngle = Math.atan2(tan.x, tan.z);
    speed = 0;
    steerAngle = 0;
    driftAmount = 0;
  }

  // Acceleration
  if (accel) {
    speed += ACCELERATION * dt;
  } else if (brake) {
    if (speed > 2) {
      speed -= BRAKE_FORCE * dt;
    } else {
      speed -= ACCELERATION * 0.5 * dt;
    }
  } else {
    if (Math.abs(speed) > 0.5) {
      speed -= Math.sign(speed) * FRICTION * dt;
    } else {
      speed = 0;
    }
  }

  speed = MathUtils.clamp(speed, -30, MAX_SPEED);

  // Steering ‚Äî smooth buildup
  const speedRatio = Math.abs(speed) / MAX_SPEED;
  const maxSteer = 0.035;
  const steerRate = 1.8 * dt;

  if (left) steerAngle = Math.min(steerAngle + steerRate, maxSteer);
  else if (right) steerAngle = Math.max(steerAngle - steerRate, -maxSteer);
  else steerAngle *= 0.88;

  const speedFactor = Math.min(Math.abs(speed) / 10, 1);
  const turnMultiplier = handbrakeActive ? 2.0 : (1.5 - speedRatio * 0.5);
  const turnRate = steerAngle * turnMultiplier * speedFactor;
  carAngle += turnRate * Math.sign(speed);

  // Drift physics
  if (handbrakeActive && Math.abs(speed) > 15) {
    driftAmount = MathUtils.lerp(driftAmount, 1, dt * 5);
    speed *= (1 - dt * 0.3);

    if (frameCount % 2 === 0) {
      const backL = new Vector3(-1, 0, -2).applyAxisAngle(new Vector3(0, 1, 0), carAngle).add(playerCar.position);
      const backR = new Vector3(1, 0, -2).applyAxisAngle(new Vector3(0, 1, 0), carAngle).add(playerCar.position);
      spawnSmoke(backL);
      spawnSmoke(backR);
    }

    if (!screeching) startScreech();
  } else if (Math.abs(steerAngle) > 0.015 && Math.abs(speed) > 50) {
    driftAmount = MathUtils.lerp(driftAmount, 0.4, dt * 3);
    if (frameCount % 4 === 0) {
      const back = new Vector3(Math.sign(steerAngle) * 1, 0, -2).applyAxisAngle(new Vector3(0, 1, 0), carAngle).add(playerCar.position);
      spawnSmoke(back);
    }
  } else {
    driftAmount = MathUtils.lerp(driftAmount, 0, dt * 4);
    stopScreech();
  }

  // Move car
  const moveDir = new Vector3(Math.sin(carAngle), 0, Math.cos(carAngle));
  playerCar.position.add(moveDir.multiplyScalar(speed * dt));
  playerCar.position.y = ROAD_Y;

  // Car visual rotation
  playerCar.rotation.y = carAngle;

  // Body lean
  const leanTarget = -steerAngle * 4 * speedFactor;
  playerCar.rotation.z = MathUtils.lerp(playerCar.rotation.z, MathUtils.clamp(leanTarget, -0.12, 0.12), dt * 6);

  // Drift visual yaw offset
  const driftYaw = driftAmount * steerAngle * -8;
  playerCar.rotation.y = carAngle + MathUtils.clamp(driftYaw, -0.25, 0.25);

  // Keep on track
  const trackT = getTrackT(playerCar.position);
  const trackPoint = trackCurve.getPointAt(trackT);
  const distFromCenter = playerCar.position.distanceTo(trackPoint);
  if (distFromCenter > TRACK_WIDTH / 2 + 5) {
    const pushDir = trackPoint.clone().sub(playerCar.position).normalize();
    playerCar.position.add(pushDir.multiplyScalar(dt * 20));
    speed *= 0.97;
  }
}

// ---- AI Update ----
function updateAI(dt) {
  aiStates.forEach((ai, i) => {
    const lookAhead = (ai.t + 0.02) % 1;
    const tan1 = trackCurve.getTangentAt(ai.t);
    const tan2 = trackCurve.getTangentAt(lookAhead);
    const curvature = 1 - tan1.dot(tan2);

    let targetSpeed = ai.baseSpeed;
    if (curvature > 0.01) targetSpeed *= 0.65;
    else if (curvature > 0.005) targetSpeed *= 0.8;

    targetSpeed += Math.sin(performance.now() * 0.001 + ai.wobble) * 5;
    ai.speed = MathUtils.lerp(ai.speed, targetSpeed, dt * 2);

    const trackLen = trackCurve.getLength();
    const advanceT = (ai.speed * dt) / trackLen;

    ai.lastT = ai.t;
    ai.t = (ai.t + advanceT) % 1;

    if (ai.lastT > 0.95 && ai.t < 0.05) {
      ai.lapCount++;
    }

    const pos = trackCurve.getPointAt(ai.t);
    const tan = trackCurve.getTangentAt(ai.t);

    const norm = new Vector3(-tan.z, 0, tan.x).normalize();
    const lateralOffset = Math.sin(ai.t * Math.PI * 8 + ai.wobble) * 3;
    pos.add(norm.multiplyScalar(lateralOffset));

    aiCars[i].position.copy(pos);
    aiCars[i].position.y = ROAD_Y;
    aiCars[i].rotation.y = Math.atan2(tan.x, tan.z);

    const crossProduct = tan1.x * tan2.z - tan1.z * tan2.x;
    aiCars[i].rotation.z = MathUtils.lerp(aiCars[i].rotation.z, -crossProduct * 3, dt * 5);
  });
}

// ---- Lap Check ----
function checkLap() {
  const currentT = getTrackT(playerCar.position);

  if (lastCheckpointT > 0.9 && currentT < 0.1) {
    const now = performance.now();
    const lapTime = now - lapStartTime;

    if (lapTime > 5000) {
      if (lapTime < bestLapTime) {
        bestLapTime = lapTime;
        document.getElementById('best-time').textContent = formatTime(bestLapTime);
      }

      const flash = document.getElementById('lap-flash');
      flash.style.opacity = '1';
      setTimeout(() => flash.style.opacity = '0', 300);

      lapCount++;
      lapStartTime = now;

      if (lapCount > TOTAL_LAPS) {
        gameState = 'finished';
        showFinish();
      }
    }
  }

  lastCheckpointT = currentT;
}

function showFinish() {
  const positions = getPositions();
  const playerPos = positions.findIndex(r => r.isPlayer) + 1;

  const countEl = document.getElementById('countdown');
  countEl.innerHTML = `<div style="text-align:center">
    <div style="font-size:2rem;color:#ffcc02;margin-bottom:20px">RACE COMPLETE</div>
    <div style="font-size:5rem">${playerPos === 1 ? 'üèÜ' : ''} P${playerPos}</div>
    <div style="font-size:1.2rem;color:#aaa;margin-top:20px;font-family:Share Tech Mono">
      BEST LAP: ${formatTime(bestLapTime)}
    </div>
    <div style="font-size:0.9rem;color:#666;margin-top:30px;font-family:Share Tech Mono">
      PRESS R TO RESTART
    </div>
  </div>`;
  countEl.style.opacity = '1';
  countEl.style.fontSize = '1rem';
  countEl.style.textShadow = '0 0 40px rgba(255,204,2,0.5)';
}

// ---- Camera ----
const cameraOffset = new Vector3(0, 5, -12);
const cameraLookOffset = new Vector3(0, 2, 10);

function updateCamera(dt) {
  const carForward = new Vector3(Math.sin(carAngle), 0, Math.cos(carAngle));
  const carRight = new Vector3(Math.cos(carAngle), 0, -Math.sin(carAngle));

  const targetPos = playerCar.position.clone()
    .add(carForward.clone().multiplyScalar(cameraOffset.z))
    .add(new Vector3(0, cameraOffset.y, 0))
    .add(carRight.clone().multiplyScalar(driftAmount * steerAngle * -8));

  camera.position.lerp(targetPos, dt * 3.5);

  const lookTarget = playerCar.position.clone()
    .add(carForward.clone().multiplyScalar(cameraLookOffset.z))
    .add(new Vector3(0, cameraLookOffset.y, 0));

  camera.lookAt(lookTarget);

  const targetFOV = 60 + (Math.abs(speed) / MAX_SPEED) * 5;
  camera.fov = MathUtils.lerp(camera.fov, targetFOV, dt * 3);
  camera.updateProjectionMatrix();
}

// ---- Resize ----
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ---- Restart ----
document.addEventListener('keydown', e => {
  if (e.code === 'KeyR' && gameState === 'finished') {
    speed = 0; steerAngle = 0; driftAmount = 0;
    lapCount = 0; bestLapTime = Infinity;
    document.getElementById('best-time').textContent = '--:--.---';
    document.getElementById('countdown').style.opacity = '0';

    const startPos = trackCurve.getPointAt(0);
    const startTan = trackCurve.getTangentAt(0);
    playerCar.position.copy(startPos);
    playerCar.position.y = ROAD_Y;
    carAngle = Math.atan2(startTan.x, startTan.z);
    playerCar.rotation.y = carAngle;
    playerCar.rotation.z = 0;

    aiStates.forEach((ai, i) => {
      ai.t = 0.01 + i * 0.015;
      ai.speed = 0;
      ai.lapCount = 0;
      ai.lastT = ai.t;
    });

    startCountdown();
  }
});

// ---- Load models then start render loop ----
loadAllModels();
gameLoop();
</script>
</body>
</html>
