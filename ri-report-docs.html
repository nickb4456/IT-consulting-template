<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RI Real Estate Report - Technical Documentation</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
      color: #e2e8f0;
      min-height: 100vh;
      padding: 2rem;
      line-height: 1.6;
    }
    .container { max-width: 900px; margin: 0 auto; }
    h1 { color: #a5b4fc; margin-bottom: 0.5rem; font-size: 2.5rem; }
    h2 { color: #10b981; margin: 2rem 0 1rem; border-bottom: 2px solid rgba(16,185,129,0.3); padding-bottom: 0.5rem; }
    h3 { color: #f59e0b; margin: 1.5rem 0 0.75rem; }
    p { margin-bottom: 1rem; color: #94a3b8; }
    code {
      background: rgba(99,102,241,0.2);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-family: 'Fira Code', monospace;
      color: #a5b4fc;
    }
    pre {
      background: #0f172a;
      border: 1px solid rgba(99,102,241,0.3);
      border-radius: 8px;
      padding: 1rem;
      overflow-x: auto;
      margin: 1rem 0;
    }
    pre code { background: none; padding: 0; }
    .card {
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid rgba(99,102,241,0.2);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1rem 0;
    }
    .highlight { color: #10b981; font-weight: 600; }
    .warning { color: #f59e0b; }
    .metric { 
      display: inline-block;
      background: rgba(16,185,129,0.2);
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
      color: #10b981;
      font-weight: 600;
      margin: 0.2rem;
    }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { padding: 0.75rem; text-align: left; border-bottom: 1px solid rgba(99,102,241,0.2); }
    th { color: #a5b4fc; background: rgba(99,102,241,0.1); }
    ul, ol { margin: 1rem 0 1rem 1.5rem; color: #94a3b8; }
    li { margin: 0.5rem 0; }
    a { color: #6366f1; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .toc { background: rgba(99,102,241,0.1); padding: 1rem; border-radius: 8px; margin: 1rem 0; }
    .toc a { display: block; padding: 0.3rem 0; }
    .badge { 
      display: inline-block;
      padding: 0.2rem 0.6rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    .badge-done { background: #10b981; color: white; }
    .badge-new { background: #6366f1; color: white; }
    .badge-perf { background: #f59e0b; color: black; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üè† RI Real Estate Report</h1>
    <p style="font-size: 1.2rem; color: #e2e8f0;">Technical Documentation & Learning Guide</p>
    <p><em>Last updated: July 18, 2025</em></p>
    
    <nav class="toc">
      <strong style="color:#a5b4fc">üìö Table of Contents</strong>
      <a href="#architecture">1. Architecture Overview</a>
      <a href="#data-flow">2. Data Flow & Loading</a>
      <a href="#optimizations">3. Performance Optimizations</a>
      <a href="#service-worker">4. Service Worker & Offline Cache</a>
      <a href="#features">5. Feature Deep Dives</a>
      <a href="#future">6. Future Improvements</a>
    </nav>

    <h2 id="architecture">1. Architecture Overview</h2>
    
    <div class="card">
      <h3>Tech Stack</h3>
      <ul>
        <li><strong>Frontend:</strong> Vanilla JS, Chart.js, SQL.js (SQLite in browser)</li>
        <li><strong>Data:</strong> Gzipped JSON (2.2MB compressed, ~36K properties)</li>
        <li><strong>Hosting:</strong> Vercel (auto-deploys from GitHub)</li>
        <li><strong>Data Source:</strong> Redfin MLS + RIGIS assessments</li>
      </ul>
    </div>

    <div class="card">
      <h3>Key Files</h3>
      <table>
        <tr><th>File</th><th>Purpose</th><th>Size</th></tr>
        <tr><td><code>ri-report.html</code></td><td>Main report SPA</td><td>~210KB</td></tr>
        <tr><td><code>ri-sales.json.gz</code></td><td>Property data (gzipped)</td><td>2.2MB</td></tr>
        <tr><td><code>ri-results.html</code></td><td>City drilldown page</td><td>~50KB</td></tr>
        <tr><td><code>ri-assessments-search.json</code></td><td>Assessment records</td><td>~15MB</td></tr>
      </table>
    </div>

    <h2 id="data-flow">2. Data Flow & Loading</h2>
    
    <h3>Parallel Loading Strategy</h3>
    <p>Instead of loading data sequentially, we use <code>Promise.all()</code> to load both the property data and SQL.js WASM simultaneously:</p>
    
    <pre><code>Promise.all([
  // Fetch + decompress gzipped JSON
  fetch('ri-sales.json.gz?v=' + new Date().toISOString().split('T')[0])
    .then(r => r.arrayBuffer())
    .then(buf => JSON.parse(pako.inflate(new Uint8Array(buf), {to:'string'}))),
  
  // Load SQL.js WASM
  initSqlJs({ locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${f}` })
]).then(([data, SQL]) => {
  // Both ready - initialize everything
});</code></pre>

    <p><span class="metric">Savings: ~2-3 seconds</span> compared to sequential loading</p>

    <h3>Batch SQL Insert</h3>
    <p>Instead of inserting 36K rows one-by-one, we batch in chunks of 500:</p>
    
    <pre><code>const BATCH = 500;
for (let i = 0; i < data.length; i += BATCH) {
  const chunk = data.slice(i, i + BATCH);
  const placeholders = chunk.map(() => '(?,?,?...)').join(',');
  const values = chunk.flatMap(p => [p.address, p.city, ...]);
  db.run(`INSERT INTO properties VALUES ${placeholders}`, values);
}</code></pre>

    <p><span class="metric">~70x faster</span> than row-by-row insertion</p>

    <h3>Cache Busting</h3>
    <p>The data URL includes today's date to ensure fresh data while allowing same-day caching:</p>
    <pre><code>fetch('ri-sales.json.gz?v=2025-07-18')</code></pre>

    <h2 id="optimizations">3. Performance Optimizations</h2>

    <div class="card">
      <h3>üöÄ Implemented Optimizations</h3>
      <table>
        <tr><th>Optimization</th><th>Impact</th><th>Status</th></tr>
        <tr>
          <td>Parallel data + WASM loading</td>
          <td>~2-3 sec faster initial load</td>
          <td><span class="badge badge-done">Done</span></td>
        </tr>
        <tr>
          <td>Batch SQL inserts (500/batch)</td>
          <td>~70x faster DB creation</td>
          <td><span class="badge badge-done">Done</span></td>
        </tr>
        <tr>
          <td>Precomputed city stats</td>
          <td>Instant insights rendering</td>
          <td><span class="badge badge-new">New</span></td>
        </tr>
        <tr>
          <td>External gzipped data</td>
          <td>96% HTML size reduction</td>
          <td><span class="badge badge-done">Done</span></td>
        </tr>
        <tr>
          <td>Daily cache busting</td>
          <td>Fresh data + browser caching</td>
          <td><span class="badge badge-done">Done</span></td>
        </tr>
      </table>
    </div>

    <h3>Precomputed City Stats</h3>
    <p>Instead of recalculating city statistics every time insights render, we compute them once on data load:</p>
    
    <pre><code>// On data load:
window.cityStats = {};
rawData.properties.forEach(p => {
  if (!window.cityStats[p.city]) {
    window.cityStats[p.city] = { prices: [], doms: [], soldPrices: [], yearlyPrices: {} };
  }
  const cs = window.cityStats[p.city];
  if (p.price > 50000) cs.prices.push(p.price);
  if (p.dom > 0 && p.dom < 365) cs.doms.push(p.dom);
  // ... collect yearly data for trends
});

// Compute aggregates once
Object.keys(window.cityStats).forEach(city => {
  const cs = window.cityStats[city];
  cs.medianPrice = calculateMedian(cs.prices);
  cs.avgDom = calculateAverage(cs.doms);
});

// Later, in updateInsights():
const topCities = Object.entries(window.cityStats)
  .filter(([c, stats]) => stats.count >= 10)
  .sort((a,b) => b[1].medianPrice - a[1].medianPrice)
  .slice(0, 5);</code></pre>

    <h2 id="service-worker">4. Service Worker & Offline Cache</h2>

    <div class="card">
      <h3>What is a Service Worker?</h3>
      <p>A service worker is a JavaScript file that runs in the background, separate from your web page. It can:</p>
      <ul>
        <li><strong>Intercept network requests</strong> - Cache responses for offline use</li>
        <li><strong>Push notifications</strong> - Send alerts even when the app is closed</li>
        <li><strong>Background sync</strong> - Queue actions when offline, sync when online</li>
      </ul>
    </div>

    <h3>How Offline Caching Works</h3>
    
    <pre><code>// sw.js (Service Worker)
const CACHE_NAME = 'ri-report-v1';
const ASSETS = [
  '/ri-report.html',
  '/ri-sales.json.gz',
  'https://cdn.jsdelivr.net/npm/chart.js',
  'https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js'
];

// Install: Cache all assets
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => cache.addAll(ASSETS))
  );
});

// Fetch: Try cache first, then network
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(cached => {
      // Return cached version if available
      if (cached) return cached;
      
      // Otherwise fetch from network and cache for next time
      return fetch(event.request).then(response => {
        const clone = response.clone();
        caches.open(CACHE_NAME).then(cache => cache.put(event.request, clone));
        return response;
      });
    })
  );
});</code></pre>

    <h3>Registration in Main Page</h3>
    <pre><code>// In ri-report.html
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js').then(reg => {
    console.log('Service Worker registered:', reg.scope);
  });
}</code></pre>

    <div class="card">
      <h3>Cache Strategies</h3>
      <table>
        <tr><th>Strategy</th><th>When to Use</th></tr>
        <tr>
          <td><strong>Cache First</strong></td>
          <td>Static assets (CSS, JS, images) - fast, works offline</td>
        </tr>
        <tr>
          <td><strong>Network First</strong></td>
          <td>API calls, fresh data - online priority, cache fallback</td>
        </tr>
        <tr>
          <td><strong>Stale While Revalidate</strong></td>
          <td>Best of both - return cached, update in background</td>
        </tr>
      </table>
    </div>

    <h3>For RI Report: Recommended Strategy</h3>
    <pre><code>// Cache-first for static assets
// Stale-while-revalidate for data (return cached, fetch fresh in background)

self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  
  // Data file: stale-while-revalidate
  if (url.pathname.includes('ri-sales.json.gz')) {
    event.respondWith(
      caches.match(event.request).then(cached => {
        const fetchPromise = fetch(event.request).then(response => {
          caches.open(CACHE_NAME).then(cache => cache.put(event.request, response.clone()));
          return response;
        });
        return cached || fetchPromise;
      })
    );
    return;
  }
  
  // Everything else: cache-first
  event.respondWith(
    caches.match(event.request).then(cached => cached || fetch(event.request))
  );
});</code></pre>

    <h2 id="features">5. Feature Deep Dives</h2>

    <h3>Explore Neighborhood (Haversine Formula)</h3>
    <p>Finds properties within a radius using the Haversine formula for great-circle distance:</p>
    
    <pre><code>function getDistance(lat1, lon1, lat2, lon2) {
  const R = 3959; // Earth radius in miles
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function getNearbyProperties(lat, lng, radiusMiles, excludeAddress) {
  return rawData.properties.filter(p => {
    if (!p.lat || !p.lng) return false;
    if (p.address === excludeAddress) return false;
    return getDistance(lat, lng, p.lat, p.lng) <= radiusMiles;
  });
}</code></pre>

    <h3>Dynamic Insights</h3>
    <p>The Key Market Insights cards update dynamically from real data:</p>
    <ul>
      <li><strong>Top 5 Inland Cities:</strong> Excludes 14 coastal cities, sorts by median price</li>
      <li><strong>Fastest to Sell:</strong> Cities with lowest average Days on Market (DOM)</li>
      <li><strong>YoY Appreciation:</strong> Compares current year median to last year</li>
    </ul>

    <h3>Deal Score Formula (House Hunter)</h3>
    <pre><code>// Discount from market value
const avgPpsf = comps.reduce((s, c) => s + c.ppsf, 0) / comps.length;
const marketValue = sqft * avgPpsf;
const discount = (1 - askingPrice / marketValue) * 100;

// DOM bonus (sitting longer = more negotiating power)
const domBonus = Math.min(20, Math.floor(dom / 15));

// Final deal score
const dealScore = discount + domBonus;</code></pre>

    <h3>Pagination with Page Size Selector</h3>
    <p>Users can choose 25, 50, 75, 100, or All results per page:</p>
    <pre><code>let propPageSize = 25; // Default

function setPageSize(size) {
  propPageSize = size;
  propPage = 1; // Reset to first page
  renderPropResults();
}

// In pagination HTML:
'<select onchange="setPageSize(parseInt(this.value))">' +
  [25, 50, 75, 100].map(n => 
    '<option value="' + n + '"' + (propPageSize === n ? ' selected' : '') + '>' + n + '</option>'
  ).join('') +
  '<option value="9999">All</option>' +
'</select>'</code></pre>

    <h2 id="future">6. Future Improvements</h2>

    <div class="card">
      <h3>üîÆ Potential Enhancements</h3>
      <ul>
        <li><span class="badge badge-perf">Perf</span> <strong>Lazy load table data</strong> - Only render visible rows (virtual scrolling)</li>
        <li><span class="badge badge-new">Feature</span> <strong>Service worker</strong> - Full offline support</li>
        <li><span class="badge badge-new">Feature</span> <strong>Auto-update cron</strong> - Daily data refresh from Redfin</li>
        <li><span class="badge badge-perf">Perf</span> <strong>Web Workers</strong> - Move heavy computations off main thread</li>
        <li><span class="badge badge-new">Feature</span> <strong>City comparison charts</strong> - Side-by-side price/DOM comparisons</li>
        <li><span class="badge badge-new">Feature</span> <strong>Map view</strong> - Leaflet/Mapbox integration for property pins</li>
      </ul>
    </div>

    <div class="card">
      <h3>üìä City Charts Enhancement Ideas</h3>
      <p>Better visualizations per city:</p>
      <ul>
        <li><strong>Box plots:</strong> Show price distribution (quartiles, outliers)</li>
        <li><strong>Histograms:</strong> Price buckets with counts</li>
        <li><strong>Time series:</strong> Monthly median prices over 2 years</li>
        <li><strong>Scatter plots:</strong> Price vs. sqft with trend line</li>
      </ul>
      
      <pre><code>// Example: Box plot data structure
const boxPlotData = {
  min: prices[0],
  q1: prices[Math.floor(prices.length * 0.25)],
  median: prices[Math.floor(prices.length * 0.5)],
  q3: prices[Math.floor(prices.length * 0.75)],
  max: prices[prices.length - 1],
  outliers: prices.filter(p => p < q1 - 1.5*iqr || p > q3 + 1.5*iqr)
};</code></pre>
    </div>

    <hr style="margin: 2rem 0; border-color: rgba(99,102,241,0.3);">
    
    <p style="text-align: center; color: #64748b;">
      Built with ‚ú® by Supernova for Nick | 
      <a href="https://aibridges.org/ri-report">Live Report</a> |
      <a href="https://github.com/nickb4456/IT-consulting-template">GitHub</a>
    </p>
  </div>
</body>
</html>
</code></pre>
