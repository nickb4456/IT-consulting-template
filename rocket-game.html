<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Rocket</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; width: 100vw; height: 100vh; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #hud {
            position: fixed; top: 0; left: 0; width: 100%; padding: 14px 20px;
            display: flex; justify-content: space-between; pointer-events: none; z-index: 10;
        }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 4px; }
        .hud-right { align-items: flex-end; }
        .hud-text {
            font-size: 18px; font-weight: 700; letter-spacing: 1px;
            text-shadow: 0 0 12px currentColor, 0 0 24px currentColor;
        }
        .hud-cyan { color: #0ff; }
        .hud-pink { color: #f0a; }
        .hud-dim { color: #888; font-size: 14px; font-weight: 400; text-shadow: none; }
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 20; pointer-events: all;
            background: radial-gradient(ellipse at center, rgba(0,10,30,0.85) 0%, rgba(0,0,0,0.95) 100%);
        }
        #overlay.hidden { display: none; }
        .overlay-title {
            font-size: 52px; font-weight: 900; color: #0ff; letter-spacing: 6px;
            text-shadow: 0 0 30px #0ff, 0 0 60px #0088ff;
            margin-bottom: 12px;
        }
        .overlay-sub { font-size: 16px; color: #888; margin-bottom: 30px; text-align: center; line-height: 1.6; }
        .overlay-score {
            font-size: 36px; font-weight: 800; color: #0ff;
            text-shadow: 0 0 20px #0ff; margin-bottom: 8px;
        }
        .overlay-alt { font-size: 20px; color: #f0a; text-shadow: 0 0 12px #f0a; margin-bottom: 30px; }
        .ctrl-box {
            border: 1px solid rgba(0,136,255,0.3); background: rgba(255,255,255,0.04);
            padding: 16px 28px; border-radius: 8px; margin-bottom: 30px; text-align: center;
        }
        .ctrl-label { font-size: 13px; color: #0ff; font-weight: 700; letter-spacing: 2px; margin-bottom: 8px; }
        .ctrl-line { font-size: 14px; color: #aaa; margin: 4px 0; }
        .launch-btn {
            background: #0088ff; border: none; color: #fff; font-size: 20px; font-weight: 800;
            letter-spacing: 4px; padding: 16px 48px; border-radius: 6px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0,136,255,0.4); transition: all 0.2s;
            pointer-events: all;
        }
        .launch-btn:hover { background: #00aaff; box-shadow: 0 0 30px rgba(0,170,255,0.6); transform: scale(1.05); }
        .game-over-title {
            font-size: 44px; font-weight: 900; color: #ff4466;
            text-shadow: 0 0 30px #ff4466, 0 0 60px #ff2244;
            margin-bottom: 20px;
        }
        #back-btn {
            position: fixed; bottom: 16px; left: 16px; z-index: 30;
            background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.15);
            color: #aaa; font-size: 13px; padding: 8px 16px; border-radius: 4px;
            cursor: pointer; text-decoration: none;
        }
        #back-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
    </style>
</head>
<body>
    <div id="hud" class="hidden">
        <div class="hud-left">
            <div class="hud-text hud-cyan" id="hud-score">SCORE: 0</div>
            <div class="hud-text hud-cyan" id="hud-lives">LIVES: 3</div>
        </div>
        <div class="hud-right">
            <div class="hud-text hud-pink" id="hud-alt">ALT: 0m</div>
            <div class="hud-dim" id="hud-speed">1.0x</div>
        </div>
    </div>

    <div id="overlay">
        <div class="overlay-title">SPACE ROCKET</div>
        <div class="overlay-sub">Fly through the asteroid field!<br>Dodge obstacles &bull; Collect power-ups</div>
        <div class="ctrl-box">
            <div class="ctrl-label">CONTROLS</div>
            <div class="ctrl-line">Arrow Keys or WASD — Move</div>
            <div class="ctrl-line">SPACE — Shoot</div>
            <div class="ctrl-line">Touch — Drag to move</div>
        </div>
        <button class="launch-btn" id="launch-btn">LAUNCH</button>
    </div>

    <a id="back-btn" href="games.html">&larr; Back</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
    // ============ SOUND ENGINE ============
    let audioCtx = null;
    function ensureAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    function playTone(freq, dur, type, vol) {
        if (!audioCtx) return;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type || 'sine';
        o.frequency.setValueAtTime(freq, audioCtx.currentTime);
        g.gain.setValueAtTime(vol || 0.12, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + dur);
    }
    function playNoise(dur, vol) {
        if (!audioCtx) return;
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
        const src = audioCtx.createBufferSource();
        const g = audioCtx.createGain();
        src.buffer = buf;
        g.gain.setValueAtTime(vol || 0.08, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        src.connect(g); g.connect(audioCtx.destination);
        src.start();
    }
    const SFX = {
        hit() { playNoise(0.2, 0.15); playTone(120, 0.2, 'sawtooth', 0.1); },
        powerup() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.12, 'sine', 0.1), i * 70)); },
        gameOver() { [400, 350, 300, 200].forEach((f, i) => setTimeout(() => playTone(f, 0.3, 'triangle', 0.1), i * 150)); },
        dodge() { playTone(900, 0.04, 'sine', 0.06); }
    };

    // ============ THREE.JS SCENE ============
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.FogExp2(0x050510, 0.008);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
    // Perfectly straight down — offset in Z so rocket (at Z=0) appears at bottom of screen
    camera.position.set(0, 18, -6);
    camera.lookAt(0, 0, -6);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Lighting — bright from above/front to match Meshy preview look
    scene.add(new THREE.AmbientLight(0x667788, 0.8));
    const sunLight = new THREE.DirectionalLight(0xffffff, 1.4);
    sunLight.position.set(3, 15, 8);
    scene.add(sunLight);
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
    fillLight.position.set(-3, 10, 5);
    scene.add(fillLight);
    const rimLight = new THREE.DirectionalLight(0x4488ff, 0.3);
    rimLight.position.set(0, 5, -10);
    scene.add(rimLight);

    // Engine glow light (attached to rocket later)
    const engineLight = new THREE.PointLight(0xff6600, 3, 8);
    engineLight.position.set(0, -2, 0);

    // ============ STARFIELD ============
    const starCount = 600;
    const starGeo = new THREE.BufferGeometry();
    const starPositions = new Float32Array(starCount * 3);
    const starSpeeds = new Float32Array(starCount);
    for (let i = 0; i < starCount; i++) {
        starPositions[i * 3] = (Math.random() - 0.5) * 80;
        starPositions[i * 3 + 1] = -5;
        starPositions[i * 3 + 2] = Math.random() * -120;
        starSpeeds[i] = 0.3 + Math.random() * 0.8;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.7 });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // ============ ROCKET (GLB) ============
    let rocketGroup = new THREE.Group();
    let rocketModel = null;
    let rocketLoaded = false;
    scene.add(rocketGroup);
    rocketGroup.add(engineLight);

    // (flame particles removed)

    let rocketPivot = new THREE.Group();
    rocketGroup.add(rocketPivot);

    const loader = new THREE.GLTFLoader();
    loader.load('rocket-model.glb', (gltf) => {
        rocketModel = gltf.scene;
        const box = new THREE.Box3().setFromObject(rocketModel);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const s = 3.8 / maxDim;
        rocketModel.scale.set(s, s, s);
        const center = box.getCenter(new THREE.Vector3());
        rocketModel.position.set(-center.x * s, -center.y * s, -center.z * s);
        // Rotate around Y so nose points to top of screen (clockwise when viewed from above)
        rocketPivot.rotation.set(0, -Math.PI / 2, 0);
        rocketPivot.add(rocketModel);
        rocketLoaded = true;
        console.log('Rocket loaded:', size);
    }, undefined, (err) => console.warn('GLB load failed:', err));

    // ============ OBSTACLE POOL ============
    function createAsteroid() {
        const radius = 0.6 + Math.random() * 1.2;
        const geo = new THREE.DodecahedronGeometry(radius, 1);
        // Distort vertices for rocky look
        const pos = geo.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            const v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i));
            v.multiplyScalar(0.8 + Math.random() * 0.4);
            pos.setXYZ(i, v.x, v.y, v.z);
        }
        geo.computeVertexNormals();
        const shade = 0.25 + Math.random() * 0.15;
        const mat = new THREE.MeshStandardMaterial({
            color: new THREE.Color(shade + 0.1, shade, shade - 0.05),
            roughness: 0.9, metalness: 0.1, flatShading: true
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.userData = { type: 'asteroid', radius, rotAxis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize(), rotSpeed: (Math.random() - 0.5) * 2 };
        return mesh;
    }

    function createGlowStar() {
        const colors = [0xffee44, 0xffaa00, 0xff6644, 0x44aaff, 0xff44ff];
        const color = colors[Math.floor(Math.random() * colors.length)];
        const group = new THREE.Group();
        // Glow sphere
        const glowGeo = new THREE.SphereGeometry(1.2, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.15 });
        group.add(new THREE.Mesh(glowGeo, glowMat));
        // Core
        const coreGeo = new THREE.OctahedronGeometry(0.5, 0);
        const coreMat = new THREE.MeshBasicMaterial({ color });
        group.add(new THREE.Mesh(coreGeo, coreMat));
        // Inner glow
        const innerGeo = new THREE.SphereGeometry(0.25, 8, 8);
        const innerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        group.add(new THREE.Mesh(innerGeo, innerMat));
        // Point light
        group.add(new THREE.PointLight(color, 1, 4));
        group.userData = { type: 'star', radius: 0.7, rotAxis: new THREE.Vector3(0, 1, 0), rotSpeed: 2 };
        return group;
    }

    function createPowerup(puType) {
        const colors = { score: 0xffff00, life: 0xff4488, slow: 0x00ff88 };
        const col = colors[puType];
        const group = new THREE.Group();
        // Diamond shape
        const diaGeo = new THREE.OctahedronGeometry(0.5, 0);
        const diaMat = new THREE.MeshStandardMaterial({ color: col, emissive: col, emissiveIntensity: 0.5, metalness: 0.8, roughness: 0.2 });
        const dia = new THREE.Mesh(diaGeo, diaMat);
        group.add(dia);
        // Glow
        const glowGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.12 });
        group.add(new THREE.Mesh(glowGeo, glowMat));
        group.add(new THREE.PointLight(col, 1.5, 5));
        group.userData = { type: 'powerup', puType, radius: 0.6, rotAxis: new THREE.Vector3(0, 1, 0), rotSpeed: 3 };
        return group;
    }

    // ============ EXPLOSION PARTICLES ============
    const explosions = [];
    function spawnExplosion(pos, color) {
        const count = 20;
        const geo = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const velocities = [];
        for (let i = 0; i < count; i++) {
            positions[i * 3] = pos.x;
            positions[i * 3 + 1] = pos.y;
            positions[i * 3 + 2] = pos.z;
            velocities.push(new THREE.Vector3((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8));
        }
        geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const mat = new THREE.PointsMaterial({ color, size: 0.25, transparent: true, opacity: 1 });
        const pts = new THREE.Points(geo, mat);
        scene.add(pts);
        explosions.push({ pts, velocities, life: 1 });
    }

    // ============ BULLETS ============
    const bullets = [];
    const BULLET_SPEED = 60;
    let shootCooldown = 0;

    function createBullet(x, z) {
        const geo = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 6);
        const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const mesh = new THREE.Mesh(geo, mat);
        // Bullet is a cylinder — keep upright (Y-axis), viewed from above it's a dot with glow
        mesh.position.set(x, 2, z);
        // Glow
        const glowGeo = new THREE.SphereGeometry(0.2, 8, 8);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        mesh.add(glow);
        const light = new THREE.PointLight(0x00ffff, 1, 4);
        mesh.add(light);
        scene.add(mesh);
        bullets.push({ mesh });
        // SFX
        playTone(800, 0.06, 'square', 0.08);
        playTone(1200, 0.04, 'sine', 0.06);
    }

    // ============ GAME STATE ============
    let state = 'menu'; // menu, playing, gameOver
    let score = 0, lives = 3, altitude = 0, gameSpeed = 1;
    let invincible = 0;
    let rocketX = 0, rocketTargetX = 0;
    let rocketZ = 0, rocketTargetZ = 0;
    const LANE_WIDTH = 14; // total X range: -7 to 7
    const Z_RANGE = 18; // total Z range for up/down movement
    const obstacles = [];
    const powerups = [];
    let obstacleTimer = 0, powerupTimer = 0;
    let keys = {};
    let touchActive = false, touchStartX = 0, touchRocketStartX = 0;

    // ============ HUD ============
    const hudEl = document.getElementById('hud');
    const hudScore = document.getElementById('hud-score');
    const hudLives = document.getElementById('hud-lives');
    const hudAlt = document.getElementById('hud-alt');
    const hudSpeed = document.getElementById('hud-speed');
    const overlay = document.getElementById('overlay');
    const launchBtn = document.getElementById('launch-btn');

    function updateHUD() {
        hudScore.textContent = 'SCORE: ' + score;
        hudLives.textContent = 'LIVES: ' + lives;
        hudAlt.textContent = 'ALT: ' + Math.floor(altitude) + 'm';
        hudSpeed.textContent = gameSpeed.toFixed(1) + 'x';
    }

    // ============ INPUT ============
    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        if (state === 'menu' && (e.code === 'Space' || e.code === 'Enter')) startGame();
        if (state === 'gameOver' && (e.code === 'Space' || e.code === 'Enter')) showMenu();
    });
    window.addEventListener('keyup', (e) => { keys[e.code] = false; });

    let touchStartY = 0, touchRocketStartZ = 0;
    renderer.domElement.addEventListener('touchstart', (e) => {
        if (state === 'menu') return;
        e.preventDefault();
        touchActive = true;
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchRocketStartX = rocketX;
        touchRocketStartZ = rocketZ;
    }, { passive: false });
    renderer.domElement.addEventListener('touchmove', (e) => {
        if (!touchActive || state !== 'playing') return;
        e.preventDefault();
        const dx = (e.touches[0].clientX - touchStartX) / window.innerWidth * LANE_WIDTH * 2;
        const dy = (e.touches[0].clientY - touchStartY) / window.innerHeight * Z_RANGE * 2;
        rocketTargetX = Math.max(-LANE_WIDTH / 2, Math.min(LANE_WIDTH / 2, touchRocketStartX + dx));
        rocketTargetZ = Math.max(-Z_RANGE / 2, Math.min(Z_RANGE / 2, touchRocketStartZ + dy));
    }, { passive: false });
    renderer.domElement.addEventListener('touchend', () => { touchActive = false; });

    // ============ GAME FLOW ============
    function startGame() {
        ensureAudio();
        state = 'playing';
        score = 0; lives = 3; altitude = 0; gameSpeed = 1;
        invincible = 0; rocketX = 0; rocketTargetX = 0; rocketZ = 0; rocketTargetZ = 0;
        obstacleTimer = 0; powerupTimer = 0;

        // Clear old obstacles/powerups
        obstacles.forEach(o => scene.remove(o.mesh));
        obstacles.length = 0;
        powerups.forEach(p => scene.remove(p.mesh));
        powerups.length = 0;
        explosions.forEach(e => { scene.remove(e.pts); e.pts.geometry.dispose(); e.pts.material.dispose(); });
        explosions.length = 0;
        bullets.forEach(b => { scene.remove(b.mesh); b.mesh.geometry.dispose(); b.mesh.material.dispose(); });
        bullets.length = 0;
        shootCooldown = 0;

        rocketGroup.position.set(0, 0, 0);
        rocketGroup.rotation.set(0, 0, 0);
        rocketGroup.visible = true;

        overlay.classList.add('hidden');
        hudEl.classList.remove('hidden');
        updateHUD();
    }

    function endGame() {
        state = 'gameOver';
        SFX.gameOver();
        hudEl.classList.add('hidden');

        overlay.innerHTML = `
            <div class="game-over-title">GAME OVER</div>
            <div class="overlay-score">Score: ${score}</div>
            <div class="overlay-alt">Altitude: ${Math.floor(altitude)}m</div>
            <button class="launch-btn" onclick="showMenu()">TRY AGAIN</button>
        `;
        overlay.classList.remove('hidden');
    }

    function showMenu() {
        state = 'menu';
        overlay.innerHTML = `
            <div class="overlay-title">SPACE ROCKET</div>
            <div class="overlay-sub">Fly through the asteroid field!<br>Dodge obstacles &bull; Collect power-ups</div>
            <div class="ctrl-box">
                <div class="ctrl-label">CONTROLS</div>
                <div class="ctrl-line">Arrow Keys or WASD — Move</div>
                <div class="ctrl-line">SPACE — Shoot</div>
                <div class="ctrl-line">Touch — Drag to move</div>
            </div>
            <button class="launch-btn" id="launch-btn" onclick="startGame()">LAUNCH</button>
        `;
        overlay.classList.remove('hidden');
        hudEl.classList.add('hidden');

        // Clear scene objects
        obstacles.forEach(o => scene.remove(o.mesh));
        obstacles.length = 0;
        powerups.forEach(p => scene.remove(p.mesh));
        powerups.length = 0;
        explosions.forEach(e => { scene.remove(e.pts); e.pts.geometry.dispose(); e.pts.material.dispose(); });
        explosions.length = 0;
        bullets.forEach(b => { scene.remove(b.mesh); b.mesh.geometry.dispose(); b.mesh.material.dispose(); });
        bullets.length = 0;
    }

    launchBtn.addEventListener('click', startGame);

    // ============ GAME LOOP ============
    const clock = new THREE.Clock();
    let lastTime = 0;

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const dt = Math.min(delta, 0.05); // cap at 50ms

        // Animate starfield (always)
        const starPos = stars.geometry.attributes.position;
        for (let i = 0; i < starCount; i++) {
            let z = starPos.getZ(i);
            z += starSpeeds[i] * (state === 'playing' ? gameSpeed : 0.3) * dt * 30;
            if (z > 10) {
                z = -120;
                starPos.setX(i, (Math.random() - 0.5) * 80);
                starPos.setY(i, (Math.random() - 0.5) * 10);
            }
            starPos.setZ(i, z);
        }
        starPos.needsUpdate = true;

        // Rocket idle animation on menu
        if (state === 'menu') {
            rocketGroup.position.set(0, 0, 0);
            rocketGroup.rotation.set(0, 0, 0);
        }

        if (state === 'playing') {
            // Rocket movement — full freedom: left/right + up/down
            const moveSpeed = 12 * dt;
            if (keys['ArrowLeft'] || keys['KeyA']) rocketTargetX -= moveSpeed;
            if (keys['ArrowRight'] || keys['KeyD']) rocketTargetX += moveSpeed;
            if (keys['ArrowUp'] || keys['KeyW']) rocketTargetZ -= moveSpeed;
            if (keys['ArrowDown'] || keys['KeyS']) rocketTargetZ += moveSpeed;
            rocketTargetX = Math.max(-LANE_WIDTH / 2, Math.min(LANE_WIDTH / 2, rocketTargetX));
            rocketTargetZ = Math.max(-Z_RANGE / 2, Math.min(Z_RANGE / 2, rocketTargetZ));
            rocketX += (rocketTargetX - rocketX) * 0.15;
            rocketZ += (rocketTargetZ - rocketZ) * 0.15;

            rocketGroup.position.x = rocketX;
            rocketGroup.position.y = 0;
            rocketGroup.position.z = rocketZ;

            // Bank toward movement direction
            const tiltTarget = (rocketTargetX - rocketX) * 0.15;
            rocketGroup.rotation.z += (tiltTarget - rocketGroup.rotation.z) * 0.1;
            rocketGroup.rotation.x = 0;
            rocketGroup.rotation.y = 0;

            // Shooting
            shootCooldown -= dt;
            if (keys['Space'] && shootCooldown <= 0) {
                shootCooldown = 0.15; // fire rate
                createBullet(rocketX, rocketZ);
            }

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.mesh.position.z -= BULLET_SPEED * dt;
                // Off screen
                if (b.mesh.position.z < -100) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                    continue;
                }
                // Check bullet vs obstacles
                let bulletHit = false;
                for (let j = obstacles.length - 1; j >= 0; j--) {
                    const ob = obstacles[j];
                    const dx = b.mesh.position.x - ob.mesh.position.x;
                    const dz = b.mesh.position.z - ob.mesh.position.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < (ob.mesh.userData.radius || 1) + 0.5) {
                        // Hit!
                        SFX.hit();
                        spawnExplosion(ob.mesh.position.clone(), 0xff8800);
                        scene.remove(ob.mesh);
                        obstacles.splice(j, 1);
                        score += 25;
                        bulletHit = true;
                        break;
                    }
                }
                if (bulletHit) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                }
            }

            // Invincibility
            if (invincible > 0) {
                invincible -= dt;
                rocketGroup.visible = Math.sin(Date.now() * 0.02) > 0;
            } else {
                rocketGroup.visible = true;
            }

            // Spawn obstacles
            obstacleTimer += dt;
            const spawnInterval = Math.max(0.1, 0.25 - gameSpeed * 0.02);
            if (obstacleTimer > spawnInterval) {
                obstacleTimer = 0;
                const isAsteroid = Math.random() > 0.2;
                const mesh = isAsteroid ? createAsteroid() : createGlowStar();
                const x = (Math.random() - 0.5) * LANE_WIDTH;
                mesh.position.set(x, 0, -80 - Math.random() * 20);
                scene.add(mesh);
                obstacles.push({ mesh, speed: 5 + Math.random() * 4 });
            }

            // Spawn powerups
            powerupTimer += dt;
            if (powerupTimer > 4) {
                powerupTimer = 0;
                const types = ['score', 'life', 'slow'];
                const puType = types[Math.floor(Math.random() * types.length)];
                const mesh = createPowerup(puType);
                mesh.position.set((Math.random() - 0.5) * LANE_WIDTH, 0, -60);
                scene.add(mesh);
                powerups.push({ mesh, puType, speed: 5 + Math.random() * 3 });
            }

            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const ob = obstacles[i];
                ob.mesh.position.z += ob.speed * gameSpeed * dt;
                // Rotate
                const ud = ob.mesh.userData;
                if (ud.rotAxis) ob.mesh.rotateOnAxis(ud.rotAxis, ud.rotSpeed * dt);

                // Collision
                if (invincible <= 0) {
                    const dx = ob.mesh.position.x - rocketX;
                    const dz = ob.mesh.position.z - rocketZ;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < (ud.radius || 1) + 1.2) {
                        SFX.hit();
                        spawnExplosion(ob.mesh.position, 0xff8800);
                        scene.remove(ob.mesh);
                        obstacles.splice(i, 1);
                        lives--;
                        invincible = 1.5;
                        updateHUD();
                        if (lives <= 0) { endGame(); return; }
                        continue;
                    }
                }

                // Past player
                if (ob.mesh.position.z > 15) {
                    scene.remove(ob.mesh);
                    obstacles.splice(i, 1);
                    score += 5;
                }
            }

            // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const pu = powerups[i];
                pu.mesh.position.z += pu.speed * gameSpeed * dt;
                pu.mesh.rotateY(3 * dt);

                const dx = pu.mesh.position.x - rocketX;
                const dz = pu.mesh.position.z - rocketZ;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 1.8) {
                    SFX.powerup();
                    spawnExplosion(pu.mesh.position, 0x00ff88);
                    if (pu.puType === 'score') score += 100;
                    else if (pu.puType === 'life') lives = Math.min(5, lives + 1);
                    else if (pu.puType === 'slow') gameSpeed = Math.max(0.6, gameSpeed - 0.15);
                    scene.remove(pu.mesh);
                    powerups.splice(i, 1);
                    updateHUD();
                    continue;
                }

                if (pu.mesh.position.z > 15) {
                    scene.remove(pu.mesh);
                    powerups.splice(i, 1);
                }
            }

            // Update explosions
            for (let i = explosions.length - 1; i >= 0; i--) {
                const ex = explosions[i];
                ex.life -= dt * 2;
                ex.pts.material.opacity = Math.max(0, ex.life);
                const epos = ex.pts.geometry.attributes.position;
                for (let j = 0; j < ex.velocities.length; j++) {
                    epos.setX(j, epos.getX(j) + ex.velocities[j].x * dt);
                    epos.setY(j, epos.getY(j) + ex.velocities[j].y * dt);
                    epos.setZ(j, epos.getZ(j) + ex.velocities[j].z * dt);
                }
                epos.needsUpdate = true;
                if (ex.life <= 0) {
                    scene.remove(ex.pts);
                    ex.pts.geometry.dispose();
                    ex.pts.material.dispose();
                    explosions.splice(i, 1);
                }
            }

            // Score & altitude
            altitude += gameSpeed * 20 * dt;
            gameSpeed += 0.003 * dt;
            updateHUD();
        }

        renderer.render(scene, camera);
    }

    animate();

    // ============ RESIZE ============
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>
