<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸš€ Space Rocket</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
    // ============ SOUND ENGINE ============
    let audioCtx = null;
    function ensureAudio() {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    function playTone(freq, dur, type, vol) {
        if (!audioCtx) return;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type || 'sine';
        o.frequency.setValueAtTime(freq, audioCtx.currentTime);
        g.gain.setValueAtTime(vol || 0.12, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + dur);
    }
    function playNoise(dur, vol) {
        if (!audioCtx) return;
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
        const d = buf.getChannelData(0);
        for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
        const src = audioCtx.createBufferSource();
        const g = audioCtx.createGain();
        src.buffer = buf;
        g.gain.setValueAtTime(vol || 0.08, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        src.connect(g); g.connect(audioCtx.destination);
        src.start();
    }
    const SFX = {
        hit() { playNoise(0.2, 0.15); playTone(120, 0.2, 'sawtooth', 0.1); },
        powerup() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.12, 'sine', 0.1), i * 70)); },
        gameOver() { [400, 350, 300, 200].forEach((f, i) => setTimeout(() => playTone(f, 0.3, 'triangle', 0.1), i * 150)); },
        dodge() { playTone(900, 0.04, 'sine', 0.06); }
    };

    const W = Math.min(window.innerWidth, 480);
    const H = window.innerHeight;

    // ============ 3D ROCKET (renders to Phaser texture) ============
    const ROCKET_TEX_SIZE = 128;
    let rocketScene3D, rocketCam3D, rocketRenderer3D, rocketModel3D;
    let rocketLoaded = false;
    let rocketCanvas3D;

    function init3DRocket() {
        rocketScene3D = new THREE.Scene();
        rocketCam3D = new THREE.PerspectiveCamera(35, 1, 0.1, 50);
        rocketCam3D.position.set(0, 1.5, 4.5);
        rocketCam3D.lookAt(0, 0, 0);

        // Offscreen canvas â€” never added to DOM
        rocketCanvas3D = document.createElement('canvas');
        rocketCanvas3D.width = ROCKET_TEX_SIZE;
        rocketCanvas3D.height = ROCKET_TEX_SIZE;
        rocketRenderer3D = new THREE.WebGLRenderer({ canvas: rocketCanvas3D, alpha: true, antialias: true });
        rocketRenderer3D.setSize(ROCKET_TEX_SIZE, ROCKET_TEX_SIZE);
        rocketRenderer3D.setClearColor(0x000000, 0);

        // Lighting
        rocketScene3D.add(new THREE.AmbientLight(0x808090, 1));
        const dir = new THREE.DirectionalLight(0xffffff, 1.2);
        dir.position.set(2, 4, 3);
        rocketScene3D.add(dir);
        const rim = new THREE.DirectionalLight(0x00ccff, 0.4);
        rim.position.set(-2, -1, -2);
        rocketScene3D.add(rim);
        const engine = new THREE.PointLight(0xff6600, 2, 5);
        engine.position.set(0, -1.5, 0);
        engine.name = 'engineLight';
        rocketScene3D.add(engine);

        const loader = new THREE.GLTFLoader();
        loader.load('rocket-model.glb', (gltf) => {
            rocketModel3D = gltf.scene;
            const box = new THREE.Box3().setFromObject(rocketModel3D);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const s = 2.2 / maxDim;
            rocketModel3D.scale.set(s, s, s);
            const center = box.getCenter(new THREE.Vector3());
            rocketModel3D.position.set(-center.x * s, -center.y * s, -center.z * s);
            const wrap = new THREE.Group();
            wrap.add(rocketModel3D);
            rocketModel3D = wrap;
            rocketScene3D.add(rocketModel3D);
            rocketLoaded = true;
            console.log('3D rocket loaded:', size);
        }, undefined, (err) => console.warn('Rocket GLB failed:', err));
    }

    function render3DRocket(rotation, boost) {
        if (!rocketLoaded || !rocketModel3D) return;
        rocketModel3D.rotation.z = rotation * 3;
        rocketModel3D.rotation.x = Math.sin(Date.now() * 0.003) * 0.03;
        const el = rocketScene3D.getObjectByName('engineLight');
        if (el) {
            el.intensity = boost ? 4 : 2;
            el.color.setHex(boost ? 0x00aaff : 0xff6600);
        }
        rocketRenderer3D.render(rocketScene3D, rocketCam3D);
    }

    class MenuScene extends Phaser.Scene {
        constructor() { super('MenuScene'); }

        create() {
            // Starfield background
            for (let i = 0; i < 120; i++) {
                const s = this.add.circle(
                    Phaser.Math.Between(0, W), Phaser.Math.Between(0, H),
                    Math.random() < 0.1 ? 2 : 1,
                    0xffffff, 0.4 + Math.random() * 0.6
                );
                this.tweens.add({ targets: s, alpha: 0.2, duration: 1000 + Math.random() * 2000, yoyo: true, repeat: -1 });
            }

            // Title
            this.add.text(W / 2, H * 0.22, 'ðŸš€', { fontSize: '72px' }).setOrigin(0.5);
            this.add.text(W / 2, H * 0.32, 'SPACE ROCKET', {
                fontSize: '36px', fontFamily: 'Segoe UI, sans-serif', fontStyle: 'bold',
                color: '#00ffff',
                shadow: { offsetX: 0, offsetY: 0, color: '#00ffff', blur: 20, fill: true }
            }).setOrigin(0.5);

            this.add.text(W / 2, H * 0.40, 'Fly upward through the asteroid field!\nDodge obstacles â€¢ Collect power-ups', {
                fontSize: '14px', fontFamily: 'Segoe UI, sans-serif', color: '#888', align: 'center', lineSpacing: 6
            }).setOrigin(0.5);

            // Controls
            const ctrlY = H * 0.54;
            const ctrlBg = this.add.rectangle(W / 2, ctrlY, W * 0.75, 90, 0xffffff, 0.08).setStrokeStyle(1, 0x0088ff, 0.3);
            this.add.text(W / 2, ctrlY - 28, 'CONTROLS', { fontSize: '14px', fontFamily: 'Segoe UI, sans-serif', color: '#0ff', fontStyle: 'bold' }).setOrigin(0.5);
            this.add.text(W / 2, ctrlY, 'â¬…ï¸ âž¡ï¸  Arrow Keys or A/D â€” Move', { fontSize: '13px', fontFamily: 'Segoe UI, sans-serif', color: '#aaa' }).setOrigin(0.5);
            this.add.text(W / 2, ctrlY + 22, 'SPACE â€” Boost', { fontSize: '13px', fontFamily: 'Segoe UI, sans-serif', color: '#aaa' }).setOrigin(0.5);

            // Launch button
            const btn = this.add.rectangle(W / 2, H * 0.72, 200, 55, 0x0088ff).setInteractive({ useHandCursor: true });
            const btnGlow = this.add.rectangle(W / 2, H * 0.72, 210, 65, 0x00ccff, 0.15);
            this.add.text(W / 2, H * 0.72, 'LAUNCH', {
                fontSize: '22px', fontFamily: 'Segoe UI, sans-serif', fontStyle: 'bold', color: '#fff', letterSpacing: 4
            }).setOrigin(0.5);

            this.tweens.add({ targets: btnGlow, scaleX: 1.15, scaleY: 1.15, alpha: 0, duration: 1200, repeat: -1 });

            btn.on('pointerover', () => btn.setFillStyle(0x00aaff));
            btn.on('pointerout', () => btn.setFillStyle(0x0088ff));
            btn.on('pointerdown', () => {
                ensureAudio();
                this.scene.start('GameScene');
            });

            // Keyboard start
            this.input.keyboard.on('keydown-SPACE', () => {
                ensureAudio();
                this.scene.start('GameScene');
            });

            // Initialize 3D rocket
            if (!rocketRenderer3D) init3DRocket();
        }
    }

    class GameScene extends Phaser.Scene {
        constructor() { super('GameScene'); }

        create() {
            this.score = 0;
            this.lives = 3;
            this.altitude = 0;
            this.gameSpeed = 1;
            this.isOver = false;
            this.invincible = 0;

            // Background stars
            this.bgStars = [];
            for (let i = 0; i < 100; i++) {
                const s = this.add.circle(
                    Phaser.Math.Between(0, W), Phaser.Math.Between(0, H),
                    Math.random() < 0.08 ? 2 : 1, 0xffffff, 0.3 + Math.random() * 0.5
                );
                s.speed = 0.3 + Math.random() * 1.2;
                this.bgStars.push(s);
            }

            // Draw rocket using graphics
            this.rocketX = W / 2;
            this.rocketY = H - 100;
            this.rocketContainer = this.add.container(this.rocketX, this.rocketY);

            const g = this.add.graphics();
            // Flame
            g.fillStyle(0xff6600, 0.7);
            g.fillTriangle(-8, 22, 8, 22, 0, 42);
            g.fillStyle(0xffaa00, 0.9);
            g.fillTriangle(-5, 22, 5, 22, 0, 35);
            // Body
            g.fillStyle(0x3388ff);
            g.fillRoundedRect(-12, -20, 24, 42, 4);
            // Nose cone
            g.fillStyle(0xff3333);
            g.fillTriangle(-12, -20, 12, -20, 0, -38);
            // Fins
            g.fillStyle(0xff6600);
            g.fillTriangle(-12, 18, -22, 26, -12, 8);
            g.fillTriangle(12, 18, 22, 26, 12, 8);
            // Window
            g.fillStyle(0x88ddff);
            g.fillCircle(0, -8, 5);
            g.fillStyle(0xaaeeff, 0.5);
            g.fillCircle(-1, -9, 2);

            this.rocketContainer.add(g);
            this.rocketGfx = g;

            // 3D rocket sprite (replaces 2D graphics when loaded)
            this.rocket3DSprite = null;
            if (rocketLoaded) {
                this.setup3DRocketSprite();
            } else {
                // Check periodically until loaded
                this.rocketLoadCheck = this.time.addEvent({
                    delay: 200, loop: true,
                    callback: () => {
                        if (rocketLoaded) {
                            this.setup3DRocketSprite();
                            this.rocketLoadCheck.remove();
                        }
                    }
                });
            }

            // Flame flicker
            this.flameTimer = 0;

            // Obstacle group (must be after rocket setup)
            // Note: setup3DRocketSprite is defined as a class method below
            this.obstacles = [];
            this.powerups = [];
            this.particles = [];

            // Spawn timers
            this.obstacleTimer = 0;
            this.powerupTimer = 0;

            // HUD
            this.scoreText = this.add.text(12, 12, 'ðŸš€ SCORE: 0', {
                fontSize: '16px', fontFamily: 'Segoe UI, sans-serif', color: '#0ff',
                shadow: { offsetX: 0, offsetY: 0, color: '#0ff', blur: 8, fill: true }
            });
            this.livesText = this.add.text(12, 36, 'â¤ï¸ LIVES: 3', {
                fontSize: '16px', fontFamily: 'Segoe UI, sans-serif', color: '#0ff',
                shadow: { offsetX: 0, offsetY: 0, color: '#0ff', blur: 8, fill: true }
            });
            this.altText = this.add.text(W - 12, 12, 'ALT: 0m', {
                fontSize: '16px', fontFamily: 'Segoe UI, sans-serif', color: '#f0a',
                shadow: { offsetX: 0, offsetY: 0, color: '#f0a', blur: 8, fill: true }
            }).setOrigin(1, 0);
            this.speedText = this.add.text(W - 12, 36, 'âš¡ 1.0x', {
                fontSize: '14px', fontFamily: 'Segoe UI, sans-serif', color: '#888'
            }).setOrigin(1, 0);

            // Input
            this.cursors = this.input.keyboard.createCursorKeys();
            this.keyA = this.input.keyboard.addKey('A');
            this.keyD = this.input.keyboard.addKey('D');

            // Touch
            this.touchDragging = false;
            this.input.on('pointerdown', (p) => { this.touchDragging = true; this.touchStartX = p.x; this.touchRocketStartX = this.rocketX; });
            this.input.on('pointermove', (p) => {
                if (!this.touchDragging) return;
                this.rocketX = Phaser.Math.Clamp(this.touchRocketStartX + (p.x - this.touchStartX), 25, W - 25);
            });
            this.input.on('pointerup', () => this.touchDragging = false);
        }

        update(time, delta) {
            if (this.isOver) return;

            const dt = delta / 16.67; // normalize to ~60fps

            // Scroll background stars
            this.bgStars.forEach(s => {
                s.y += s.speed * this.gameSpeed * dt;
                if (s.y > H + 5) {
                    s.y = -5;
                    s.x = Phaser.Math.Between(0, W);
                }
            });

            // Rocket movement
            const speed = 5 * dt;
            const boost = this.cursors.space.isDown ? 1.6 : 1;
            let moveX = 0;
            if (this.cursors.left.isDown || this.keyA.isDown) moveX = -speed * boost;
            if (this.cursors.right.isDown || this.keyD.isDown) moveX = speed * boost;

            this.rocketX = Phaser.Math.Clamp(this.rocketX + moveX, 25, W - 25);
            this.rocketContainer.x = this.rocketX;

            // Tilt
            this.rocketContainer.rotation = Phaser.Math.Linear(this.rocketContainer.rotation, -moveX * 0.04, 0.15);

            // Flame flicker
            this.flameTimer += delta;
            const flameScale = 1 + Math.sin(this.flameTimer * 0.015) * 0.15 + (boost > 1 ? 0.3 : 0);
            this.rocketContainer.scaleY = 1;

            // Invincibility
            if (this.invincible > 0) {
                this.invincible -= delta;
                this.rocketContainer.alpha = Math.sin(time * 0.02) > 0 ? 1 : 0.3;
            } else {
                this.rocketContainer.alpha = 1;
            }

            // Spawn obstacles
            this.obstacleTimer += delta;
            const spawnInterval = Math.max(250, 800 - this.gameSpeed * 80);
            if (this.obstacleTimer > spawnInterval) {
                this.obstacleTimer = 0;
                this.spawnObstacle();
            }

            // Spawn powerups
            this.powerupTimer += delta;
            if (this.powerupTimer > 5000) {
                this.powerupTimer = 0;
                this.spawnPowerup();
            }

            // Update obstacles
            for (let i = this.obstacles.length - 1; i >= 0; i--) {
                const ob = this.obstacles[i];
                ob.y += ob.speed * this.gameSpeed * dt;
                ob.gfx.x = ob.x;
                ob.gfx.y = ob.y;
                ob.gfx.rotation += ob.rotSpeed * dt;

                // Collision
                if (this.invincible <= 0) {
                    const dx = ob.x - this.rocketX;
                    const dy = ob.y - this.rocketY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < ob.radius + 18) {
                        SFX.hit();
                        this.spawnExplosion(ob.x, ob.y, ob.color);
                        ob.gfx.destroy();
                        this.obstacles.splice(i, 1);
                        this.lives--;
                        this.livesText.setText('â¤ï¸ LIVES: ' + this.lives);
                        this.invincible = 1500;
                        if (this.lives <= 0) { this.endGame(); return; }
                        continue;
                    }
                }

                // Off screen
                if (ob.y > H + 40) {
                    ob.gfx.destroy();
                    this.obstacles.splice(i, 1);
                    this.score += 5;
                }
            }

            // Update powerups
            for (let i = this.powerups.length - 1; i >= 0; i--) {
                const pu = this.powerups[i];
                pu.y += 1.5 * this.gameSpeed * dt;
                pu.gfx.x = pu.x;
                pu.gfx.y = pu.y;
                pu.gfx.rotation += 0.02 * dt;

                const dx = pu.x - this.rocketX;
                const dy = pu.y - this.rocketY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 28) {
                    SFX.powerup();
                    this.spawnExplosion(pu.x, pu.y, 0x00ff88);
                    if (pu.type === 'score') this.score += 100;
                    else if (pu.type === 'life') { this.lives = Math.min(5, this.lives + 1); this.livesText.setText('â¤ï¸ LIVES: ' + this.lives); }
                    else if (pu.type === 'slow') this.gameSpeed = Math.max(0.6, this.gameSpeed - 0.15);
                    pu.gfx.destroy();
                    this.powerups.splice(i, 1);
                    continue;
                }

                if (pu.y > H + 30) {
                    pu.gfx.destroy();
                    this.powerups.splice(i, 1);
                }
            }

            // Update particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= 0.03 * dt;
                p.gfx.x = p.x;
                p.gfx.y = p.y;
                p.gfx.alpha = Math.max(0, p.life);
                if (p.life <= 0) {
                    p.gfx.destroy();
                    this.particles.splice(i, 1);
                }
            }

            // Score & altitude
            this.altitude += this.gameSpeed * 1.5 * dt;
            this.gameSpeed += 0.00005 * dt;
            this.scoreText.setText('ðŸš€ SCORE: ' + this.score);
            this.altText.setText('ALT: ' + Math.floor(this.altitude) + 'm');
            this.speedText.setText('âš¡ ' + this.gameSpeed.toFixed(1) + 'x');

            // Render 3D rocket to Phaser texture each frame
            if (rocketLoaded && this.rocket3DSprite) {
                this.rocketGfx.setVisible(false);
                render3DRocket(this.rocketContainer.rotation, this.cursors.space.isDown);
                // Copy offscreen 3D canvas to the Phaser texture's source canvas
                const tex = this.textures.get('rocket3d');
                const srcCanvas = tex.getSourceImage();
                const ctx = srcCanvas.getContext('2d');
                ctx.clearRect(0, 0, ROCKET_TEX_SIZE, ROCKET_TEX_SIZE);
                ctx.drawImage(rocketCanvas3D, 0, 0);
                tex.update();
            }
        }

        spawnObstacle() {
            const isAsteroid = Math.random() > 0.3;
            const x = Phaser.Math.Between(20, W - 20);
            const g = this.add.graphics();
            let radius, color;

            if (isAsteroid) {
                radius = 12 + Math.random() * 18;
                const shade = Phaser.Math.Between(60, 100);
                color = Phaser.Display.Color.GetColor(shade + 40, shade, shade - 20);
                // Draw irregular asteroid
                g.fillStyle(color);
                g.beginPath();
                const pts = 7 + Math.floor(Math.random() * 4);
                for (let i = 0; i < pts; i++) {
                    const angle = (i / pts) * Math.PI * 2;
                    const r = radius * (0.7 + Math.random() * 0.3);
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) g.moveTo(px, py);
                    else g.lineTo(px, py);
                }
                g.closePath();
                g.fillPath();
                // Crater
                g.fillStyle(0x000000, 0.2);
                g.fillCircle(radius * 0.2, -radius * 0.15, radius * 0.25);
            } else {
                // Glowing star
                radius = 8 + Math.random() * 10;
                const starColors = [0xffee44, 0xffaa00, 0xff6644, 0x44aaff, 0xff44ff];
                color = starColors[Math.floor(Math.random() * starColors.length)];
                // Glow
                g.fillStyle(color, 0.15);
                g.fillCircle(0, 0, radius * 3);
                g.fillStyle(color, 0.3);
                g.fillCircle(0, 0, radius * 1.8);
                // Star shape
                g.fillStyle(color);
                g.beginPath();
                for (let i = 0; i < 10; i++) {
                    const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
                    const r = i % 2 === 0 ? radius : radius * 0.4;
                    const px = Math.cos(angle) * r;
                    const py = Math.sin(angle) * r;
                    if (i === 0) g.moveTo(px, py);
                    else g.lineTo(px, py);
                }
                g.closePath();
                g.fillPath();
                // Bright center
                g.fillStyle(0xffffff, 0.8);
                g.fillCircle(0, 0, radius * 0.2);
            }

            g.x = x;
            g.y = -40;

            this.obstacles.push({
                x, y: -40, gfx: g,
                speed: 1.5 + Math.random() * 2,
                radius,
                rotSpeed: (Math.random() - 0.5) * 0.04,
                color
            });
        }

        spawnPowerup() {
            const types = ['score', 'life', 'slow'];
            const type = types[Math.floor(Math.random() * types.length)];
            const colors = { score: 0xffff00, life: 0xff4488, slow: 0x00ff88 };
            const labels = { score: '$', life: 'â™¥', slow: 'âš¡' };
            const x = Phaser.Math.Between(30, W - 30);
            const g = this.add.graphics();
            const col = colors[type];

            // Glowing diamond
            g.fillStyle(col, 0.15);
            g.fillCircle(0, 0, 20);
            g.fillStyle(col, 0.8);
            g.beginPath();
            g.moveTo(0, -12); g.lineTo(10, 0); g.lineTo(0, 12); g.lineTo(-10, 0);
            g.closePath();
            g.fillPath();
            g.lineStyle(1.5, 0xffffff, 0.6);
            g.beginPath();
            g.moveTo(0, -12); g.lineTo(10, 0); g.lineTo(0, 12); g.lineTo(-10, 0);
            g.closePath();
            g.strokePath();

            // Label
            const label = this.add.text(0, 0, labels[type], {
                fontSize: '14px', fontFamily: 'Segoe UI', color: '#fff', fontStyle: 'bold'
            }).setOrigin(0.5);

            const container = this.add.container(x, -30, [g, label]);

            this.powerups.push({ x, y: -30, gfx: container, type });
        }

        spawnExplosion(x, y, color) {
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spd = 1 + Math.random() * 3;
                const size = 2 + Math.random() * 3;
                const pg = this.add.circle(x, y, size, color || 0xff8800, 1);
                this.particles.push({
                    x, y, gfx: pg,
                    vx: Math.cos(angle) * spd,
                    vy: Math.sin(angle) * spd,
                    life: 1
                });
            }
        }

        setup3DRocketSprite() {
            // Render one frame to initialize the texture
            render3DRocket(0, false);
            // Create a Phaser canvas texture from the offscreen 3D canvas
            const texCanvas = document.createElement('canvas');
            texCanvas.width = ROCKET_TEX_SIZE;
            texCanvas.height = ROCKET_TEX_SIZE;
            texCanvas.getContext('2d').drawImage(rocketCanvas3D, 0, 0);
            if (this.textures.exists('rocket3d')) this.textures.remove('rocket3d');
            this.textures.addCanvas('rocket3d', texCanvas);
            // Create sprite and add to rocket container
            this.rocket3DSprite = this.add.sprite(0, 0, 'rocket3d');
            this.rocket3DSprite.setDisplaySize(80, 80);
            this.rocketContainer.add(this.rocket3DSprite);
            // Hide the 2D graphics rocket
            this.rocketGfx.setVisible(false);
        }

        endGame() {
            this.isOver = true;
            SFX.gameOver();
            this.scene.start('GameOverScene', { score: this.score, altitude: Math.floor(this.altitude) });
        }
    }

    class GameOverScene extends Phaser.Scene {
        constructor() { super('GameOverScene'); }

        create(data) {
            // Stars
            for (let i = 0; i < 80; i++) {
                this.add.circle(
                    Phaser.Math.Between(0, W), Phaser.Math.Between(0, H),
                    1, 0xffffff, 0.3 + Math.random() * 0.4
                );
            }

            this.add.text(W / 2, H * 0.25, 'ðŸ’¥ GAME OVER', {
                fontSize: '34px', fontFamily: 'Segoe UI, sans-serif', fontStyle: 'bold', color: '#ff4466',
                shadow: { offsetX: 0, offsetY: 0, color: '#ff4466', blur: 20, fill: true }
            }).setOrigin(0.5);

            this.add.text(W / 2, H * 0.38, `Score: ${data.score}`, {
                fontSize: '28px', fontFamily: 'Segoe UI, sans-serif', fontStyle: 'bold', color: '#0ff',
                shadow: { offsetX: 0, offsetY: 0, color: '#0ff', blur: 15, fill: true }
            }).setOrigin(0.5);

            this.add.text(W / 2, H * 0.46, `Altitude: ${data.altitude}m`, {
                fontSize: '20px', fontFamily: 'Segoe UI, sans-serif', color: '#f0a',
                shadow: { offsetX: 0, offsetY: 0, color: '#f0a', blur: 10, fill: true }
            }).setOrigin(0.5);

            // Retry button
            const btn = this.add.rectangle(W / 2, H * 0.62, 200, 55, 0x0088ff).setInteractive({ useHandCursor: true });
            const btnGlow = this.add.rectangle(W / 2, H * 0.62, 210, 65, 0x00ccff, 0.15);
            this.add.text(W / 2, H * 0.62, 'TRY AGAIN', {
                fontSize: '20px', fontFamily: 'Segoe UI, sans-serif', fontStyle: 'bold', color: '#fff', letterSpacing: 3
            }).setOrigin(0.5);

            this.tweens.add({ targets: btnGlow, scaleX: 1.15, scaleY: 1.15, alpha: 0, duration: 1200, repeat: -1 });

            btn.on('pointerover', () => btn.setFillStyle(0x00aaff));
            btn.on('pointerout', () => btn.setFillStyle(0x0088ff));
            btn.on('pointerdown', () => this.scene.start('GameScene'));

            this.input.keyboard.on('keydown-SPACE', () => this.scene.start('GameScene'));
        }
    }

    const config = {
        type: Phaser.AUTO,
        width: W,
        height: H,
        backgroundColor: '#050510',
        parent: document.body,
        scene: [MenuScene, GameScene, GameOverScene],
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH
        },
        physics: { default: 'arcade' }
    };

    const game = new Phaser.Game(config);
    </script>
</body>
</html>
