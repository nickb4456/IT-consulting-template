<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://appsforoffice.microsoft.com; style-src 'self' 'unsafe-inline'; connect-src 'self' https://6b2bpmn8f8.execute-api.us-east-1.amazonaws.com; img-src 'self' data:; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self';">
    <title>DraftBridge</title>
    <link rel="stylesheet" href="src/styles/tokens.css">
    <link rel="stylesheet" href="src/styles/base.css">
    <link rel="stylesheet" href="src/styles/taskpane.css">
    <link rel="stylesheet" href="src/taskpane/smart-variables.css">
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <header class="header" role="banner">
        <span>Draft<span>Bridge</span></span>
        <div class="header-actions">
            <button class="voice-toggle-btn" onclick="toggleVoiceWindow()" title="Voice Control - Say commands like 'Insert clause' or 'Fill variables' (Ctrl+Shift+V)">Voice</button>
            <button class="help-btn" onclick="showHelpDialog()" title="Help & Support">Help</button>
        </div>
    </header>

    <!-- ONBOARDING MODAL -->
    <div class="onboarding-overlay hidden" id="onboarding-modal">
        <div class="onboarding-modal">
            <div class="onboarding-header">
                <div class="onboarding-logo">DB</div>
                <div class="onboarding-title">Welcome to DraftBridge</div>
                <div class="onboarding-subtitle">Legal document automation for modern law firms</div>
            </div>
            <div class="onboarding-body">
                <ul class="onboarding-features">
                    <li>
                        <span class="feature-icon">•</span>
                        <div class="feature-text">
                            <div class="feature-title">Clause Library</div>
                            <div class="feature-desc">One-tap access to your firm's approved clauses</div>
                        </div>
                    </li>
                    <li>
                        <span class="feature-icon">•</span>
                        <div class="feature-text">
                            <div class="feature-title">Smart Numbering</div>
                            <div class="feature-desc">Legal outline formats with one click (I. A. 1. (a))</div>
                        </div>
                    </li>
                    <li>
                        <span class="feature-icon">•</span>
                        <div class="feature-text">
                            <div class="feature-title">Fill Variables</div>
                            <div class="feature-desc">Find all {{placeholders}} and fill them at once</div>
                        </div>
                    </li>
                    <li>
                        <span class="feature-icon">•</span>
                        <div class="feature-text">
                            <div class="feature-title">Custom Templates</div>
                            <div class="feature-desc">Build reusable templates with drag & drop</div>
                        </div>
                    </li>
                </ul>
            </div>
            <div class="onboarding-footer">
                <button class="btn" onclick="completeOnboarding()">Get Started →</button>
                <div class="onboarding-skip" onclick="completeOnboarding()">I've used DraftBridge before</div>
            </div>
        </div>
    </div>
    
    <nav class="main-tabs-container" role="tablist" aria-label="Main navigation">
        <button class="tab-arrow" id="tab-prev" onclick="slideTab(-1)" disabled>‹</button>
        <div class="main-tabs" id="main-tabs">
            <button class="main-tab active" onclick="switchPanel('generate')" aria-label="Generate documents">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="12" y1="18" x2="12" y2="12"/>
                    <line x1="9" y1="15" x2="15" y2="15"/>
                </svg>
                <span class="tab-label">Generate</span>
            </button>
            <button class="main-tab" onclick="switchPanel('numbering')" aria-label="Numbering and table of contents">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <line x1="10" y1="6" x2="21" y2="6"/>
                    <line x1="10" y1="12" x2="21" y2="12"/>
                    <line x1="10" y1="18" x2="21" y2="18"/>
                    <path d="M4 6h1v4"/>
                    <path d="M4 10h2"/>
                    <path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"/>
                </svg>
                <span class="tab-label">Numbering</span>
            </button>
            <button class="main-tab" onclick="switchPanel('library')" aria-label="Clause library">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/>
                    <line x1="8" y1="6" x2="16" y2="6"/>
                    <line x1="8" y1="10" x2="14" y2="10"/>
                </svg>
                <span class="tab-label">Library</span>
            </button>
            <button class="main-tab" onclick="switchPanel('admin')" aria-label="Application settings">
                <svg class="tab-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="3"/>
                    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                </svg>
                <span class="tab-label">Settings</span>
            </button>
        </div>
        <button class="tab-arrow" id="tab-next" onclick="slideTab(1)">›</button>
    </nav>
    
    <main id="main-content" role="main">
    <!-- GENERATE PANEL -->
    <div class="panel active" id="panel-generate" role="tabpanel">
        <div class="sub-panel active" id="generate-main">
            <div class="content">
                <div class="section-header">Create Document</div>
                <div class="section-desc">Choose a template to start</div>
                
                <div class="option-card" onclick="showTemplate('letter')">
                    <span class="option-icon"></span>
                    <div class="option-text">
                        <div class="option-title">Letter</div>
                        <div class="option-desc">Formal business letter</div>
                    </div>
                    <span class="option-arrow">→</span>
                </div>
                
                <div class="option-card" onclick="showTemplate('memo')">
                    <span class="option-icon"></span>
                    <div class="option-text">
                        <div class="option-title">Memorandum</div>
                        <div class="option-desc">Internal memo</div>
                    </div>
                    <span class="option-arrow">→</span>
                </div>
                
                <div class="option-card" onclick="showTemplate('fax')">
                    <span class="option-icon"></span>
                    <div class="option-text">
                        <div class="option-title">Fax Cover</div>
                        <div class="option-desc">Fax cover sheet</div>
                    </div>
                    <span class="option-arrow">→</span>
                </div>
                
                <div class="divider">
                    <span class="divider-label">Tools</span>
                </div>
                
                <div class="option-card" onclick="showFillVariables()">
                    <span class="option-icon"></span>
                    <div class="option-text">
                        <div class="option-title">Fill Variables</div>
                        <div class="option-desc">Find {{placeholders}} & bookmarks, fill all at once</div>
                    </div>
                    <span class="option-arrow">→</span>
                </div>
            </div>
        </div>
        
        <!-- Fill Variables - Now uses modal, see fill-vars-modal -->
        
        <!-- Letter Form -->
        <div class="sub-panel" id="generate-letter">
            <button class="back-btn" onclick="hideTemplate()">← Back</button>
            <div class="content">
                <div class="section-header">Letter</div>
                <div class="section-desc">Fill in the details</div>
                
                <div class="field">
                    <label>Date</label>
                    <input type="date" id="letter-date">
                </div>
                <div class="field">
                    <label>Recipient Name</label>
                    <input type="text" id="letter-recipient" placeholder="John Smith">
                </div>
                <div class="field">
                    <label>Recipient Address</label>
                    <textarea id="letter-address" placeholder="123 Main St&#10;City, State 12345"></textarea>
                </div>
                <div class="field">
                    <label>RE: Subject</label>
                    <input type="text" id="letter-subject" placeholder="Subject matter">
                </div>
                <div class="field">
                    <label>Closing</label>
                    <select id="letter-closing">
                        <option value="Sincerely">Sincerely</option>
                        <option value="Very truly yours">Very truly yours</option>
                        <option value="Best regards">Best regards</option>
                        <option value="Respectfully">Respectfully</option>
                        <option value="Cordially">Cordially</option>
                        <option value="Regards">Regards</option>
                        <option value="Yours truly">Yours truly</option>
                        <option value="With kind regards">With kind regards</option>
                    </select>
                </div>
                <div class="field">
                    <label>Delivery Method</label>
                    <select id="letter-delivery">
                        <option value="">(None)</option>
                        <option value="Via Email">Via Email</option>
                        <option value="Via Certified Mail">Via Certified Mail</option>
                        <option value="Via Federal Express">Via Federal Express</option>
                        <option value="Via Facsimile">Via Facsimile</option>
                        <option value="Via Hand Delivery">Via Hand Delivery</option>
                        <option value="Via First Class Mail">Via First Class Mail</option>
                        <option value="Via Overnight Delivery">Via Overnight Delivery</option>
                    </select>
                </div>
                <div class="field">
                    <label>Enclosures</label>
                    <select id="letter-enclosures">
                        <option value="">(None)</option>
                        <option value="Enclosure">Enclosure</option>
                        <option value="Enclosures">Enclosures</option>
                        <option value="Enc.">Enc.</option>
                        <option value="Attachment">Attachment</option>
                        <option value="Attachments">Attachments</option>
                        <option value="Enclosures as stated">Enclosures as stated</option>
                    </select>
                </div>
                <div class="field">
                    <label>Author</label>
                    <select id="letter-signer" class="author-select"></select>
                </div>
                <div class="field">
                    <label>Include Job Title</label>
                    <select id="letter-title-option">
                        <option value="yes">Yes - from author profile</option>
                        <option value="no">No</option>
                        <option value="custom">Custom...</option>
                    </select>
                    <input type="text" id="letter-title-custom" placeholder="Custom title" style="display:none; margin-top:8px;">
                </div>
            </div>
            <div class="actions">
                <button class="btn" onclick="generateLetter()">Generate Letter</button>
            </div>
        </div>
        
        <!-- Memo Form -->
        <div class="sub-panel" id="generate-memo">
            <button class="back-btn" onclick="hideTemplate()">← Back</button>
            <div class="content">
                <div class="section-header">Memorandum</div>
                <div class="section-desc">Fill in the details</div>
                
                <div class="field">
                    <label>Date</label>
                    <input type="date" id="memo-date">
                </div>
                <div class="field">
                    <label>To</label>
                    <input type="text" id="memo-to" placeholder="Recipient name(s)">
                </div>
                <div class="field">
                    <label>From</label>
                    <select id="memo-from" class="author-select"></select>
                </div>
                <div class="field">
                    <label>Subject</label>
                    <input type="text" id="memo-subject" placeholder="Brief description">
                </div>
                <div class="field">
                    <label>CC (optional)</label>
                    <input type="text" id="memo-cc" placeholder="Copy recipients">
                </div>
            </div>
            <div class="actions">
                <button class="btn" onclick="generateMemo()">Generate Memo</button>
            </div>
        </div>
        
        <!-- Fax Form -->
        <div class="sub-panel" id="generate-fax">
            <button class="back-btn" onclick="hideTemplate()">← Back</button>
            <div class="content">
                <div class="section-header">Fax Cover Sheet</div>
                <div class="section-desc">Fill in the details</div>
                
                <div class="field">
                    <label>Date</label>
                    <input type="date" id="fax-date">
                </div>
                <div class="field">
                    <label>To</label>
                    <input type="text" id="fax-to" placeholder="Recipient name">
                </div>
                <div class="field">
                    <label>Fax Number</label>
                    <input type="text" id="fax-number" placeholder="(555) 123-4567">
                </div>
                <div class="field">
                    <label>From</label>
                    <select id="fax-from" class="author-select"></select>
                </div>
                <div class="field">
                    <label>Phone</label>
                    <input type="text" id="fax-phone" placeholder="(555) 987-6543">
                </div>
                <div class="field">
                    <label>Pages</label>
                    <input type="number" id="fax-pages" placeholder="1" value="1">
                </div>
                <div class="field">
                    <label>RE: Subject</label>
                    <input type="text" id="fax-subject" placeholder="Subject matter">
                </div>
            </div>
            <div class="actions">
                <button class="btn" onclick="generateFax()">Generate Fax Cover</button>
            </div>
        </div>
    </div>
    
    <!-- SMART TEMPLATES PANEL -->
    <!-- Smart panel removed - functionality available via Settings -->
    <div class="panel" id="panel-smart" style="display:none;" role="tabpanel">
        <div id="smart-templates-root" class="content" style="padding: 0;">
            <!-- Smart Variables UI renders here -->
        </div>
    </div>
    
    <!-- API KEY MODAL -->
    <div class="modal-overlay hidden" id="apikey-modal">
        <div class="modal">
            <div class="modal-header">
                <span>API Key Configuration</span>
                <button class="modal-close" onclick="hideApiKeyModal()">×</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: #666; font-size: 13px;">
                    Enter your DraftBridge API key to sync templates, clauses, and settings across devices.
                </p>
                <div class="field">
                    <label>API Key *</label>
                    <input type="password" id="apikey-input" placeholder="Enter your API key" style="font-family: monospace;">
                </div>
                <div id="apikey-status" style="margin-top: 12px; padding: 10px; border-radius: 6px; display: none;"></div>
                <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px; padding: 12px; margin-top: 16px;">
                    <strong style="color: #1565c0;">Where to get your API key</strong>
                    <p style="color: #1565c0; font-size: 12px; margin-top: 4px;">
                        Contact your firm administrator or email support@draftbridge.com to receive your API key.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" onclick="hideApiKeyModal()">Cancel</button>
                <button class="btn" onclick="validateAndSaveApiKey()" id="apikey-save-btn">
                    <span id="apikey-save-text">Validate & Save</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- ENCRYPTION MODAL -->
    <div class="modal-overlay hidden" id="encrypt-modal">
        <div class="modal">
            <div class="modal-header">
                <span>Export Encrypted Copy</span>
                <button class="modal-close" onclick="hideEncryptModal()">×</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: #666; font-size: 13px;">
                    Your document will be encrypted with AES-256-GCM (military-grade encryption). 
                    Only someone with the password can decrypt it.
                </p>
                <div class="field">
                    <label>Password *</label>
                    <input type="password" id="encrypt-password" placeholder="Enter a strong password">
                </div>
                <div class="field">
                    <label>Confirm Password *</label>
                    <input type="password" id="encrypt-password-confirm" placeholder="Confirm password">
                </div>
                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 12px; margin-top: 16px;">
                    <strong style="color: #856404;">Warning:</strong>
                    <p style="color: #856404; font-size: 12px; margin-top: 4px;">
                        If you forget this password, the document cannot be recovered. 
                        There is no password reset.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" onclick="hideEncryptModal()">Cancel</button>
                <button class="btn" onclick="encryptAndExport()">Encrypt & Download</button>
            </div>
        </div>
    </div>
    
    <!-- OCR MODAL -->
    <div class="modal-overlay hidden" id="ocr-modal">
        <div class="modal">
            <div class="modal-header">
                <span>Make PDF Searchable (OCR)</span>
                <button class="modal-close" onclick="hideOcrModal()">×</button>
            </div>
            <div class="modal-body">
                <div id="ocr-step-upload">
                    <p style="margin-bottom: 16px; color: #666; font-size: 13px;">
                        Courts require searchable PDFs for e-filing. Upload a scanned PDF and we'll convert it to searchable text using AWS Textract.
                    </p>
                    <div class="field">
                        <label>Select Scanned PDF</label>
                        <input type="file" id="ocr-file" accept=".pdf" style="padding: 8px;" onchange="checkPdfSearchable()">
                    </div>
                    <div id="ocr-check-result" style="display: none; margin-top: 12px;"></div>
                </div>
                
                <div id="ocr-step-processing" style="display: none;">
                    <div style="text-align: center; padding: 30px 0;">
                        <div class="scanning-spinner" style="margin: 0 auto 16px;"></div>
                        <div style="font-size: 14px; color: #666;">Processing with AWS Textract...</div>
                        <div id="ocr-progress" style="font-size: 12px; color: #999; margin-top: 8px;">Uploading...</div>
                    </div>
                </div>
                
                <div id="ocr-step-complete" style="display: none;">
                    <div style="padding: 16px 0;">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div class="status-success-dot" style="width: 36px; height: 36px; border-radius: 50%; background: #059669; margin: 0 auto 8px;"></div>
                            <div style="font-size: 16px; font-weight: 600; color: #2e7d32;">Text Extracted!</div>
                            <div id="ocr-stats" style="font-size: 12px; color: #666; margin-top: 4px;"></div>
                        </div>
                        <div style="background: #f5f5f5; border-radius: 8px; padding: 12px; max-height: 200px; overflow-y: auto;">
                            <pre id="ocr-text-preview" style="font-size: 12px; white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: inherit;"></pre>
                        </div>
                        <div style="display: flex; gap: 8px; margin-top: 12px;">
                            <button class="btn secondary" style="flex: 1;" onclick="copyOcrText()">Copy Text</button>
                            <button class="btn" style="flex: 1;" onclick="insertOcrText()">Insert into Doc</button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer" id="ocr-footer">
                <button class="btn secondary" onclick="hideOcrModal()">Cancel</button>
                <button class="btn" id="ocr-process-btn" onclick="processOcr()" disabled>Run OCR</button>
            </div>
        </div>
    </div>
    
    <!-- DECRYPT MODAL -->
    <div class="modal-overlay hidden" id="decrypt-modal">
        <div class="modal">
            <div class="modal-header">
                <span>Decrypt Document</span>
                <button class="modal-close" onclick="hideDecryptModal()">×</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 16px; color: #666; font-size: 13px;">
                    Select an encrypted file (.docx.enc) to decrypt and open.
                </p>
                <div class="field">
                    <label>Encrypted File *</label>
                    <input type="file" id="decrypt-file" accept=".enc" style="padding: 8px;">
                </div>
                <div class="field">
                    <label>Password *</label>
                    <input type="password" id="decrypt-password" placeholder="Enter decryption password">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn secondary" onclick="hideDecryptModal()">Cancel</button>
                <button class="btn" onclick="decryptAndOpen()">Decrypt & Insert</button>
            </div>
        </div>
    </div>
    
    <!-- FIX ALL MODAL -->
    <div class="modal-overlay hidden" id="fix-all-modal">
        <div class="modal" style="max-width: 450px;">
            <div class="modal-header">
                <span id="fix-all-modal-title">Fix All Issues</span>
                <button class="modal-close" onclick="hideFixAllModal()">×</button>
            </div>
            <div class="modal-body" id="fix-all-modal-body">
                <!-- Content populated dynamically -->
            </div>
            <div class="modal-footer" id="fix-all-modal-footer">
                <!-- Buttons populated dynamically -->
            </div>
        </div>
    </div>
    
    <!-- FILL VARIABLES MODAL -->
    <div class="modal-overlay hidden" id="fill-vars-modal">
        <div class="fill-vars-modal">
            <div class="fill-vars-header">
                <div class="fill-vars-header-title">
                    <span class="icon"></span>
                    <span>Fill Variables</span>
                </div>
                <div style="display: flex; align-items: center; gap: 12px;">
                    <span class="fill-vars-header-badge" id="fill-vars-badge">0 found</span>
                    <button class="fill-vars-close" onclick="closeFillVarsModal()">×</button>
                </div>
            </div>
            
            <!-- Scanning State -->
            <div class="fill-vars-body" id="fill-vars-scanning-state">
                <div class="fill-vars-scanning" style="flex: 1; display: flex;">
                    <div class="spinner"></div>
                    <div class="fill-vars-scanning-text">Scanning document for variables...</div>
                </div>
            </div>
            
            <!-- Empty State -->
            <div class="fill-vars-body hidden" id="fill-vars-empty-state">
                <div class="fill-vars-empty" style="flex: 1;">
                    <div class="fill-vars-empty-icon"></div>
                    <div class="fill-vars-empty-title">No Variables Found</div>
                    <div class="fill-vars-empty-desc">
                        Your document doesn't contain any fillable variables.<br>
                        Use placeholders like this:
                    </div>
                    <div class="fill-vars-empty-code">{{client_name}}</div>
                </div>
            </div>
            
            <!-- Main Content -->
            <div class="fill-vars-body hidden" id="fill-vars-content">
                <!-- Form Section -->
                <div class="fill-vars-form-section">
                    <div class="fill-vars-form-header">
                        <span class="fill-vars-form-title">Variables</span>
                        <button class="fill-vars-clear-btn" onclick="clearAllFillVars()">Clear All</button>
                    </div>
                    <div id="fill-vars-form">
                        <!-- Variables form will be populated here -->
                    </div>
                </div>
                
                <!-- Preview Section -->
                <div class="fill-vars-preview-section">
                    <div class="fill-vars-preview-header">
                        <span class="fill-vars-preview-title">Preview</span>
                        <div class="fill-vars-preview-toggle">
                            <button class="preview-toggle-btn active" onclick="setPreviewMode('before')">Before</button>
                            <button class="preview-toggle-btn" onclick="setPreviewMode('after')">After</button>
                        </div>
                    </div>
                    <div class="fill-vars-preview-content" id="fill-vars-preview">
                        <!-- Preview will be populated here -->
                    </div>
                </div>
            </div>
            
            <!-- Footer -->
            <div class="fill-vars-footer" id="fill-vars-footer" style="display: none;">
                <div class="fill-vars-stats">
                    <strong id="fill-vars-filled-count">0</strong> of <span id="fill-vars-total-count">0</span> filled
                </div>
                <div class="fill-vars-actions">
                    <button class="fill-vars-btn secondary" onclick="closeFillVarsModal()">Cancel</button>
                    <button class="fill-vars-btn primary" id="fill-vars-apply-btn" onclick="applyFillVariables()">
                        Apply Changes
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- VOICE CONTROL WINDOW -->
    <div id="voice-control" class="voice-window hidden">
        <div class="voice-header">
            <span>Voice Control</span>
            <button class="voice-close" onclick="closeVoiceControl()">×</button>
        </div>
        <div class="voice-body">
            <div id="voice-status" class="voice-status">
                <div class="voice-icon" id="voice-icon"></div>
                <div class="voice-text" id="voice-text">Press to speak...</div>
            </div>
            <div id="voice-transcript" class="voice-transcript"></div>
            <div id="voice-action" class="voice-action"></div>
        </div>
        <div class="voice-footer">
            <button class="btn small" id="voice-btn" onclick="toggleVoiceListening()">Start Listening</button>
            <div class="voice-hint">Ctrl+Shift+V to toggle</div>
        </div>
    </div>
    
    <!-- ========== NUMBERING & TOC PANEL (REDESIGNED) ========== -->
    <div class="panel" id="panel-numbering" role="tabpanel">
        <!-- Sub-navigation: Numbering vs TOC vs Fix — single line with arrow overflow -->
        <div class="sub-nav-container">
            <button class="sub-nav-arrow" id="subnav-prev" onclick="slideSubNav(-1)" disabled>&lsaquo;</button>
            <div class="sub-nav" id="sub-nav-strip">
                <button class="sub-nav-btn active" onclick="switchNumberingMode('numbering')">Numbering</button>
                <button class="sub-nav-btn" onclick="switchNumberingMode('fix')">Fix</button>
                <button class="sub-nav-btn" onclick="switchNumberingMode('toc')">TOC</button>
            </div>
            <button class="sub-nav-arrow" id="subnav-next" onclick="slideSubNav(1)">&rsaquo;</button>
            <!-- Health Score Badge -->
            <div class="health-badge" id="numbering-health-badge" onclick="onHealthBadgeClick()" title="Click to view issues">
                <span class="health-dot" id="health-dot"></span>
                <span class="health-label" id="health-label">—</span>
            </div>
            
            <!-- Location Indicator Toggle -->
            <button class="location-toggle" id="location-toggle" onclick="toggleLocationIndicator()" title="Show paragraph location (Ctrl+Shift+L)">
                <span class="location-toggle-icon"></span>
                <span>Location</span>
            </button>
        </div>
        
        <!-- Location Status Bar (shows current paragraph number) -->
        <div class="location-status-bar" id="location-status-bar">
            <span class="location-status-icon"></span>
            <span class="location-status-label">Current:</span>
            <span class="location-status-value" id="location-para-number">—</span>
            <span class="location-status-text" id="location-para-text"></span>
            <span class="location-shortcut">Ctrl+Shift+L</span>
        </div>
        
        <!-- NUMBERING SECTION -->
        <div class="sub-panel active" id="numbering-browse">
            <div class="content">
                <!-- Live Preview Card -->
                <div class="preview-card">
                    <div class="preview-label">Preview</div>
                    <div class="preview-content" id="numbering-preview">
                        <div class="preview-line l1"><span class="num">I.</span> Article One</div>
                        <div class="preview-line l2"><span class="num">A.</span> Section Title</div>
                        <div class="preview-line l3"><span class="num">1.</span> Paragraph text</div>
                        <div class="preview-line l4"><span class="num">(a)</span> Sub-paragraph</div>
                        <div class="preview-line l5"><span class="num">(i)</span> Detail item</div>
                    </div>
                </div>
                
                <div class="section-label">Select a Scheme</div>
                
                <!-- Scheme Cards (Modern, Large) - Hover to preview, click to select -->
                <div class="scheme-grid">
                    <div class="scheme-card selected" onclick="selectSchemeCard('legal-outline', this)" onmouseenter="previewScheme('legal-outline')" onmouseleave="restoreSelectedPreview()">
                        <div class="scheme-card-check"></div>
                        <div class="scheme-card-name">Legal Outline</div>
                        <div class="scheme-card-preview">I - A - 1 - (a) - (i)</div>
                    </div>
                    <div class="scheme-card" onclick="selectSchemeCard('contract-sections', this)" onmouseenter="previewScheme('contract-sections')" onmouseleave="restoreSelectedPreview()">
                        <div class="scheme-card-check"></div>
                        <div class="scheme-card-name">Contract</div>
                        <div class="scheme-card-preview">Art. I - S1 - a - (i)</div>
                    </div>
                    <div class="scheme-card" onclick="selectSchemeCard('heading-style', this)" onmouseenter="previewScheme('heading-style')" onmouseleave="restoreSelectedPreview()">
                        <div class="scheme-card-check"></div>
                        <div class="scheme-card-name">Heading</div>
                        <div class="scheme-card-preview">1. - 1.1 - 1.1.1</div>
                    </div>
                    <div class="scheme-card" onclick="selectSchemeCard('pleading-format', this)" onmouseenter="previewScheme('pleading-format')" onmouseleave="restoreSelectedPreview()">
                        <div class="scheme-card-check"></div>
                        <div class="scheme-card-name">Pleading</div>
                        <div class="scheme-card-preview">1 - a - (1) - (a)</div>
                    </div>
                </div>
                
                <!-- Document & Personal Schemes -->
                <div class="schemes-section">
                    <div class="schemes-section-header" onclick="toggleSchemesSection('document')">
                        <span>From This Document</span>
                        <span class="toggle-arrow" id="toggle-document">▼</span>
                    </div>
                    <div class="schemes-section-body" id="section-document">
                        <div class="scheme-list-item" onclick="selectSchemeCard('doc-1', this)" onmouseenter="previewScheme('doc-1')" onmouseleave="restoreSelectedPreview()">
                            Document Scheme
                        </div>
                    </div>
                </div>
                
                <div class="schemes-section">
                    <div class="schemes-section-header" onclick="toggleSchemesSection('personal')">
                        <span>My Saved Schemes</span>
                        <span class="toggle-arrow" id="toggle-personal">▼</span>
                    </div>
                    <div class="schemes-section-body" id="section-personal">
                        <div id="user-schemes-container"></div>
                        <button class="add-scheme-btn" onclick="captureNumberingFromDocument()">Save from Document</button>
                        <button class="add-scheme-btn" onclick="showNumberingEditor()">+ Create New Scheme</button>
                    </div>
                </div>
            </div>
            
            <div class="actions">
                <button class="btn" onclick="applySelectedScheme()">Insert</button>
                <button class="btn secondary" onclick="openWordNumberingDialog()">Edit</button>
            </div>
        </div>
        
        <!-- TOC SECTION -->
        <div class="sub-panel" id="toc-browse">
            <div class="content">
                <div class="section-label">Table of Contents Style</div>
                
                <!-- TOC Style Cards -->
                <div class="toc-grid">
                    <div class="toc-card selected" onclick="selectTocStyle('level1', this)">
                        <div class="toc-card-check"></div>
                        <div class="toc-card-title">Level 1 Only</div>
                        <div class="toc-card-desc">Top-level headings</div>
                        <div class="toc-card-preview">
                            <div>I. First Article</div>
                            <div>II. Second Article</div>
                        </div>
                    </div>
                    <div class="toc-card" onclick="selectTocStyle('level12', this)">
                        <div class="toc-card-check"></div>
                        <div class="toc-card-title">Levels 1 & 2</div>
                        <div class="toc-card-desc">Articles + Sections</div>
                        <div class="toc-card-preview">
                            <div>I. First Article</div>
                            <div class="indent">A. Section One</div>
                            <div class="indent">B. Section Two</div>
                        </div>
                    </div>
                    <div class="toc-card" onclick="selectTocStyle('level123', this)">
                        <div class="toc-card-check"></div>
                        <div class="toc-card-title">Levels 1-3</div>
                        <div class="toc-card-desc">Full detail</div>
                        <div class="toc-card-preview">
                            <div>I. First Article</div>
                            <div class="indent">A. Section</div>
                            <div class="indent2">1. Para</div>
                        </div>
                    </div>
                </div>
                
                <!-- TOC Options -->
                <div class="options-card">
                    <div class="options-title">Options</div>
                    <label class="option-row">
                        <input type="checkbox" id="toc-hyperlinks" checked>
                        <span>Use Hyperlinks</span>
                    </label>
                    <label class="option-row">
                        <input type="checkbox" id="toc-page-numbers" checked>
                        <span>Show Page Numbers</span>
                    </label>
                    <label class="option-row">
                        <input type="checkbox" id="toc-right-align">
                        <span>Right-Align Page Numbers</span>
                    </label>
                    <label class="option-row">
                        <input type="checkbox" id="toc-dot-leaders" checked>
                        <span>Dot Leaders</span>
                    </label>
                </div>
            </div>
            
            <div class="actions">
                <button class="btn" onclick="insertToc()">Insert TOC</button>
                <button class="btn secondary" onclick="updateToc()">Update TOC</button>
            </div>
        </div>
        
        <!-- FIX NUMBERING SECTION -->
        <div class="sub-panel" id="fix-numbering">
            <div class="content">
                <!-- List Controls Section (Context-Aware) -->
                <div class="list-controls-section inactive" id="list-controls">
                    <div class="list-controls-header">
                        <span class="list-controls-icon"></span>
                        <span class="list-controls-title">List Controls</span>
                        <span class="list-controls-status" id="list-status">Not in a list</span>
                    </div>
                    
                    <div class="list-controls-info" id="list-info" style="display: none;">
                        <div class="info-label">Current item:</div>
                        <div class="info-value" id="list-current-item">—</div>
                    </div>
                    
                    <div class="list-controls-buttons">
                        <button class="list-control-btn" id="btn-continue-list" onclick="continueFromPrevious()" disabled>
                            <span class="list-control-btn-icon"></span>
                            <div class="list-control-btn-text">
                                <div class="list-control-btn-title">Continue from Previous</div>
                                <div class="list-control-btn-desc">Join with the list above</div>
                            </div>
                        </button>
                        
                        <button class="list-control-btn" id="btn-restart-list" onclick="restartAtOne()" disabled>
                            <span class="list-control-btn-icon"></span>
                            <div class="list-control-btn-text">
                                <div class="list-control-btn-title">Restart at 1</div>
                                <div class="list-control-btn-desc">Keep current list, restart numbering</div>
                            </div>
                        </button>
                        
                        <button class="list-control-btn" id="btn-new-list" onclick="startNewList()" disabled>
                            <span class="list-control-btn-icon"></span>
                            <div class="list-control-btn-text">
                                <div class="list-control-btn-title">Start New List</div>
                                <div class="list-control-btn-desc">Create independent list (won't affect others)</div>
                            </div>
                        </button>
                    </div>
                    
                    <div class="list-controls-hint" id="list-hint">
                        <strong>Tip:</strong> Click in a numbered paragraph to enable these controls.
                    </div>
                </div>
                
                <div class="section-label">Repair Document Numbering</div>
                
                <!-- Initial state: Not scanned yet -->
                <div id="fix-initial" class="fix-results">
                    <div class="fix-summary">
                        <span class="fix-summary-icon"></span>
                        <div class="fix-summary-text">
                            <div class="fix-summary-title">Scan for Issues</div>
                            <div class="fix-summary-desc">Check your document for numbering problems</div>
                        </div>
                    </div>
                    <p style="font-size: 13px; color: #666; margin-bottom: 16px;">
                        Common issues detected:
                    </p>
                    <ul style="font-size: 13px; color: #555; margin-left: 20px; line-height: 1.8;">
                        <li>Unexpected number restarts</li>
                        <li>Fragmented lists (should be continuous)</li>
                        <li>Inconsistent numbering formats</li>
                        <li>Orphaned list items</li>
                    </ul>
                </div>
                
                <!-- Scanning state -->
                <div id="fix-scanning" class="fix-results" style="display: none;">
                    <div class="scanning-indicator">
                        <div class="scanning-spinner"></div>
                        <div>Scanning document...</div>
                    </div>
                </div>
                
                <!-- Results: No issues -->
                <div id="fix-clean" class="fix-results" style="display: none;">
                    <div class="fix-summary no-issues">
                        <span class="fix-summary-icon"></span>
                        <div class="fix-summary-text">
                            <div class="fix-summary-title">No Issues Found!</div>
                            <div class="fix-summary-desc">Your document's numbering looks good</div>
                        </div>
                    </div>
                </div>
                
                <!-- Results: Issues found -->
                <div id="fix-issues" class="fix-results" style="display: none;">
                    <div class="fix-summary has-issues">
                        <span class="fix-summary-icon"></span>
                        <div class="fix-summary-text">
                            <div class="fix-summary-title" id="fix-count">Found X Issues</div>
                            <div class="fix-summary-desc">Click to fix individually or use "Fix All"</div>
                        </div>
                    </div>
                    
                    <div id="fix-issues-list">
                        <!-- Issues will be populated here dynamically -->
                    </div>
                </div>
            </div>
            
            <div class="actions">
                <button class="btn secondary" id="btn-scan" onclick="scanForNumberingIssues()">Scan Document</button>
                <button class="btn" id="btn-fix-all" onclick="fixAllNumberingIssues()" style="display: none;">Fix All</button>
            </div>
        </div>
        
        <!-- NUMBERING EDITOR (existing, keep similar) -->
        <div class="sub-panel" id="numbering-editor">
            <button class="back-btn" onclick="hideNumberingEditor()">← Back</button>
            <div class="content">
                <div class="field">
                    <label>Scheme Name</label>
                    <input type="text" id="scheme-name" value="Legal Outline" class="large-input">
                </div>
                
                <!-- Level editors - keep existing but with larger styling -->
                <div class="level-card" id="level-1-card">
                    <div class="level-card-header" onclick="toggleLevelCard(1)">
                        <span class="level-badge">1</span>
                        <span class="level-card-title">Level 1</span>
                        <span class="level-card-sample" id="level-1-sample">I.</span>
                        <span class="level-expand">▼</span>
                    </div>
                    <div class="level-card-body" id="level-1-body">
                        <div class="field-row">
                            <div class="field">
                                <label>Before Number</label>
                                <input type="text" id="level-1-before" placeholder="Article ">
                            </div>
                            <div class="field">
                                <label>Number Style</label>
                                <select id="level-1-style" class="large-select">
                                    <option value="I">I, II, III (Roman)</option>
                                    <option value="1">1, 2, 3 (Numeric)</option>
                                    <option value="A">A, B, C (Alpha)</option>
                                    <option value="a">a, b, c (alpha)</option>
                                    <option value="i">i, ii, iii (roman)</option>
                                    <option value="none">(none)</option>
                                </select>
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label>After Number</label>
                                <input type="text" id="level-1-after" value="." placeholder=".">
                            </div>
                            <div class="field">
                                <label>Followed By</label>
                                <select id="level-1-follow" class="large-select">
                                    <option value="tab">Tab</option>
                                    <option value="space">Space</option>
                                    <option value="nothing">Nothing</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Repeat for levels 2-5 (similar structure) -->
                <div class="level-card collapsed" id="level-2-card">
                    <div class="level-card-header" onclick="toggleLevelCard(2)">
                        <span class="level-badge">2</span>
                        <span class="level-card-title">Level 2</span>
                        <span class="level-card-sample" id="level-2-sample">A.</span>
                        <span class="level-expand">▶</span>
                    </div>
                    <div class="level-card-body" id="level-2-body" style="display:none;">
                        <div class="field-row">
                            <div class="field">
                                <label>Before Number</label>
                                <input type="text" id="level-2-before" placeholder="">
                            </div>
                            <div class="field">
                                <label>Number Style</label>
                                <select id="level-2-style" class="large-select">
                                    <option value="A" selected>A, B, C (Alpha)</option>
                                    <option value="I">I, II, III (Roman)</option>
                                    <option value="1">1, 2, 3 (Numeric)</option>
                                    <option value="a">a, b, c (alpha)</option>
                                    <option value="i">i, ii, iii (roman)</option>
                                    <option value="none">(none)</option>
                                </select>
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label>After Number</label>
                                <input type="text" id="level-2-after" value=".">
                            </div>
                            <div class="field">
                                <label>Followed By</label>
                                <select id="level-2-follow" class="large-select">
                                    <option value="tab">Tab</option>
                                    <option value="space">Space</option>
                                    <option value="nothing">Nothing</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="level-card collapsed" id="level-3-card">
                    <div class="level-card-header" onclick="toggleLevelCard(3)">
                        <span class="level-badge">3</span>
                        <span class="level-card-title">Level 3</span>
                        <span class="level-card-sample" id="level-3-sample">1.</span>
                        <span class="level-expand">▶</span>
                    </div>
                    <div class="level-card-body" id="level-3-body" style="display:none;">
                        <!-- Same structure as above -->
                        <div class="field-row">
                            <div class="field">
                                <label>Before Number</label>
                                <input type="text" id="level-3-before">
                            </div>
                            <div class="field">
                                <label>Number Style</label>
                                <select id="level-3-style" class="large-select">
                                    <option value="1" selected>1, 2, 3 (Numeric)</option>
                                    <option value="A">A, B, C (Alpha)</option>
                                    <option value="a">a, b, c (alpha)</option>
                                    <option value="I">I, II, III (Roman)</option>
                                    <option value="i">i, ii, iii (roman)</option>
                                    <option value="none">(none)</option>
                                </select>
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label>After Number</label>
                                <input type="text" id="level-3-after" value=".">
                            </div>
                            <div class="field">
                                <label>Followed By</label>
                                <select id="level-3-follow" class="large-select">
                                    <option value="tab">Tab</option>
                                    <option value="space">Space</option>
                                    <option value="nothing">Nothing</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="level-card collapsed" id="level-4-card">
                    <div class="level-card-header" onclick="toggleLevelCard(4)">
                        <span class="level-badge">4</span>
                        <span class="level-card-title">Level 4</span>
                        <span class="level-card-sample" id="level-4-sample">(a)</span>
                        <span class="level-expand">▶</span>
                    </div>
                    <div class="level-card-body" id="level-4-body" style="display:none;">
                        <div class="field-row">
                            <div class="field">
                                <label>Before Number</label>
                                <input type="text" id="level-4-before" value="(">
                            </div>
                            <div class="field">
                                <label>Number Style</label>
                                <select id="level-4-style" class="large-select">
                                    <option value="a" selected>a, b, c (alpha)</option>
                                    <option value="1">1, 2, 3 (Numeric)</option>
                                    <option value="A">A, B, C (Alpha)</option>
                                    <option value="I">I, II, III (Roman)</option>
                                    <option value="i">i, ii, iii (roman)</option>
                                    <option value="none">(none)</option>
                                </select>
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label>After Number</label>
                                <input type="text" id="level-4-after" value=")">
                            </div>
                            <div class="field">
                                <label>Followed By</label>
                                <select id="level-4-follow" class="large-select">
                                    <option value="tab">Tab</option>
                                    <option value="space">Space</option>
                                    <option value="nothing">Nothing</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="level-card collapsed" id="level-5-card">
                    <div class="level-card-header" onclick="toggleLevelCard(5)">
                        <span class="level-badge">5</span>
                        <span class="level-card-title">Level 5</span>
                        <span class="level-card-sample" id="level-5-sample">(i)</span>
                        <span class="level-expand">▶</span>
                    </div>
                    <div class="level-card-body" id="level-5-body" style="display:none;">
                        <div class="field-row">
                            <div class="field">
                                <label>Before Number</label>
                                <input type="text" id="level-5-before" value="(">
                            </div>
                            <div class="field">
                                <label>Number Style</label>
                                <select id="level-5-style" class="large-select">
                                    <option value="i" selected>i, ii, iii (roman)</option>
                                    <option value="1">1, 2, 3 (Numeric)</option>
                                    <option value="a">a, b, c (alpha)</option>
                                    <option value="A">A, B, C (Alpha)</option>
                                    <option value="I">I, II, III (Roman)</option>
                                    <option value="none">(none)</option>
                                </select>
                            </div>
                        </div>
                        <div class="field-row">
                            <div class="field">
                                <label>After Number</label>
                                <input type="text" id="level-5-after" value=")">
                            </div>
                            <div class="field">
                                <label>Followed By</label>
                                <select id="level-5-follow" class="large-select">
                                    <option value="tab">Tab</option>
                                    <option value="space">Space</option>
                                    <option value="nothing">Nothing</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Global Options -->
                <div class="options-card">
                    <div class="options-title">Options</div>
                    <label class="option-row">
                        <input type="checkbox" id="opt-restart" checked>
                        <span>Restart numbering after higher level</span>
                    </label>
                    <label class="option-row">
                        <input type="checkbox" id="opt-legal">
                        <span>Legal style (1.1.1 format)</span>
                    </label>
                    <label class="option-row">
                        <input type="checkbox" id="opt-right-align">
                        <span>Right-align numbers</span>
                    </label>
                    <div class="field-inline">
                        <label>Start at:</label>
                        <input type="number" id="scheme-start" value="1" min="1" class="small-input">
                    </div>
                </div>
            </div>
            
            <div class="actions">
                <button class="btn secondary" onclick="hideNumberingEditor()">Cancel</button>
                <button class="btn" onclick="saveNumberingScheme()">Save Scheme</button>
            </div>
        </div>
    </div>
    <!-- LIBRARY PANEL -->
    <div class="panel" id="panel-library" role="tabpanel">
        <div class="search-box">
            <input type="text" class="search-input" id="search" placeholder="Search clauses..." oninput="debouncedFilterClauses()">
        </div>
        
        <div class="filter-tabs">
            <button class="filter-tab active" data-filter="all" onclick="setCategory('all')">All</button>
            <button class="filter-tab" data-filter="contracts" onclick="setCategory('contracts')">Contracts</button>
            <button class="filter-tab" data-filter="litigation" onclick="setCategory('litigation')">Litigation</button>
            <button class="filter-tab" data-filter="corporate" onclick="setCategory('corporate')">Corporate</button>
        </div>
        
        <div id="library-status" class="status">Loading clauses...</div>
        <div id="clauses" class="content"></div>
    </div>
    
    <!-- ADMIN PANEL -->
    <div class="panel" id="panel-admin" role="tabpanel">
        <div class="content">
            <div class="section-header">Settings</div>
            <div class="section-desc">Configure your preferences</div>
            
            <div class="option-card" onclick="showFirmSettings()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Firm Settings</div>
                    <div class="option-desc">Firm name, address, branding</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="option-card" onclick="showApiKeySettings()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">API Key</div>
                    <div class="option-desc" id="api-key-status">Configure authentication</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="option-card" onclick="comingSoon('Styles')">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Styles</div>
                    <div class="option-desc">Document styles & formatting</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="section-header" style="margin-top: 24px;">Templates</div>
            <div class="section-desc">Create and manage document templates</div>
            
            <div class="option-card" onclick="showTemplateList()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">My Templates</div>
                    <div class="option-desc">Browse and insert saved templates</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="option-card" onclick="showTemplateEditor()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Create Template</div>
                    <div class="option-desc">Build with drag & drop</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="option-card" onclick="showPrintSettings()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Print Settings</div>
                    <div class="option-desc">Default print & export options</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="section-header" style="margin-top: 24px;">Contacts</div>
            <div class="section-desc">Manage your contact database</div>
            
            <div class="option-card" onclick="showContactsPanel()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Manage Contacts</div>
                    <div class="option-desc">Add, edit, and organize saved contacts</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="section-header" style="margin-top: 24px;">Data Management</div>
            <div class="section-desc">Save and organize your clause library</div>
            
            <div class="option-card" onclick="startSaveClause()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Save Highlighted Text</div>
                    <div class="option-desc">Add selected text from your document to your library</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="section-header" style="margin-top: 24px;">E-Filing Tools</div>
            <div class="section-desc">Prepare documents for court submission</div>
            
            <div class="option-card" onclick="showOcrTool()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Make PDF Searchable (OCR)</div>
                    <div class="option-desc">Convert scanned documents to searchable text</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="section-header" style="margin-top: 24px;">Security</div>
            <div class="section-desc">Encrypt and protect sensitive documents</div>
            
            <div class="option-card" onclick="showEncryptModal()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Export Encrypted Copy</div>
                    <div class="option-desc">AES-256 military-grade encryption</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
            
            <div class="option-card" onclick="showDecryptModal()">
                <span class="option-icon"></span>
                <div class="option-text">
                    <div class="option-title">Decrypt Document</div>
                    <div class="option-desc">Open an encrypted file</div>
                </div>
                <span class="option-arrow">→</span>
            </div>
        </div>
        
        <!-- Save Clause Form (hidden by default) -->
        <div id="save-clause-form" class="content" style="display: none; padding: 16px;">
            <div class="section-header">Save to Library</div>
            <div class="section-desc">Add this clause to your collection</div>
            
            <div id="save-preview" class="clause-content" style="max-height: 100px; margin-bottom: 16px; overflow: auto; background: #f5f5f5; padding: 10px; border-radius: 8px; font-size: 12px;"></div>
            
            <div class="field">
                <label for="save-title">Title</label>
                <input type="text" id="save-title" placeholder="e.g., Standard Indemnification Clause">
            </div>
            
            <div class="field">
                <label>Category</label>
                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">
                    <button type="button" class="category-btn selected" data-cat="contracts" onclick="selectSaveCategory('contracts')">Contracts</button>
                    <button type="button" class="category-btn" data-cat="litigation" onclick="selectSaveCategory('litigation')">Litigation</button>
                    <button type="button" class="category-btn" data-cat="corporate" onclick="selectSaveCategory('corporate')">Corporate</button>
                    <button type="button" class="category-btn" data-cat="ip" onclick="selectSaveCategory('ip')">IP</button>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn secondary" onclick="cancelSaveClause()" style="flex: 1;">Cancel</button>
                <button class="btn" id="confirm-save-btn" onclick="confirmSaveClause()" style="flex: 1;">Save Clause</button>
            </div>
        </div>
        
        <!-- Template List -->
        <div class="sub-panel" id="template-list">
            <button class="back-btn" onclick="hideTemplateList()">← Back</button>
            <div class="content">
                <div class="section-header">My Templates <span id="templates-sync-status" class="sync-badge" style="display:none;"></span></div>
                <div class="section-desc">Select a template to insert</div>
                
                <div id="templates-container">
                    <div class="template-loading">Loading templates...</div>
                </div>
                
                <div class="empty-state" id="no-templates" style="display: none;">
                    <div class="empty-icon"></div>
                    <div class="empty-title">No templates yet</div>
                    <div class="empty-desc">Create your first template to get started</div>
                    <button class="btn" onclick="showTemplateEditor()">Create Template</button>
                </div>
            </div>
        </div>
        
        <!-- Template Editor -->
        <div class="sub-panel" id="template-editor">
            <button class="back-btn" onclick="hideTemplateEditor()">← Back</button>
            <div class="content">
                <div class="section-header">Template Editor</div>
                
                <div class="field">
                    <label>Template Name</label>
                    <input type="text" id="template-name" placeholder="e.g., Federal Court Letter">
                </div>
                
                <div class="template-editor-layout">
                    <!-- Block Palette -->
                    <div class="block-palette">
                        <div class="palette-header">Sections <span style="font-weight:normal;font-size:10px;color:#888;">(click Add or drag)</span></div>
                        <div class="palette-item" draggable="true" data-block-type="text">
                            <span class="palette-icon">T</span>
                            <span>Text Section</span>
                            <button class="add-block-btn" onclick="addBlock('text')" title="Add text section to template">+ Add</button>
                        </div>
                        <div class="palette-item" draggable="true" data-block-type="variable">
                            <span class="palette-icon">V</span>
                            <span>Fill-in Field</span>
                            <button class="add-block-btn" onclick="addBlock('variable')" title="Add fill-in field to template">+ Add</button>
                        </div>
                        <div class="palette-item" draggable="true" data-block-type="separator">
                            <span class="palette-icon">—</span>
                            <span>Separator Line</span>
                            <button class="add-block-btn" onclick="addBlock('separator')" title="Add separator line to template">+ Add</button>
                        </div>
                        <div class="palette-item" draggable="true" data-block-type="table">
                            <span class="palette-icon">#</span>
                            <span>Table</span>
                            <button class="add-block-btn" onclick="addBlock('table')" title="Add table to template">+ Add</button>
                        </div>
                        <div class="palette-item" draggable="true" data-block-type="conditional" style="background: #fdf8f3; border-color: #8B7355;">
                            <span class="palette-icon">?</span>
                            <span>Conditional</span>
                            <button class="add-block-btn" onclick="addBlock('conditional')" title="Add conditional block - show/hide content based on variable values">+ Add</button>
                        </div>
                        
                        <div class="palette-header" style="margin-top: 12px;">Variables <span style="font-weight:normal;font-size:10px;color:#888;">(click to insert)</span></div>
                        <div class="variable-chips">
                            <span class="var-chip" data-var="date" title="Click to insert at cursor">date</span>
                            <span class="var-chip" data-var="firm.name" title="Click to insert at cursor">firm.name</span>
                            <span class="var-chip" data-var="attorney.name" title="Click to insert at cursor">attorney.name</span>
                            <span class="var-chip" data-var="client.name" title="Click to insert at cursor">client.name</span>
                            <span class="var-chip" data-var="client.address" title="Click to insert at cursor">client.address</span>
                            <span class="var-chip" data-var="matter.name" title="Click to insert at cursor">matter.name</span>
                            <span class="var-chip" data-var="matter.caseNumber" title="Click to insert at cursor">case #</span>
                        </div>
                    </div>
                    
                    <!-- Template Area -->
                    <div class="template-canvas" id="template-canvas">
                        <div class="canvas-placeholder">
                            Click "+ Add" or drag sections here to build your template
                        </div>
                    </div>
                </div>
                
                <!-- Preview Toggle -->
                <div class="preview-toggle">
                    <button class="btn small secondary" id="preview-toggle-btn" onclick="toggleTemplatePreview()">Hide Preview</button>
                </div>
                
                <!-- Preview Area (hidden by default) -->
                <div class="template-preview" id="template-preview">
                    <div class="preview-header">
                        <span>Preview</span>
                        <select id="preview-court-type" onchange="updateTemplatePreview()">
                            <option value="federal">Federal Court</option>
                            <option value="state">State Court</option>
                            <option value="bankruptcy">Bankruptcy</option>
                        </select>
                    </div>
                    <div class="preview-content" id="preview-content">
                        <!-- Rendered preview goes here -->
                    </div>
                </div>
            </div>
            <div class="actions">
                <span id="template-save-status" class="save-status"></span>
                <button class="btn secondary" onclick="hideTemplateEditor()">Cancel</button>
                <button class="btn" onclick="saveTemplate()">Save Template</button>
            </div>
        </div>
        
        <!-- Contacts Manager Sub-Panel -->
        <div class="sub-panel" id="contacts-panel">
            <button class="back-btn" onclick="hideContactsPanel()">← Back</button>
            <div class="content" id="contacts-panel-content">
                <div class="section-header">Contacts</div>
                <div class="section-desc">Manage your saved contacts</div>
                <!-- SmartVariables will render here -->
            </div>
        </div>
    </div>
    </main>

    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <script>
        const API = 'https://6b2bpmn8f8.execute-api.us-east-1.amazonaws.com/prod';
        // TODO: Load from authenticated API endpoint in production
        const FIRM = 'morrison';
        
        // Configuration loaded from API at startup
        let appConfig = {
            apiVersion: '1.0.0',
            features: { templates: true, aiAssist: false, voiceControl: true },
            limits: { maxTemplatesPerFirm: 100, maxBlocksPerTemplate: 100 }
        };
        
        // API Key configuration - loaded from localStorage
        // In production, this could be managed via API Gateway API keys or JWT tokens
        let API_KEY = localStorage.getItem('draftbridge_api_key') || '';
        
        // Load configuration from API
        async function loadAppConfig() {
            try {
                const response = await fetch(`${API}/config`, { headers: apiHeaders() });
                if (response.ok) {
                    appConfig = await response.json();
                } else if (response.status === 401 || response.status === 403) {
                    console.warn('API Key invalid or missing - auth required');
                    handleAuthError();
                }
            } catch (err) {
                console.warn('Could not load config from API, using defaults:', err);
            }
        }
        
        // Handle authentication errors (401/403)
        function handleAuthError() {
            // Clear invalid key
            API_KEY = '';
            localStorage.removeItem('draftbridge_api_key');
            toast('API Key required. Go to Settings → API Key to configure.', 'warning', 5000);
        }
        
        // Wrapper for API calls with auth error handling
        async function apiCall(url, options = {}) {
            const response = await fetch(url, {
                ...options,
                headers: { ...apiHeaders(), ...options.headers }
            });
            
            if (response.status === 401 || response.status === 403) {
                handleAuthError();
                throw new Error('Authentication failed. Please configure your API key in Settings.');
            }
            
            return response;
        }
        
        // Helper to create headers with API key
        function apiHeaders(contentType = 'application/json') {
            const headers = { 'Content-Type': contentType };
            if (API_KEY) headers['X-API-Key'] = API_KEY;
            return headers;
        }
        
        // TODO: Load from authenticated API endpoint in production
        // Authors list - will come from firm settings after auth
        // Each author can have optional title for signature blocks
        const AUTHORS = [
            { name: 'Nick Bridges', title: 'Managing Partner', default: true },
            { name: 'Sarah Chen', title: 'Partner' },
            { name: 'Michael Torres', title: 'Associate' },
            { name: 'Jennifer Williams', title: 'Of Counsel' },
            { name: 'David Park', title: 'Associate' }
        ];
        
        let allClauses = [];
        let currentCategory = 'all';

        Office.onReady(async (info) => {
            // Initialize API key status display
            initApiKeyStatus();
            
            // Load app configuration from API
            await loadAppConfig();
            
            // Set today's date on date inputs
            const today = new Date().toISOString().split('T')[0];
            document.querySelectorAll('input[type="date"]').forEach(input => {
                input.value = today;
            });
            
            // Populate author dropdowns
            populateAuthorDropdowns();
            
            // Load user's saved numbering schemes
            loadUserSchemes();
            
            // Load clauses
            loadClauses();
            
            // Initialize numbering preview
            updateNumberingPreview('legal-outline');
            
            // Initialize location indicator (paragraph tracking)
            initLocationIndicator();
            
            // Show onboarding for first-time users
            checkFirstRun();
        });
        
        // First-run onboarding
        function checkFirstRun() {
            const hasSeenOnboarding = localStorage.getItem('draftbridge_onboarding_complete');
            if (!hasSeenOnboarding) {
                document.getElementById('onboarding-modal').classList.remove('hidden');
            }
        }
        
        function completeOnboarding() {
            localStorage.setItem('draftbridge_onboarding_complete', 'true');
            document.getElementById('onboarding-modal').classList.add('hidden');
            toast('Welcome! Explore the tabs above to get started.', 'success', 4000);
        }
        
        function resetOnboarding() {
            // Utility to reset onboarding (for testing)
            localStorage.removeItem('draftbridge_onboarding_complete');
            location.reload();
        }
        
        // Coming soon handler - honest about feature status
        function comingSoon(featureName) {
            toast(`${featureName} is not yet available. We're working on it!`, 'info', 4000);
        }
        
        // ========== FIRM SETTINGS ==========

        function showFirmSettings() {
            const profile = JSON.parse(localStorage.getItem('draftbridge_user_profile') || '{}');
            const html = `
                <div class="section-header">Firm Information</div>
                <div class="section-desc">This information auto-fills firm fields in all templates</div>

                <div class="field">
                    <label>Firm Name</label>
                    <input type="text" id="firm-name" class="input" value="${escapeHtmlAttr(profile.firmName || '')}" placeholder="Smith & Associates LLP">
                </div>

                <div class="field">
                    <label>Street Address</label>
                    <input type="text" id="firm-street" class="input" value="${escapeHtmlAttr(profile.firmStreet || '')}" placeholder="123 Main Street, Suite 400">
                </div>

                <div style="display: flex; gap: 10px;">
                    <div class="field" style="flex: 2;">
                        <label>City</label>
                        <input type="text" id="firm-city" class="input" value="${escapeHtmlAttr(profile.firmCity || '')}">
                    </div>
                    <div class="field" style="flex: 1;">
                        <label>State</label>
                        <input type="text" id="firm-state" class="input" maxlength="2" value="${escapeHtmlAttr(profile.firmState || '')}" placeholder="CA">
                    </div>
                    <div class="field" style="flex: 1;">
                        <label>ZIP</label>
                        <input type="text" id="firm-zip" class="input" maxlength="10" value="${escapeHtmlAttr(profile.firmZip || '')}" placeholder="02101">
                    </div>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn secondary" onclick="closeModal()" style="flex: 1;">Cancel</button>
                    <button class="btn" onclick="saveFirmSettings()" style="flex: 1;">Save Settings</button>
                </div>
            `;
            showModal('Firm Settings', html);
        }

        function saveFirmSettings() {
            const profile = JSON.parse(localStorage.getItem('draftbridge_user_profile') || '{}');
            profile.firmName = document.getElementById('firm-name').value.trim();
            profile.firmStreet = document.getElementById('firm-street').value.trim();
            profile.firmCity = document.getElementById('firm-city').value.trim();
            profile.firmState = document.getElementById('firm-state').value.trim().toUpperCase();
            profile.firmZip = document.getElementById('firm-zip').value.trim();
            localStorage.setItem('draftbridge_user_profile', JSON.stringify(profile));

            // Sync with SmartVariables if loaded
            if (typeof SmartVariables !== 'undefined') {
                SmartVariables.userProfile = profile;
            }

            closeModal();
            toast('Firm settings saved!', 'success');
        }

        function escapeHtmlAttr(str) {
            return String(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        // ========== API KEY MANAGEMENT ==========
        
        function showApiKeySettings() {
            const modal = document.getElementById('apikey-modal');
            const input = document.getElementById('apikey-input');
            const statusEl = document.getElementById('apikey-status');
            
            // Pre-fill with masked version if key exists
            if (API_KEY) {
                input.value = API_KEY;
                input.type = 'password';
            } else {
                input.value = '';
            }
            
            // Reset status
            statusEl.style.display = 'none';
            
            modal.classList.remove('hidden');
            input.focus();
        }
        
        function hideApiKeyModal() {
            document.getElementById('apikey-modal').classList.add('hidden');
        }
        
        async function validateAndSaveApiKey() {
            const input = document.getElementById('apikey-input');
            const statusEl = document.getElementById('apikey-status');
            const saveBtn = document.getElementById('apikey-save-btn');
            const saveBtnText = document.getElementById('apikey-save-text');
            
            const key = input.value.trim();
            
            if (!key) {
                statusEl.style.display = 'block';
                statusEl.style.background = '#ffebee';
                statusEl.style.border = '1px solid #f44336';
                statusEl.innerHTML = '<span style="color: #c62828;">Please enter an API key</span>';
                return;
            }
            
            // Show loading state
            saveBtn.disabled = true;
            saveBtnText.textContent = 'Validating...';
            statusEl.style.display = 'block';
            statusEl.style.background = '#e3f2fd';
            statusEl.style.border = '1px solid #2196f3';
            statusEl.innerHTML = '<span style="color: #1565c0;">Validating key...</span>';
            
            try {
                // Test the key by calling /config
                const response = await fetch(`${API}/config`, {
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': key
                    }
                });
                
                if (response.ok) {
                    // Key is valid - save it
                    API_KEY = key;
                    localStorage.setItem('draftbridge_api_key', key);
                    
                    // Update config with response
                    const config = await response.json();
                    appConfig = config;
                    
                    // Update status display in Settings
                    updateApiKeyStatus(true);
                    
                    statusEl.style.background = '#e8f5e9';
                    statusEl.style.border = '1px solid #4caf50';
                    statusEl.innerHTML = '<span style="color: #2e7d32;">API key validated and saved!</span>';
                    
                    toast('API key saved successfully!', 'success');
                    
                    // Close modal after short delay
                    setTimeout(() => {
                        hideApiKeyModal();
                        // Reload clauses with new auth
                        loadClauses();
                    }, 1500);
                    
                } else if (response.status === 401 || response.status === 403) {
                    statusEl.style.background = '#ffebee';
                    statusEl.style.border = '1px solid #f44336';
                    statusEl.innerHTML = '<span style="color: #c62828;">Invalid API key. Please check and try again.</span>';
                } else {
                    throw new Error(`Server error: ${response.status}`);
                }
                
            } catch (err) {
                console.error('API key validation failed:', err);
                statusEl.style.background = '#fff3e0';
                statusEl.style.border = '1px solid #ff9800';
                statusEl.innerHTML = `<span style="color: #e65100;">Could not validate: ${escapeHtml(err.message)}</span>`;
            } finally {
                saveBtn.disabled = false;
                saveBtnText.textContent = 'Validate & Save';
            }
        }
        
        function clearApiKey() {
            API_KEY = '';
            localStorage.removeItem('draftbridge_api_key');
            updateApiKeyStatus(false);
            toast('API key cleared', 'info');
        }
        
        function updateApiKeyStatus(isValid) {
            const statusEl = document.getElementById('api-key-status');
            if (statusEl) {
                if (isValid && API_KEY) {
                    statusEl.textContent = 'Connected';
                    statusEl.style.color = '#2e7d32';
                } else {
                    statusEl.textContent = 'Configure authentication';
                    statusEl.style.color = '';
                }
            }
        }
        
        // Update API key status on page load
        function initApiKeyStatus() {
            updateApiKeyStatus(!!API_KEY);
        }
        
        // Toast notification system with stacking, progress bar, and type-specific behavior
        const _toastStack = [];
        const MAX_TOASTS = 3;

        function toast(message, type = 'info', duration = 3000) {
            // Enforce max visible toasts — remove oldest
            while (_toastStack.length >= MAX_TOASTS) {
                const oldest = _toastStack.shift();
                if (oldest && oldest.parentElement) {
                    oldest.classList.remove('show');
                    setTimeout(() => oldest.remove(), 300);
                }
            }

            const toastEl = document.createElement('div');
            toastEl.className = `toast-notification toast-${type}`;

            const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            toastEl.innerHTML = `
                <div class="toast-body">
                    <span class="toast-message">${escapeHtml(message)}</span>
                    <span class="toast-time">${time}</span>
                    <button class="toast-dismiss" onclick="SmartVariables._dismissToast(this.closest('.toast-notification'))" title="Dismiss" aria-label="Dismiss notification">&times;</button>
                </div>
                ${type !== 'error' ? '<div class="toast-progress"><div class="toast-progress-bar"></div></div>' : ''}
            `;

            document.body.appendChild(toastEl);
            _toastStack.push(toastEl);

            // Reposition stack
            _toastStack.forEach((t, i) => {
                t.style.bottom = `${20 + i * 56}px`;
            });

            // Animate in
            setTimeout(() => toastEl.classList.add('show'), 10);

            // Errors require manual dismiss
            if (type === 'error') return;

            // Animate progress bar countdown
            const actualDuration = type === 'success' ? Math.max(duration, 4000) : duration;
            const progressBar = toastEl.querySelector('.toast-progress-bar');
            if (progressBar) {
                progressBar.style.transition = `width ${actualDuration}ms linear`;
                requestAnimationFrame(() => { progressBar.style.width = '0%'; });
            }

            setTimeout(() => {
                SmartVariables._dismissToast(toastEl);
            }, actualDuration);
        }
        
        // Button lock utility - prevents double-clicks during async operations
        async function withButtonLock(buttonOrId, asyncFn, loadingText = null) {
            const btn = typeof buttonOrId === 'string' 
                ? document.getElementById(buttonOrId) 
                : buttonOrId;
            
            if (!btn || btn.disabled) return;
            
            const originalText = btn.textContent;
            const originalDisabled = btn.disabled;
            
            try {
                btn.disabled = true;
                btn.style.opacity = '0.7';
                btn.style.cursor = 'wait';
                if (loadingText) btn.textContent = loadingText;
                
                return await asyncFn();
            } finally {
                btn.disabled = originalDisabled;
                btn.style.opacity = '';
                btn.style.cursor = '';
                btn.textContent = originalText;
            }
        }
        
        // Better error messages for common issues
        function friendlyError(err, context = '') {
            const msg = err.message || String(err);
            
            // Network errors
            if (msg.includes('fetch') || msg.includes('network') || msg.includes('Failed to fetch')) {
                return 'Network error. Check your internet connection and try again.';
            }
            
            // Word API errors
            if (msg.includes('GeneralException') || msg.includes('ItemNotFound')) {
                return 'Word couldn\'t complete this action. Try selecting different text or restarting the add-in.';
            }
            
            // Permission errors
            if (msg.includes('Access') || msg.includes('permission') || msg.includes('401')) {
                return 'Permission denied. You may need to sign in again.';
            }
            
            // Crypto errors
            if (msg.includes('decrypt') || msg.includes('crypto')) {
                return 'Decryption failed. Check your password and try again.';
            }
            
            // Empty/validation errors
            if (msg.includes('empty') || msg.includes('required') || msg.includes('select')) {
                return msg; // These are usually already friendly
            }
            
            // Add context if provided
            if (context) {
                return `${context}: ${msg}`;
            }
            
            return msg;
        }
        
        // Populate all author/signer dropdowns with firm authors
        function populateAuthorDropdowns() {
            const authorSelects = document.querySelectorAll('.author-select');
            const defaultAuthor = AUTHORS.find(a => a.default) || AUTHORS[0];
            
            authorSelects.forEach(select => {
                select.innerHTML = '';
                AUTHORS.forEach(author => {
                    const option = document.createElement('option');
                    option.value = author.name;
                    option.textContent = author.name;
                    option.dataset.title = author.title || '';
                    if (author.default) option.selected = true;
                    select.appendChild(option);
                });
            });
        }
        
        // Get selected author's title (for signature blocks)
        function getSelectedAuthorTitle(selectId) {
            const select = document.getElementById(selectId);
            if (!select) return '';
            const selected = select.options[select.selectedIndex];
            return selected?.dataset?.title || '';
        }
        
        // Handle title option toggle for letter form
        document.addEventListener('DOMContentLoaded', () => {
            const titleOption = document.getElementById('letter-title-option');
            const titleCustom = document.getElementById('letter-title-custom');
            if (titleOption && titleCustom) {
                titleOption.addEventListener('change', () => {
                    titleCustom.style.display = titleOption.value === 'custom' ? 'block' : 'none';
                });
            }
        });

        // Panel Navigation
        function switchPanel(panelId) {
            document.querySelectorAll('.main-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.toLowerCase() === panelId.toLowerCase()) {
                    tab.classList.add('active');
                }
            });
            document.querySelectorAll('.panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === 'panel-' + panelId);
            });
            
            // Auto-scan health when entering Numbering panel
            if (panelId === 'numbering') {
                // Small delay to ensure panel is visible
                setTimeout(() => {
                    triggerHealthScan();
                }, 100);
            } else {
                // Stop list controls polling when leaving Numbering panel
                if (typeof stopListControlsPolling === 'function') {
                    stopListControlsPolling();
                }
            }
        }

        // Tab Slider Navigation
        let currentTabOffset = 0;
        const TAB_SLIDE_AMOUNT = 100; // pixels to slide
        
        function slideTab(direction) {
            const container = document.getElementById('main-tabs');
            const maxScroll = container.scrollWidth - container.clientWidth;
            
            currentTabOffset += direction * TAB_SLIDE_AMOUNT;
            currentTabOffset = Math.max(0, Math.min(currentTabOffset, maxScroll));
            
            container.style.transform = `translateX(-${currentTabOffset}px)`;
            
            // Update arrow states
            document.getElementById('tab-prev').disabled = currentTabOffset <= 0;
            document.getElementById('tab-next').disabled = currentTabOffset >= maxScroll;
        }
        
        // Sub-nav Slider Navigation (Numbering panel)
        let currentSubNavOffset = 0;
        const SUBNAV_SLIDE_AMOUNT = 80;
        
        function slideSubNav(direction) {
            const container = document.getElementById('sub-nav-strip');
            if (!container) return;
            
            const maxScroll = container.scrollWidth - container.clientWidth;
            
            currentSubNavOffset += direction * SUBNAV_SLIDE_AMOUNT;
            currentSubNavOffset = Math.max(0, Math.min(currentSubNavOffset, maxScroll));
            
            container.style.transform = `translateX(-${currentSubNavOffset}px)`;
            container.style.transition = 'transform 0.2s ease-out';
            
            // Update arrow states
            const prevBtn = document.getElementById('subnav-prev');
            const nextBtn = document.getElementById('subnav-next');
            if (prevBtn) prevBtn.disabled = currentSubNavOffset <= 0;
            if (nextBtn) nextBtn.disabled = currentSubNavOffset >= maxScroll;
        }
        
        // Generic modal helpers (used by Print Settings, PDF/A export, etc.)
        function showModal(title, bodyHtml) {
            // Remove any existing generic modal
            const existing = document.getElementById('generic-modal');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'generic-modal';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px; background: var(--db-surface); border-radius: var(--db-radius-lg); padding: 0; box-shadow: var(--db-shadow-modal);">
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 14px 16px; border-bottom: 1px solid var(--db-border);">
                        <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: var(--db-text);">${title}</h3>
                        <button onclick="closeModal()" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--db-text-muted); padding: 4px 8px;" title="Close">&times;</button>
                    </div>
                    <div style="padding: 16px; max-height: 70vh; overflow-y: auto;">
                        ${bodyHtml}
                    </div>
                </div>
            `;
            modal.addEventListener('click', function(e) {
                if (e.target === modal) closeModal();
            });
            document.body.appendChild(modal);

            modal._escHandler = function(e) {
                if (e.key === 'Escape') closeModal();
            };
            document.addEventListener('keydown', modal._escHandler);
        }

        function closeModal() {
            const modal = document.getElementById('generic-modal');
            if (modal) {
                if (modal._escHandler) {
                    document.removeEventListener('keydown', modal._escHandler);
                }
                modal.remove();
            }
        }

        // Print Settings
        function showPrintSettings() {
            const html = `
                <div class="section-header">Print Settings</div>
                <div class="section-desc">Configure default print and export options</div>
                
                <div class="field">
                    <label>Default Paper Size</label>
                    <select id="print-paper-size" class="select">
                        <option value="letter" selected>Letter (8.5" × 11")</option>
                        <option value="legal">Legal (8.5" × 14")</option>
                        <option value="a4">A4 (210mm × 297mm)</option>
                    </select>
                </div>
                
                <div class="field">
                    <label>Default Margins</label>
                    <select id="print-margins" class="select">
                        <option value="normal" selected>Normal (1" all sides)</option>
                        <option value="narrow">Narrow (0.5" all sides)</option>
                        <option value="wide">Wide (1.5" all sides)</option>
                        <option value="legal">Legal Pleading (1.5" left, 1" right)</option>
                    </select>
                </div>
                
                <div class="field">
                    <label>Default Font</label>
                    <select id="print-font" class="select">
                        <option value="times" selected>Times New Roman</option>
                        <option value="courier">Courier New</option>
                        <option value="arial">Arial</option>
                        <option value="garamond">Garamond</option>
                    </select>
                </div>
                
                <div class="field">
                    <label>Font Size</label>
                    <select id="print-font-size" class="select">
                        <option value="10">10 pt</option>
                        <option value="11">11 pt</option>
                        <option value="12" selected>12 pt</option>
                        <option value="14">14 pt</option>
                    </select>
                </div>
                
                <div class="field">
                    <label>Line Spacing</label>
                    <select id="print-line-spacing" class="select">
                        <option value="single">Single</option>
                        <option value="1.5">1.5 lines</option>
                        <option value="double" selected>Double</option>
                    </select>
                </div>
                
                <div style="border-top: 1px solid #e0e0e0; margin: 20px 0; padding-top: 16px;">
                    <div class="section-header" style="font-size: 14px;">E-Filing Export</div>
                    <div class="section-desc" style="margin-bottom: 12px;">PDF/A format for court e-filing</div>
                    
                    <div class="field">
                        <label>PDF/A Version</label>
                        <select id="print-pdfa-version" class="select">
                            <option value="none">Standard PDF (no PDF/A)</option>
                            <option value="1b" selected>PDF/A-1b (Basic compliance)</option>
                            <option value="1a">PDF/A-1a (Full compliance)</option>
                            <option value="2b">PDF/A-2b (Newer standard)</option>
                        </select>
                    </div>
                    
                    <div class="field">
                        <label>Court Profile</label>
                        <select id="print-court-profile" class="select">
                            <option value="federal">Federal (CM/ECF) - 50MB limit</option>
                            <option value="massachusetts">Massachusetts - 25MB, searchable PDF</option>
                            <option value="rhodeisland">Rhode Island (Odyssey) - searchable PDF</option>
                            <option value="california">California - 25MB, PDF/A</option>
                            <option value="newyork">New York (NYSCEF) - 200 DPI, PDF/A</option>
                            <option value="texas">Texas - Varies by county</option>
                            <option value="florida">Florida - 50MB limit</option>
                            <option value="custom">Custom settings</option>
                        </select>
                    </div>
                    
                    <button class="btn" onclick="exportPdfA()" style="width: 100%; margin-top: 12px;">
                        Export PDF/A for E-Filing
                    </button>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn secondary" onclick="closePrintSettings()" style="flex: 1;">Cancel</button>
                    <button class="btn" onclick="savePrintSettings()" style="flex: 1;">Save Settings</button>
                </div>
            `;
            
            showModal('Print Settings', html);
        }
        
        function savePrintSettings() {
            const settings = {
                paperSize: document.getElementById('print-paper-size').value,
                margins: document.getElementById('print-margins').value,
                font: document.getElementById('print-font').value,
                fontSize: document.getElementById('print-font-size').value,
                lineSpacing: document.getElementById('print-line-spacing').value,
                pdfaVersion: document.getElementById('print-pdfa-version')?.value || '1b',
                courtProfile: document.getElementById('print-court-profile')?.value || 'federal'
            };
            localStorage.setItem('draftbridge-print-settings', JSON.stringify(settings));
            closeModal();
            toast('Print settings saved!', 'success');
        }
        
        // Export to PDF/A for e-filing
        async function exportPdfA() {
            const pdfaVersion = document.getElementById('print-pdfa-version')?.value || '1b';
            const courtProfile = document.getElementById('print-court-profile')?.value || 'federal';
            
            // Court-specific limits and requirements
            const courtLimits = {
                'federal': { maxMb: 50, name: 'Federal CM/ECF', searchable: true, pdfa: false },
                'massachusetts': { maxMb: 25, name: 'Massachusetts', searchable: true, pdfa: false, notes: 'OCR required for scans. No passwords. Follow MA Court Rules formatting.' },
                'rhodeisland': { maxMb: 35, name: 'Rhode Island (Odyssey)', searchable: true, pdfa: false, notes: 'Tyler Technologies system. 30-day retention in File and Serve.' },
                'california': { maxMb: 25, name: 'California', searchable: true, pdfa: true },
                'newyork': { maxMb: 100, name: 'New York NYSCEF', searchable: true, pdfa: true, notes: '200 DPI min for scans. Flattened. No passwords.' },
                'texas': { maxMb: 50, name: 'Texas', searchable: true, pdfa: false, notes: 'Requirements vary by county.' },
                'florida': { maxMb: 50, name: 'Florida', searchable: true, pdfa: false },
                'custom': { maxMb: 100, name: 'Custom', searchable: false, pdfa: false }
            };
            
            const court = courtLimits[courtProfile] || courtLimits['federal'];
            
            toast(`Preparing PDF/A-${pdfaVersion} for ${court.name}...`, 'info');
            
            try {
                await Word.run(async (context) => {
                    // Get document properties
                    const docProps = context.document.properties;
                    docProps.load('title');
                    await context.sync();
                    
                    // Note: Word JavaScript API doesn't directly support PDF/A export
                    // This would need to be handled server-side or via a conversion service
                    // For now, we provide guidance
                    
                    closeModal();
                    
                    // Build requirements list based on court profile
                    let requirements = [];
                    if (court.searchable) requirements.push('Text must be searchable (use native PDF, not scanned images)');
                    if (court.pdfa) requirements.push('PDF/A format required (ISO 19005-1 compliant)');
                    requirements.push(`Max file size: ${court.maxMb}MB`);
                    if (court.notes) requirements.push(`${court.notes}`);
                    
                    const requirementsList = requirements.map(r => `<li style="margin-bottom: 6px;">${r}</li>`).join('');
                    
                    const instructions = `
                        <div style="padding: 16px;">
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 12px;">Export for ${court.name}</div>
                            
                            <div style="background: #fff3e0; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                                <strong style="color: #e65100;">Court Requirements:</strong>
                                <ul style="margin: 8px 0 0 16px; color: #333; font-size: 13px; line-height: 1.8;">
                                    ${requirementsList}
                                </ul>
                            </div>
                            
                            <p style="color: #666; margin-bottom: 12px; font-weight: 500;">Export Steps:</p>
                            <ol style="line-height: 2; color: #333; margin-left: 20px; font-size: 13px;">
                                <li>Go to <strong>File → Save As</strong></li>
                                <li>Choose <strong>PDF</strong> as file type</li>
                                <li>Click <strong>Options...</strong></li>
                                ${court.pdfa ? '<li>Check <strong>"ISO 19005-1 compliant (PDF/A)"</strong></li>' : ''}
                                <li>Ensure <strong>"Document structure tags"</strong> is checked (for searchability)</li>
                                <li>Click OK, then Save</li>
                            </ol>
                            
                            <div style="background: #e8f5e9; padding: 12px; border-radius: 8px; margin-top: 16px;">
                                <strong>Ready for: ${court.name}</strong>
                            </div>
                        </div>
                    `;
                    
                    showModal('Export for E-Filing', instructions);
                });
            } catch (err) {
                console.error('PDF/A export error:', err);
                toast('Export failed: ' + err.message, 'error');
            }
        }
        
        function closePrintSettings() {
            closeModal();
        }

        // Template Forms
        function showTemplate(type) {
            document.getElementById('generate-main').classList.remove('active');
            document.getElementById('generate-' + type).classList.add('active');
        }
        
        function hideTemplate() {
            document.querySelectorAll('#panel-generate .sub-panel').forEach(p => p.classList.remove('active'));
            document.getElementById('generate-main').classList.add('active');
        }
        
        // ========== FILL VARIABLES (Enhanced Modal UI) ==========
        
        let fillVarsData = {
            variables: [],      // Array of { name, count, type }
            bookmarks: [],      // Array of bookmark names
            documentText: '',   // Full document text for preview
            values: {},         // Current values: { varName: value }
            previewMode: 'before' // 'before' or 'after'
        };
        
        // LocalStorage key for remembered values
        const FILL_VARS_STORAGE_KEY = 'draftbridge_fill_vars_memory';
        
        // Load remembered values from localStorage
        function loadRememberedValues() {
            try {
                return JSON.parse(localStorage.getItem(FILL_VARS_STORAGE_KEY) || '{}');
            } catch (e) {
                return {};
            }
        }
        
        // Save values to localStorage
        function saveRememberedValues(values) {
            try {
                const existing = loadRememberedValues();
                const merged = { ...existing, ...values };
                // Keep only last 100 variables to prevent bloat
                const keys = Object.keys(merged);
                if (keys.length > 100) {
                    const toRemove = keys.slice(0, keys.length - 100);
                    toRemove.forEach(k => delete merged[k]);
                }
                localStorage.setItem(FILL_VARS_STORAGE_KEY, JSON.stringify(merged));
            } catch (e) {
                // Silently fail on storage errors
            }
        }
        
        // Determine input type based on variable name
        function inferVariableType(varName) {
            const name = varName.toLowerCase();
            if (name.includes('date') || name.includes('_dt') || name.endsWith('_on')) {
                return { type: 'date', icon: '' };
            }
            if (name.includes('email') || name.includes('e_mail')) {
                return { type: 'email', icon: '' };
            }
            if (name.includes('phone') || name.includes('tel') || name.includes('fax')) {
                return { type: 'tel', icon: '' };
            }
            if (name.includes('amount') || name.includes('price') || name.includes('cost') || name.includes('fee') || name.includes('salary')) {
                return { type: 'money', icon: '' };
            }
            if (name.includes('percent') || name.includes('rate') || name.includes('_pct')) {
                return { type: 'percent', icon: '' };
            }
            if (name.includes('address') || name.includes('street') || name.includes('city') || name.includes('state') || name.includes('zip')) {
                return { type: 'address', icon: '' };
            }
            if (name.includes('name') || name.includes('party') || name.includes('client') || name.includes('attorney')) {
                return { type: 'name', icon: '' };
            }
            if (name.includes('company') || name.includes('corp') || name.includes('llc') || name.includes('firm')) {
                return { type: 'company', icon: '' };
            }
            if (name.includes('number') || name.includes('_no') || name.includes('_num') || name.includes('count')) {
                return { type: 'number', icon: '' };
            }
            return { type: 'text', icon: '' };
        }
        
        // Show the Fill Variables modal
        async function showFillVariables() {
            const modal = document.getElementById('fill-vars-modal');
            const scanningState = document.getElementById('fill-vars-scanning-state');
            const emptyState = document.getElementById('fill-vars-empty-state');
            const contentState = document.getElementById('fill-vars-content');
            const footer = document.getElementById('fill-vars-footer');
            
            // Reset state
            fillVarsData = {
                variables: [],
                bookmarks: [],
                documentText: '',
                values: {},
                previewMode: 'before'
            };
            
            // Show modal with scanning state
            modal.classList.remove('hidden');
            scanningState.classList.remove('hidden');
            emptyState.classList.add('hidden');
            contentState.classList.add('hidden');
            footer.style.display = 'none';
            
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    body.load('text');
                    await context.sync();
                    
                    fillVarsData.documentText = body.text;
                    
                    // Find all {{variable}} patterns with counts
                    const varPattern = /\{\{([^}]+)\}\}/g;
                    let match;
                    const varCounts = {};
                    
                    while ((match = varPattern.exec(fillVarsData.documentText)) !== null) {
                        const varName = match[1].trim();
                        varCounts[varName] = (varCounts[varName] || 0) + 1;
                    }
                    
                    // Convert to array with type info
                    fillVarsData.variables = Object.keys(varCounts).map(name => ({
                        name,
                        count: varCounts[name],
                        ...inferVariableType(name)
                    }));
                    
                    // Try to find bookmarks
                    try {
                        const bookmarks = context.document.body.getRange().getBookmarks();
                        await context.sync();
                        if (bookmarks && bookmarks.items) {
                            fillVarsData.bookmarks = bookmarks.items.map(b => b.name);
                        }
                    } catch (e) {
                        // Bookmarks not available in this document
                    }
                });
                
                // Hide scanning state
                scanningState.classList.add('hidden');
                
                const totalCount = fillVarsData.variables.length + fillVarsData.bookmarks.length;
                document.getElementById('fill-vars-badge').textContent = `${totalCount} found`;
                
                if (totalCount === 0) {
                    // Show empty state
                    emptyState.classList.remove('hidden');
                } else {
                    // Show content
                    contentState.classList.remove('hidden');
                    footer.style.display = 'flex';
                    
                    // Load remembered values
                    const remembered = loadRememberedValues();
                    fillVarsData.variables.forEach(v => {
                        if (remembered[v.name]) {
                            fillVarsData.values[v.name] = remembered[v.name];
                        }
                    });
                    fillVarsData.bookmarks.forEach(bm => {
                        if (remembered['bm_' + bm]) {
                            fillVarsData.values['bm_' + bm] = remembered['bm_' + bm];
                        }
                    });
                    
                    renderFillVarsForm();
                    renderFillVarsPreview();
                    updateFillVarsStats();
                }
                
            } catch (err) {
                console.error('Scan failed:', err);
                toast(friendlyError(err, 'Could not scan document'), 'error');
                closeFillVarsModal();
            }
        }
        
        // Close the modal
        function closeFillVarsModal() {
            document.getElementById('fill-vars-modal').classList.add('hidden');
        }
        
        // Backward compatibility - keep old function name
        function hideFillVariables() {
            closeFillVarsModal();
        }
        
        // Render the variables form
        function renderFillVarsForm() {
            const container = document.getElementById('fill-vars-form');
            let html = '';
            
            if (fillVarsData.variables.length > 0) {
                html += '<div class="fill-vars-group">';
                html += '<div class="fill-vars-group-label">Variables</div>';
                
                fillVarsData.variables.forEach(v => {
                    const displayName = v.name.replace(/_/g, ' ').replace(/\./g, ' › ');
                    const currentValue = fillVarsData.values[v.name] || '';
                    const hasValue = currentValue.trim() !== '';
                    
                    let inputHtml = '';
                    if (v.type === 'date') {
                        inputHtml = `<input type="date" class="fill-var-input ${hasValue ? 'has-value' : ''}" 
                                    data-var="${escapeHtml(v.name)}" 
                                    value="${escapeHtml(currentValue)}"
                                    onchange="onFillVarChange(this)">`;
                    } else if (v.type === 'email') {
                        inputHtml = `<input type="email" class="fill-var-input ${hasValue ? 'has-value' : ''}" 
                                    data-var="${escapeHtml(v.name)}" 
                                    value="${escapeHtml(currentValue)}"
                                    placeholder="email@example.com"
                                    oninput="onFillVarChange(this)">`;
                    } else if (v.type === 'tel') {
                        inputHtml = `<input type="tel" class="fill-var-input ${hasValue ? 'has-value' : ''}" 
                                    data-var="${escapeHtml(v.name)}" 
                                    value="${escapeHtml(currentValue)}"
                                    placeholder="(555) 123-4567"
                                    oninput="onFillVarChange(this)">`;
                    } else if (v.type === 'money') {
                        inputHtml = `<input type="text" class="fill-var-input ${hasValue ? 'has-value' : ''}" 
                                    data-var="${escapeHtml(v.name)}" 
                                    value="${escapeHtml(currentValue)}"
                                    placeholder="$0.00"
                                    oninput="onFillVarChange(this)">`;
                    } else if (v.type === 'number') {
                        inputHtml = `<input type="number" class="fill-var-input ${hasValue ? 'has-value' : ''}" 
                                    data-var="${escapeHtml(v.name)}" 
                                    value="${escapeHtml(currentValue)}"
                                    placeholder="0"
                                    oninput="onFillVarChange(this)">`;
                    } else {
                        inputHtml = `<input type="text" class="fill-var-input ${hasValue ? 'has-value' : ''}" 
                                    data-var="${escapeHtml(v.name)}" 
                                    value="${escapeHtml(currentValue)}"
                                    placeholder="Enter ${escapeHtml(displayName.toLowerCase())}"
                                    oninput="onFillVarChange(this)">`;
                    }
                    
                    html += `
                        <div class="fill-var-field">
                            <label class="fill-var-label">
                                <span class="type-icon">${v.icon}</span>
                                ${escapeHtml(displayName)}
                                ${v.count > 1 ? `<span class="fill-var-count">×${v.count}</span>` : ''}
                            </label>
                            ${inputHtml}
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            if (fillVarsData.bookmarks.length > 0) {
                html += '<div class="fill-vars-group">';
                html += '<div class="fill-vars-group-label">Bookmarks</div>';
                
                fillVarsData.bookmarks.forEach(bm => {
                    const key = 'bm_' + bm;
                    const currentValue = fillVarsData.values[key] || '';
                    const hasValue = currentValue.trim() !== '';
                    
                    html += `
                        <div class="fill-var-field">
                            <label class="fill-var-label">
                                <span class="type-icon"></span>
                                ${escapeHtml(bm)}
                            </label>
                            <input type="text" class="fill-var-input ${hasValue ? 'has-value' : ''}" 
                                   data-bookmark="${escapeHtml(bm)}"
                                   value="${escapeHtml(currentValue)}"
                                   placeholder="Enter value for bookmark"
                                   oninput="onFillVarChange(this)">
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            container.innerHTML = html;
        }
        
        // Handle input changes
        function onFillVarChange(input) {
            const varName = input.dataset.var;
            const bmName = input.dataset.bookmark;
            const value = input.value;
            
            if (varName) {
                fillVarsData.values[varName] = value;
            } else if (bmName) {
                fillVarsData.values['bm_' + bmName] = value;
            }
            
            // Update input styling
            if (value.trim()) {
                input.classList.add('has-value');
            } else {
                input.classList.remove('has-value');
            }
            
            renderFillVarsPreview();
            updateFillVarsStats();
        }
        
        // Set preview mode
        function setPreviewMode(mode) {
            fillVarsData.previewMode = mode;
            
            // Update toggle buttons
            document.querySelectorAll('.preview-toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.textContent.toLowerCase() === mode);
            });
            
            renderFillVarsPreview();
        }
        
        // Render the preview
        function renderFillVarsPreview() {
            const container = document.getElementById('fill-vars-preview');
            let previewText = fillVarsData.documentText;
            
            // Truncate for display (show first ~1000 chars with context around variables)
            const maxLength = 1500;
            if (previewText.length > maxLength) {
                // Try to show text around variables
                const firstVarMatch = previewText.match(/\{\{[^}]+\}\}/);
                if (firstVarMatch) {
                    const startIdx = Math.max(0, firstVarMatch.index - 200);
                    previewText = (startIdx > 0 ? '...' : '') + 
                                  previewText.substring(startIdx, startIdx + maxLength) +
                                  (previewText.length > startIdx + maxLength ? '...' : '');
                } else {
                    previewText = previewText.substring(0, maxLength) + '...';
                }
            }
            
            // Escape HTML first
            previewText = escapeHtml(previewText);
            
            // Highlight/replace variables
            fillVarsData.variables.forEach(v => {
                const pattern = new RegExp(`\\{\\{${escapeRegExp(v.name)}\\}\\}`, 'g');
                const value = fillVarsData.values[v.name];
                
                if (fillVarsData.previewMode === 'after' && value && value.trim()) {
                    // Show filled value
                    previewText = previewText.replace(pattern, `<span class="preview-filled">${escapeHtml(value)}</span>`);
                } else if (value && value.trim()) {
                    // Show as "will be filled"
                    previewText = previewText.replace(pattern, `<span class="preview-highlight">{{${escapeHtml(v.name)}}}</span>`);
                } else {
                    // Show as unfilled
                    previewText = previewText.replace(pattern, `<span class="preview-unfilled">{{${escapeHtml(v.name)}}}</span>`);
                }
            });
            
            container.innerHTML = previewText;
        }
        
        // Helper to escape regex special chars
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // Update stats in footer
        function updateFillVarsStats() {
            const totalVars = fillVarsData.variables.length;
            const totalBms = fillVarsData.bookmarks.length;
            const total = totalVars + totalBms;
            
            let filled = 0;
            fillVarsData.variables.forEach(v => {
                if (fillVarsData.values[v.name] && fillVarsData.values[v.name].trim()) {
                    filled++;
                }
            });
            fillVarsData.bookmarks.forEach(bm => {
                if (fillVarsData.values['bm_' + bm] && fillVarsData.values['bm_' + bm].trim()) {
                    filled++;
                }
            });
            
            document.getElementById('fill-vars-filled-count').textContent = filled;
            document.getElementById('fill-vars-total-count').textContent = total;
            
            // Enable/disable apply button based on whether any are filled
            document.getElementById('fill-vars-apply-btn').disabled = filled === 0;
        }
        
        // Clear all values
        function clearAllFillVars() {
            fillVarsData.values = {};
            renderFillVarsForm();
            renderFillVarsPreview();
            updateFillVarsStats();
        }
        
        // Apply the variables to the document
        async function applyFillVariables() {
            const btn = document.getElementById('fill-vars-apply-btn');
            
            await withButtonLock(btn, async () => {
                try {
                    await Word.run(async (context) => {
                        const body = context.document.body;
                        
                        // Replace {{variables}}
                        for (const v of fillVarsData.variables) {
                            const value = fillVarsData.values[v.name];
                            if (value && value.trim()) {
                                const searchResults = body.search('{{' + v.name + '}}', { 
                                    matchCase: false, 
                                    matchWholeWord: false 
                                });
                                searchResults.load('items');
                                await context.sync();
                                
                                for (const result of searchResults.items) {
                                    result.insertText(value.trim(), Word.InsertLocation.replace);
                                }
                                await context.sync();
                            }
                        }
                        
                        // Fill bookmarks
                        for (const bm of fillVarsData.bookmarks) {
                            const value = fillVarsData.values['bm_' + bm];
                            if (value && value.trim()) {
                                try {
                                    const bookmark = body.getRange().getBookmark(bm);
                                    bookmark.insertText(value.trim(), Word.InsertLocation.replace);
                                    await context.sync();
                                } catch (e) {
                                    // Could not fill bookmark - skip
                                }
                            }
                        }
                    });
                    
                    // Count filled
                    let filled = 0;
                    fillVarsData.variables.forEach(v => {
                        if (fillVarsData.values[v.name] && fillVarsData.values[v.name].trim()) {
                            filled++;
                        }
                    });
                    fillVarsData.bookmarks.forEach(bm => {
                        if (fillVarsData.values['bm_' + bm] && fillVarsData.values['bm_' + bm].trim()) {
                            filled++;
                        }
                    });
                    
                    // Save values to localStorage for next time
                    saveRememberedValues(fillVarsData.values);
                    
                    toast(`Filled ${filled} variable${filled !== 1 ? 's' : ''} successfully!`, 'success');
                    closeFillVarsModal();
                    
                } catch (err) {
                    console.error('Fill failed:', err);
                    toast(friendlyError(err, 'Could not fill variables'), 'error');
                }
            }, 'Applying...');
        }
        
        // Backward compatibility aliases
        const foundVariables = [];
        const foundBookmarks = [];
        function renderVariablesForm() { renderFillVarsForm(); }
        async function applyVariables() { await applyFillVariables(); }
        
        // ========== NUMBERING & TOC FUNCTIONS ==========
        
        let selectedSchemeId = 'legal-outline';
        let selectedTocStyle = 'level1';
        
        // Numbering Schemes Data
        // Each scheme can have optional styleAssociations for linking to Word styles
        const numberingSchemes = {
            'legal-outline': {
                name: 'Legal Outline',
                levels: [
                    { before: '', style: 'I', after: '.', follow: 'tab' },
                    { before: '', style: 'A', after: '.', follow: 'tab' },
                    { before: '', style: '1', after: '.', follow: 'tab' },
                    { before: '(', style: 'a', after: ')', follow: 'tab' },
                    { before: '(', style: 'i', after: ')', follow: 'tab' }
                ],
                options: { restart: true, legal: false, rightAlign: false, startAt: 1 },
                styleAssociations: [
                    { level: 0, styleName: 'Heading 1' },
                    { level: 1, styleName: 'Heading 2' },
                    { level: 2, styleName: 'Heading 3' }
                ]
            },
            'contract-sections': {
                name: 'Contract Sections',
                levels: [
                    { before: 'ARTICLE ', style: 'I', after: '', follow: 'tab' },
                    { before: 'Section ', style: '1', after: '.', follow: 'tab' },
                    { before: '', style: 'a', after: '.', follow: 'tab' },
                    { before: '(', style: 'i', after: ')', follow: 'tab' },
                    { before: '(', style: 'A', after: ')', follow: 'tab' }
                ],
                options: { restart: true, legal: false, rightAlign: false, startAt: 1 },
                styleAssociations: [
                    { level: 0, styleName: 'Heading 1' },
                    { level: 1, styleName: 'Heading 2' }
                ]
            },
            'heading-style': {
                name: 'Heading Style',
                levels: [
                    { before: '', style: '1', after: '.', follow: 'tab' },
                    { before: '', style: '1', after: '.', follow: 'tab' },
                    { before: '', style: '1', after: '.', follow: 'tab' },
                    { before: '', style: '1', after: '.', follow: 'tab' },
                    { before: '', style: '1', after: '.', follow: 'tab' }
                ],
                options: { restart: true, legal: true, rightAlign: false, startAt: 1 },
                styleAssociations: [
                    { level: 0, styleName: 'Heading 1' },
                    { level: 1, styleName: 'Heading 2' },
                    { level: 2, styleName: 'Heading 3' },
                    { level: 3, styleName: 'Heading 4' },
                    { level: 4, styleName: 'Heading 5' }
                ]
            },
            'pleading-format': {
                name: 'Pleading Format',
                levels: [
                    { before: '', style: '1', after: '.', follow: 'tab' },
                    { before: '', style: 'a', after: '.', follow: 'tab' },
                    { before: '(', style: '1', after: ')', follow: 'tab' },
                    { before: '(', style: 'a', after: ')', follow: 'tab' },
                    { before: '(', style: 'i', after: ')', follow: 'tab' }
                ],
                options: { restart: true, legal: false, rightAlign: false, startAt: 1 },
                styleAssociations: []
            }
        };
        
        // User's saved schemes (loaded from localStorage, later from cloud)
        let userSchemes = {};
        try {
            userSchemes = JSON.parse(localStorage.getItem('draftbridge_numbering_schemes') || '{}');
        } catch (e) {
            console.error('Failed to parse saved schemes:', e);
            userSchemes = {};
        }
        
        // HTML escape utility to prevent XSS (includes single/double quotes for attribute contexts)
        function escapeHtml(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }
        
        // Sanitize user input before sending to server (defense in depth)
        function sanitizeInput(text, maxLength = 50000) {
            if (!text) return '';
            
            let sanitized = String(text)
                // Remove null bytes and control chars (except newlines/tabs)
                .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
                // Remove script tags (case insensitive)
                .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                // Remove event handlers (onclick, onerror, onload, etc.)
                .replace(/\s*on\w+\s*=\s*["'][^"']*["']/gi, '')
                .replace(/\s*on\w+\s*=\s*[^\s>]*/gi, '')
                // Remove javascript: protocol
                .replace(/javascript\s*:/gi, '')
                // Remove data: URIs that could contain scripts
                .replace(/data\s*:\s*text\/html/gi, '')
                // Remove expression() CSS (IE)
                .replace(/expression\s*\(/gi, '')
                // Normalize excessive whitespace
                .replace(/\s{10,}/g, '    ')
                // Trim
                .trim();
            
            // Enforce max length
            if (sanitized.length > maxLength) {
                sanitized = sanitized.substring(0, maxLength);
            }
            
            return sanitized;
        }
        
        // Sanitize for short text fields (titles, categories)
        function sanitizeShortText(text, maxLength = 200) {
            if (!text) return '';
            return sanitizeInput(text, maxLength)
                // For short fields, also remove newlines
                .replace(/[\r\n]+/g, ' ')
                // Collapse multiple spaces
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Debounce utility - prevents excessive function calls during rapid input
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Debounced search filter (200ms delay)
        const debouncedFilterClauses = debounce(filterClauses, 200);
        
        // Format salutation with honorific support
        // "Dr. John Smith" → "Dr. Smith", "John Smith" → "John"
        function formatSalutation(name) {
            if (!name) return '';
            const honorifics = ['Dr.', 'Mr.', 'Mrs.', 'Ms.', 'Prof.', 'Hon.', 'Rev.', 'Judge'];
            const parts = name.trim().split(/\s+/);
            
            if (parts.length >= 2 && honorifics.includes(parts[0])) {
                // Has honorific: "Dr. John Smith" → "Dr. Smith"
                return parts[0] + ' ' + parts[parts.length - 1];
            }
            // No honorific: "John Smith" → "John"
            return parts[0];
        }
        
        // switchNumberingMode is defined below with list controls integration
        
        function selectSchemeCard(schemeId, element) {
            selectedSchemeId = schemeId;
            
            // Update all scheme cards
            document.querySelectorAll('.scheme-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelectorAll('.scheme-list-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            if (element) {
                element.classList.add('selected');
            }
            
            updateNumberingPreview(schemeId);
        }
        
        // Hover preview - temporarily show scheme without selecting it
        function previewScheme(schemeId) {
            updateNumberingPreview(schemeId);
        }
        
        // Restore selected scheme's preview when mouse leaves
        function restoreSelectedPreview() {
            if (selectedSchemeId) {
                updateNumberingPreview(selectedSchemeId);
            }
        }
        
        function updateNumberingPreview(schemeId) {
            const scheme = numberingSchemes[schemeId];
            if (!scheme) return;
            
            const preview = document.getElementById('numbering-preview');
            const samples = ['Article One', 'Section Title', 'Paragraph text', 'Sub-paragraph', 'Detail item'];
            
            let html = '';
            for (let i = 0; i < 5; i++) {
                const level = scheme.levels[i];
                const num = level.before + formatNumber(i + 1, level.style) + level.after;
                html += `<div class="preview-line l${i+1}"><span class="num">${num}</span> ${samples[i]}</div>`;
            }
            preview.innerHTML = html;
        }
        
        function formatNumber(n, style) {
            switch(style) {
                case 'I': return toRoman(n).toUpperCase();
                case 'i': return toRoman(n).toLowerCase();
                case 'A': return toAlpha(n).toUpperCase();
                case 'a': return toAlpha(n).toLowerCase();
                case '1': return n.toString();
                case 'none': return '';
                default: return n.toString();
            }
        }
        
        // Convert number to Excel-style alpha: 1=A, 26=Z, 27=AA, 28=AB, etc.
        function toAlpha(n) {
            let result = '';
            while (n > 0) {
                n--; // Adjust for 1-based indexing
                result = String.fromCharCode(65 + (n % 26)) + result;
                n = Math.floor(n / 26);
            }
            return result || 'A';
        }
        
        function toRoman(num) {
            const romanNumerals = [
                ['M', 1000], ['CM', 900], ['D', 500], ['CD', 400],
                ['C', 100], ['XC', 90], ['L', 50], ['XL', 40],
                ['X', 10], ['IX', 9], ['V', 5], ['IV', 4], ['I', 1]
            ];
            let result = '';
            for (const [letter, value] of romanNumerals) {
                while (num >= value) {
                    result += letter;
                    num -= value;
                }
            }
            return result;
        }
        
        function toggleSchemesSection(sectionId) {
            const section = event.target.closest('.schemes-section');
            section.classList.toggle('collapsed');
        }
        
        function showNumberingEditor() {
            document.getElementById('numbering-browse').classList.remove('active');
            document.getElementById('toc-browse').classList.remove('active');
            document.getElementById('numbering-editor').classList.add('active');
            
            // Load scheme into editor
            const scheme = numberingSchemes[selectedSchemeId];
            if (scheme) {
                document.getElementById('scheme-name').value = scheme.name;
                
                for (let i = 1; i <= 5; i++) {
                    const level = scheme.levels[i - 1];
                    const beforeEl = document.getElementById(`level-${i}-before`);
                    const styleEl = document.getElementById(`level-${i}-style`);
                    const afterEl = document.getElementById(`level-${i}-after`);
                    const followEl = document.getElementById(`level-${i}-follow`);
                    
                    if (beforeEl) beforeEl.value = level.before;
                    if (styleEl) styleEl.value = level.style;
                    if (afterEl) afterEl.value = level.after;
                    if (followEl) followEl.value = level.follow;
                }
                
                document.getElementById('opt-restart').checked = scheme.options.restart;
                document.getElementById('opt-legal').checked = scheme.options.legal;
                document.getElementById('opt-right-align').checked = scheme.options.rightAlign;
                document.getElementById('scheme-start').value = scheme.options.startAt;
            }
        }
        
        function hideNumberingEditor() {
            document.getElementById('numbering-editor').classList.remove('active');
            document.getElementById('numbering-browse').classList.add('active');
        }
        
        function toggleLevelCard(level) {
            const card = document.getElementById(`level-${level}-card`);
            const body = document.getElementById(`level-${level}-body`);
            
            if (card.classList.contains('collapsed')) {
                card.classList.remove('collapsed');
                body.style.display = 'block';
            } else {
                card.classList.add('collapsed');
                body.style.display = 'none';
            }
        }
        
        function saveNumberingScheme() {
            const scheme = {
                name: sanitizeShortText(document.getElementById('scheme-name').value, 100),
                levels: [],
                options: {
                    restart: document.getElementById('opt-restart').checked,
                    legal: document.getElementById('opt-legal').checked,
                    rightAlign: document.getElementById('opt-right-align').checked,
                    startAt: parseInt(document.getElementById('scheme-start').value) || 1
                }
            };
            
            for (let i = 1; i <= 5; i++) {
                scheme.levels.push({
                    // Sanitize before/after text (these get rendered)
                    before: sanitizeShortText(document.getElementById(`level-${i}-before`)?.value || '', 20),
                    style: document.getElementById(`level-${i}-style`)?.value || '1',
                    after: sanitizeShortText(document.getElementById(`level-${i}-after`)?.value || '', 20),
                    follow: document.getElementById(`level-${i}-follow`)?.value || 'tab'
                });
            }
            
            numberingSchemes[selectedSchemeId] = scheme;
            updateNumberingPreview(selectedSchemeId);
            
            toast('Scheme saved!', 'success');
            hideNumberingEditor();
        }
        
        // Open Word's native numbering dialog
        async function openWordNumberingDialog() {
            toast('Use Home → Numbering dropdown → Define New Number Format', 'info', 5000);
        }
        
        // OOXML Number format mapping
        const ooxmlNumFormats = {
            'I': 'upperRoman',
            'i': 'lowerRoman', 
            'A': 'upperLetter',
            'a': 'lowerLetter',
            '1': 'decimal',
            'none': 'none'
        };
        
        // Generate OOXML for a numbering scheme
        // FIXED: Added proper relationships so Word can find numbering.xml
        function generateNumberingOoxml(scheme, sampleText) {
            const numId = 1;
            const abstractNumId = 1;
            
            // Build level definitions
            let levelDefs = '';
            for (let i = 0; i < scheme.levels.length; i++) {
                const level = scheme.levels[i];
                const numFmt = ooxmlNumFormats[level.style] || 'decimal';
                const lvlText = level.before + '%' + (i + 1) + level.after;
                const indent = 720 + (i * 720); // 0.5 inch per level
                const hanging = 360;
                
                levelDefs += `
                    <w:lvl w:ilvl="${i}">
                        <w:start w:val="1"/>
                        <w:numFmt w:val="${numFmt}"/>
                        <w:lvlText w:val="${escapeXml(lvlText)}"/>
                        <w:lvlJc w:val="left"/>
                        <w:pPr>
                            <w:ind w:left="${indent}" w:hanging="${hanging}"/>
                        </w:pPr>
                    </w:lvl>`;
            }
            
            // Build paragraphs with numbering
            let paragraphs = '';
            sampleText.forEach((text, idx) => {
                const level = Math.min(idx, scheme.levels.length - 1);
                paragraphs += `
                    <w:p>
                        <w:pPr>
                            <w:numPr>
                                <w:ilvl w:val="${level}"/>
                                <w:numId w:val="${numId}"/>
                            </w:numPr>
                        </w:pPr>
                        <w:r>
                            <w:t>${escapeXml(text)}</w:t>
                        </w:r>
                    </w:p>`;
            });
            
            // Complete OOXML package WITH PROPER RELATIONSHIPS
            // The key fix: Word needs /_rels/.rels and /word/_rels/document.xml.rels
            // to know that document.xml references numbering.xml
            return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
                <pkg:package xmlns:pkg="http://schemas.microsoft.com/office/2006/xmlPackage">
                    <pkg:part pkg:name="/_rels/.rels" pkg:contentType="application/vnd.openxmlformats-package.relationships+xml">
                        <pkg:xmlData>
                            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
                                <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
                            </Relationships>
                        </pkg:xmlData>
                    </pkg:part>
                    <pkg:part pkg:name="/word/_rels/document.xml.rels" pkg:contentType="application/vnd.openxmlformats-package.relationships+xml">
                        <pkg:xmlData>
                            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
                                <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering" Target="numbering.xml"/>
                            </Relationships>
                        </pkg:xmlData>
                    </pkg:part>
                    <pkg:part pkg:name="/word/numbering.xml" pkg:contentType="application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml">
                        <pkg:xmlData>
                            <w:numbering xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                                <w:abstractNum w:abstractNumId="${abstractNumId}">
                                    ${levelDefs}
                                </w:abstractNum>
                                <w:num w:numId="${numId}">
                                    <w:abstractNumId w:val="${abstractNumId}"/>
                                </w:num>
                            </w:numbering>
                        </pkg:xmlData>
                    </pkg:part>
                    <pkg:part pkg:name="/word/document.xml" pkg:contentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml">
                        <pkg:xmlData>
                            <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                                <w:body>
                                    ${paragraphs}
                                </w:body>
                            </w:document>
                        </pkg:xmlData>
                    </pkg:part>
                </pkg:package>`;
        }
        
        // Escape special XML characters
        function escapeXml(text) {
            if (!text) return '';
            return String(text)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
        
        async function applySelectedScheme() {
            console.log('[NUMBERING] applySelectedScheme() called');
            console.log('[NUMBERING] selectedSchemeId:', selectedSchemeId);
            
            const scheme = numberingSchemes[selectedSchemeId] || userSchemes[selectedSchemeId];
            console.log('[NUMBERING] scheme found:', !!scheme, scheme?.name);
            
            if (!scheme) {
                toast('Please select a numbering scheme first', 'error');
                return;
            }
            
            // Find and lock the Insert button
            const insertBtn = document.querySelector('#numbering-browse .btn:not(.secondary)');
            console.log('[NUMBERING] Insert button found:', !!insertBtn);
            if (insertBtn) {
                insertBtn.disabled = true;
                insertBtn.textContent = 'Inserting...';
            }
            
            try {
                console.log('[NUMBERING] Starting Word.run...');
                toast('Applying numbering...', 'info');
                
                await Word.run(async (context) => {
                    console.log('[NUMBERING] Inside Word.run, getting selection...');
                    const selection = context.document.getSelection();
                    selection.load('text');
                    await context.sync();
                    console.log('[NUMBERING] Selection loaded, text length:', selection.text?.length);
                    
                    // Determine sample text
                    let sampleText;
                    const selectedText = selection.text.trim();
                    const hasSelection = selectedText && selectedText.length > 0;
                    console.log('[NUMBERING] hasSelection:', hasSelection);
                    
                    if (hasSelection) {
                        // Use selected text, split by lines
                        sampleText = selectedText.split('\r').filter(line => line.trim());
                        if (sampleText.length === 0) {
                            sampleText = ['First item', 'Second item', 'Third item'];
                        }
                    } else {
                        // No selection - insert sample numbered list at cursor
                        sampleText = [
                            'Article One',
                            'Section A', 
                            'Paragraph 1',
                            'Sub-paragraph (a)',
                            'Detail item (i)'
                        ];
                    }
                    console.log('[NUMBERING] sampleText items:', sampleText.length);
                    
                    // Generate OOXML with proper numbering (now with relationships!)
                    const ooxml = generateNumberingOoxml(scheme, sampleText);
                    console.log('[NUMBERING] OOXML generated, length:', ooxml?.length);
                    
                    // Insert at cursor/selection
                    // Use 'end' for no selection (inserts at cursor), 'replace' if text was selected
                    const insertLocation = hasSelection ? Word.InsertLocation.replace : Word.InsertLocation.end;
                    console.log('[NUMBERING] Inserting with location:', insertLocation);
                    
                    selection.insertOoxml(ooxml, insertLocation);
                    await context.sync();
                    console.log('[NUMBERING] Insert complete!');
                });
                
                toast(`${scheme.name} numbering applied!`, 'success');
            } catch (err) {
                console.error('[NUMBERING] Apply failed:', err);
                console.error('[NUMBERING] Error details:', err.message, err.code, err.debugInfo);
                const msg = err.message || String(err);
                
                // Provide specific, helpful error messages
                if (msg.includes('GeneralException') || msg.includes('InvalidArgument')) {
                    // OOXML rejected - try simpler fallback
                    console.log('[NUMBERING] OOXML rejected, trying fallback...');
                    toast('Trying simpler approach...', 'info');
                    await applyNumberingSimpleFallback();
                } else if (msg.includes('RichApi') || msg.includes('ItemNotFound')) {
                    // Cursor/document not ready
                    toast('Click inside your document first, then try again.', 'warning');
                } else {
                    toast('Insert failed: ' + msg.substring(0, 100), 'error');
                }
            } finally {
                // Re-enable the Insert button
                const insertBtn = document.querySelector('#numbering-browse .btn:not(.secondary)');
                if (insertBtn) {
                    insertBtn.disabled = false;
                    insertBtn.textContent = 'Insert';
                }
            }
        }
        
        // Fallback: DO NOT destroy user content - just show helpful guidance
        // Previous version replaced selection with sample text - NEVER do that
        async function applyNumberingFallback() {
            const scheme = numberingSchemes[selectedSchemeId] || userSchemes[selectedSchemeId];
            if (!scheme) {
                toast('No scheme selected', 'error');
                return;
            }
            
            console.log('[NUMBERING Fallback] Trying simple text insertion...');
            
            // Try inserting plain text to verify Word API works at all
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    
                    // Create a simple text representation of the numbering scheme
                    const sampleText = [
                        'I.\tArticle One',
                        '\tA.\tSection Title',
                        '\t\t1.\tParagraph text',
                        '\t\t\t(a)\tSub-paragraph',
                        '\t\t\t\t(i)\tDetail item'
                    ].join('\n');
                    
                    selection.insertText(sampleText, Word.InsertLocation.end);
                    await context.sync();
                    console.log('[NUMBERING Fallback] Plain text inserted successfully');
                    toast('Sample outline inserted (plain text). For formatted numbering, use Home → Numbering.', 'info', 5000);
                });
            } catch (textErr) {
                console.error('[NUMBERING Fallback] Even plain text failed:', textErr);
                toast('Cannot insert into document. Click inside your document first.', 'error', 5000);
            }
        }
        
        // Simpler fallback using Word's native list APIs (when OOXML fails)
        async function applyNumberingSimpleFallback() {
            const scheme = numberingSchemes[selectedSchemeId] || userSchemes[selectedSchemeId];
            if (!scheme) {
                toast('No scheme selected', 'error');
                return;
            }
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    
                    // Insert sample paragraphs with text first
                    const sampleText = [
                        'Article One',
                        'Section A', 
                        'Paragraph 1',
                        'Sub-paragraph (a)',
                        'Detail item (i)'
                    ];
                    
                    let lastPara = null;
                    for (let i = 0; i < sampleText.length; i++) {
                        const para = selection.insertParagraph(sampleText[i], Word.InsertLocation.after);
                        
                        if (i === 0) {
                            // Start a new list on first paragraph
                            para.startNewList();
                        }
                        
                        lastPara = para;
                    }
                    
                    await context.sync();
                    
                    // Now set the list levels
                    const body = context.document.body;
                    const paragraphs = body.paragraphs;
                    paragraphs.load('items');
                    await context.sync();
                    
                    // Find our inserted paragraphs (last 5) and set their levels
                    const startIdx = Math.max(0, paragraphs.items.length - sampleText.length);
                    for (let i = startIdx; i < paragraphs.items.length; i++) {
                        const para = paragraphs.items[i];
                        para.load('listItemOrNullObject');
                        await context.sync();
                        
                        if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                            const listItem = para.listItemOrNullObject;
                            const targetLevel = i - startIdx;
                            
                            // Set level by calling levelDown() the appropriate number of times
                            for (let lvl = 0; lvl < targetLevel; lvl++) {
                                listItem.levelDown();
                            }
                        }
                    }
                    
                    await context.sync();
                });
                
                toast('Basic numbering applied! For custom formats, use Home → Numbering', 'success');
            } catch (err) {
                console.error('[NUMBERING] Simple fallback also failed:', err);
                toast('Could not apply numbering. Try selecting text first, then use Home → Numbering.', 'error');
            }
        }
        
        // Apply style associations from a numbering scheme
        async function applyStyleAssociations(context, associations) {
            const missingStyles = [];
            const linkedStyles = [];
            
            // Get all built-in style names to check against
            const builtInStyles = [
                'Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5',
                'Heading 6', 'Heading 7', 'Heading 8', 'Heading 9', 'Title', 'Subtitle',
                'Quote', 'Intense Quote', 'List Paragraph', 'TOC Heading'
            ];
            
            for (const assoc of associations) {
                try {
                    // Check if it's a known built-in style (these always exist)
                    if (builtInStyles.includes(assoc.styleName)) {
                        linkedStyles.push(assoc.styleName);
                    } else {
                        // For custom styles, we can't easily check existence
                        // Mark as potentially missing - user will see if it fails
                        missingStyles.push(assoc);
                    }
                } catch (e) {
                    missingStyles.push(assoc);
                }
            }
            
            if (missingStyles.length > 0) {
                // Show dialog for missing/custom styles
                showMissingStylesDialog(missingStyles, linkedStyles);
            } else if (linkedStyles.length > 0) {
                toast(`Linked to styles: ${linkedStyles.join(', ')}`, 'success');
            }
        }
        
        // Dialog for handling missing styles
        function showMissingStylesDialog(missingStyles, linkedStyles) {
            const styleNames = missingStyles.map(s => s.styleName).join(', ');
            
            if (linkedStyles.length > 0) {
                toast(`Numbering applied! Linked: ${linkedStyles.join(', ')}. Missing: ${styleNames}`, 'warning', 6000);
            } else {
                toast(`Numbering applied! Styles not found: ${styleNames}. Create them in Word's Styles pane.`, 'warning', 6000);
            }
        }
        
        // Capture numbering scheme from current document
        async function captureNumberingFromDocument() {
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.load('paragraphs');
                    await context.sync();
                    
                    const paragraphs = selection.paragraphs;
                    paragraphs.load('items');
                    await context.sync();
                    
                    if (paragraphs.items.length === 0) {
                        toast('Select some numbered text first', 'warning');
                        return;
                    }
                    
                    // Collect styles used in selection
                    const styleMap = new Map(); // level -> styleName
                    const capturedLevels = [];
                    
                    for (const para of paragraphs.items) {
                        para.load(['style', 'listFormat/listLevelNumber', 'listFormat/listString']);
                        await context.sync();
                        
                        const level = para.listFormat.listLevelNumber;
                        const styleName = para.style;
                        const listString = para.listFormat.listString;
                        
                        if (level >= 0 && listString) {
                            // Capture the level format
                            if (!capturedLevels[level]) {
                                capturedLevels[level] = {
                                    before: '',
                                    style: detectNumberStyle(listString),
                                    after: detectSuffix(listString),
                                    follow: 'tab'
                                };
                            }
                            
                            // Capture style association
                            if (styleName && styleName !== 'Normal' && !styleMap.has(level)) {
                                styleMap.set(level, styleName);
                            }
                        }
                    }
                    
                    // Build style associations array
                    const styleAssociations = [];
                    for (const [level, styleName] of styleMap) {
                        styleAssociations.push({ level, styleName });
                    }
                    
                    // Filter out sparse array holes and compact levels
                    const compactLevels = capturedLevels.filter(l => l !== undefined);
                    if (compactLevels.length === 0) {
                        toast('No numbered paragraphs found in selection', 'warning');
                        return;
                    }
                    
                    // Show save dialog with captured data
                    showSaveSchemeDialog(compactLevels, styleAssociations);
                });
            } catch (err) {
                console.error('Capture failed:', err);
                toast('Failed to capture: ' + err.message, 'error');
            }
        }
        
        // Detect number style from list string (e.g., "I." -> "I", "1." -> "1")
        function detectNumberStyle(listString) {
            if (!listString) return '1';
            const cleaned = listString.replace(/[\.\)\(\s]/g, '');
            if (/^[IVXLCDM]+$/i.test(cleaned)) {
                return cleaned === cleaned.toUpperCase() ? 'I' : 'i';
            }
            if (/^[A-Z]+$/.test(cleaned)) return 'A';
            if (/^[a-z]+$/.test(cleaned)) return 'a';
            return '1';
        }
        
        // Detect suffix from list string
        function detectSuffix(listString) {
            if (!listString) return '.';
            if (listString.endsWith(')')) return ')';
            if (listString.endsWith('.')) return '.';
            if (listString.endsWith(':')) return ':';
            return '';
        }
        
        // Show dialog to save captured scheme
        function showSaveSchemeDialog(levels, styleAssociations) {
            // Build HTML for style associations preview
            let stylePreview = '';
            if (styleAssociations.length > 0) {
                stylePreview = styleAssociations.map(s => 
                    `<div class="style-assoc-item">Level ${s.level + 1} → "${escapeHtml(s.styleName)}"</div>`
                ).join('');
            } else {
                stylePreview = '<div class="style-assoc-empty">No style associations detected</div>';
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">Save Numbering Scheme</div>
                    <div class="field">
                        <label>Scheme Name</label>
                        <input type="text" id="save-scheme-name" placeholder="My Legal Outline">
                    </div>
                    <div class="field">
                        <label>
                            <input type="checkbox" id="save-scheme-styles" checked>
                            Include style associations
                        </label>
                        <div class="style-assoc-preview">${stylePreview}</div>
                    </div>
                    <div class="modal-actions">
                        <button class="btn secondary" onclick="closeSaveSchemeModal()">Cancel</button>
                        <button class="btn" onclick="saveNewScheme()">Save</button>
                    </div>
                </div>
            `;
            
            // Store captured data for save
            modal.dataset.levels = JSON.stringify(levels);
            modal.dataset.styles = JSON.stringify(styleAssociations);
            
            document.body.appendChild(modal);
            document.getElementById('save-scheme-name').focus();
            
            // Close on Escape key - store handler for cleanup
            modal._escHandler = (e) => {
                if (e.key === 'Escape') {
                    closeSaveSchemeModal();
                }
            };
            document.addEventListener('keydown', modal._escHandler);
        }
        
        function closeSaveSchemeModal() {
            const modal = document.querySelector('.modal-overlay');
            // Clean up escape handler to prevent memory leak
            if (modal && modal._escHandler) {
                document.removeEventListener('keydown', modal._escHandler);
            }
            if (modal) modal.remove();
        }
        
        function saveNewScheme() {
            const modal = document.querySelector('.modal-overlay');
            const rawName = document.getElementById('save-scheme-name').value.trim();
            const includeStyles = document.getElementById('save-scheme-styles').checked;
            
            if (!rawName) {
                toast('Please enter a scheme name', 'warning');
                return;
            }
            
            // Sanitize the name
            const name = sanitizeShortText(rawName, 100);
            
            // Check for duplicate names
            const existingNames = Object.values(userSchemes).map(s => s.name.toLowerCase());
            if (existingNames.includes(name.toLowerCase())) {
                toast('A scheme with this name already exists', 'warning');
                return;
            }
            
            const levels = JSON.parse(modal.dataset.levels || '[]');
            const styleAssociations = includeStyles ? JSON.parse(modal.dataset.styles || '[]') : [];
            
            // Sanitize style names in associations (they come from document, but could be manipulated)
            const sanitizedStyleAssocs = styleAssociations.map(s => ({
                ...s,
                styleName: sanitizeShortText(s.styleName || '', 100)
            }));
            
            // Generate unique ID
            const schemeId = 'user_' + Date.now();
            
            // Create scheme object
            const scheme = {
                name: name,
                levels: levels.length > 0 ? levels : [
                    { before: '', style: '1', after: '.', follow: 'tab' }
                ],
                options: { restart: true, legal: false, rightAlign: false, startAt: 1 },
                styleAssociations: sanitizedStyleAssocs,
                createdAt: new Date().toISOString()
            };
            
            // Save to userSchemes
            userSchemes[schemeId] = scheme;
            localStorage.setItem('draftbridge_numbering_schemes', JSON.stringify(userSchemes));
            
            // Refresh the scheme list
            refreshSchemeList();
            
            closeSaveSchemeModal();
            toast(`Saved "${name}" with ${styleAssociations.length} style associations`, 'success');
        }
        
        // Refresh the scheme dropdown/list to include user schemes
        function refreshSchemeList() {
            // Just reload the user schemes display
            loadUserSchemes();
        }
        
        // Load user schemes on startup
        function loadUserSchemes() {
            const container = document.getElementById('user-schemes-container');
            if (!container) return;
            
            const userSchemeKeys = Object.keys(userSchemes);
            if (userSchemeKeys.length === 0) {
                container.innerHTML = '<div class="empty-state">No saved schemes yet</div>';
                return;
            }
            
            container.innerHTML = '';
            for (const [id, scheme] of Object.entries(userSchemes)) {
                // Validate scheme ID format (alphanumeric + underscore/hyphen only)
                if (!/^[a-zA-Z0-9_-]+$/.test(id)) continue;
                
                const hasStyles = scheme.styleAssociations && scheme.styleAssociations.length > 0;
                const item = document.createElement('div');
                item.className = 'scheme-list-item';
                item.dataset.schemeId = id;
                item.onclick = () => selectSchemeCard(id, item);
                item.onmouseenter = () => previewScheme(id);
                item.onmouseleave = () => restoreSelectedPreview();
                item.innerHTML = `
                    <span class="scheme-icon">${hasStyles ? '•' : '•'}</span>
                    <span class="scheme-name">${escapeHtml(scheme.name)}</span>
                    ${hasStyles ? `<span class="scheme-badge">${scheme.styleAssociations.length} styles</span>` : ''}
                    <button class="scheme-delete" data-action="delete-scheme">×</button>
                `;
                
                // Safe event listener for delete button
                item.querySelector('.scheme-delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteUserScheme(id);
                });
                
                container.appendChild(item);
            }
        }
        
        // Delete a user-saved scheme
        async function deleteUserScheme(schemeId) {
            const confirmed = await SmartVariables.showConfirm('Delete this numbering scheme?', { destructive: true, confirmText: 'Delete' });
            if (!confirmed) return;
            
            delete userSchemes[schemeId];
            localStorage.setItem('draftbridge_numbering_schemes', JSON.stringify(userSchemes));
            
            // Clear selection if we deleted the active scheme
            if (selectedSchemeId === schemeId) {
                selectedSchemeId = 'legal-outline'; // Reset to default
            }
            
            loadUserSchemes();
            toast('Scheme deleted', 'success');
        }
        
        // TOC Functions
        function selectTocStyle(style, element) {
            selectedTocStyle = style;
            
            document.querySelectorAll('.toc-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            if (element) {
                element.classList.add('selected');
            }
        }
        
        async function insertToc() {
            console.log('[TOC] insertToc() called');
            console.log('[TOC] selectedTocStyle:', selectedTocStyle);
            try {
                console.log('[TOC] Starting Word.run...');
                await Word.run(async (context) => {
                    // Determine heading levels based on selection
                    let headingLevels = '1';
                    if (selectedTocStyle === 'level12') headingLevels = '1-2';
                    if (selectedTocStyle === 'level123') headingLevels = '1-3';
                    
                    console.log('[TOC] Heading levels:', headingLevels);
                    const range = context.document.getSelection();
                    range.load('text');
                    await context.sync();
                    
                    // Determine if there's a selection
                    const hasSelection = range.text && range.text.trim().length > 0;
                    console.log('[TOC] hasSelection:', hasSelection, 'text length:', range.text?.length);
                    
                    // Use proper OOXML package format for TOC
                    const tocOoxml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
                        <pkg:package xmlns:pkg="http://schemas.microsoft.com/office/2006/xmlPackage">
                            <pkg:part pkg:name="/word/document.xml" pkg:contentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml">
                                <pkg:xmlData>
                                    <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                                        <w:body>
                                            <w:sdt>
                                                <w:sdtPr>
                                                    <w:docPartObj>
                                                        <w:docPartGallery w:val="Table of Contents"/>
                                                        <w:docPartUnique/>
                                                    </w:docPartObj>
                                                </w:sdtPr>
                                                <w:sdtContent>
                                                    <w:p>
                                                        <w:pPr>
                                                            <w:pStyle w:val="TOCHeading"/>
                                                        </w:pPr>
                                                        <w:r>
                                                            <w:t>Table of Contents</w:t>
                                                        </w:r>
                                                    </w:p>
                                                    <w:p>
                                                        <w:r>
                                                            <w:fldChar w:fldCharType="begin"/>
                                                        </w:r>
                                                        <w:r>
                                                            <w:instrText xml:space="preserve"> TOC \\o "${headingLevels}" \\h \\z \\u </w:instrText>
                                                        </w:r>
                                                        <w:r>
                                                            <w:fldChar w:fldCharType="separate"/>
                                                        </w:r>
                                                        <w:r>
                                                            <w:t>Press F9 to update table of contents</w:t>
                                                        </w:r>
                                                        <w:r>
                                                            <w:fldChar w:fldCharType="end"/>
                                                        </w:r>
                                                    </w:p>
                                                </w:sdtContent>
                                            </w:sdt>
                                        </w:body>
                                    </w:document>
                                </pkg:xmlData>
                            </pkg:part>
                        </pkg:package>`;
                    
                    console.log('[TOC] OOXML generated, length:', tocOoxml.length);
                    
                    // Use 'end' when no selection, 'replace' when text is selected
                    const insertLocation = hasSelection ? Word.InsertLocation.replace : Word.InsertLocation.end;
                    console.log('[TOC] Inserting OOXML with location:', insertLocation);
                    range.insertOoxml(tocOoxml, insertLocation);
                    await context.sync();
                    console.log('[TOC] Insert complete!');
                });
                
                toast('TOC inserted! Press F9 to populate.', 'success', 5000);
            } catch (err) {
                console.error('[TOC] Insert failed:', err);
                console.error('[TOC] Error details:', err.message, err.code, err.debugInfo);
                
                // Try simpler fallback without SDT wrapper
                console.log('[TOC] Trying simpler fallback...');
                try {
                    await insertTocSimpleFallback();
                } catch (fallbackErr) {
                    console.error('[TOC] Fallback also failed:', fallbackErr);
                    toast('TOC failed: ' + (err.message || 'Unknown error') + '. Use References → Table of Contents instead.', 'error', 5000);
                }
            }
        }
        
        // Simpler TOC fallback without SDT wrapper
        async function insertTocSimpleFallback() {
            await Word.run(async (context) => {
                let headingLevels = '1';
                if (selectedTocStyle === 'level12') headingLevels = '1-2';
                if (selectedTocStyle === 'level123') headingLevels = '1-3';
                
                const range = context.document.getSelection();
                
                // Simpler OOXML - just the TOC field without SDT wrapper
                const simpleTocOoxml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
                    <pkg:package xmlns:pkg="http://schemas.microsoft.com/office/2006/xmlPackage">
                        <pkg:part pkg:name="/word/document.xml" pkg:contentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml">
                            <pkg:xmlData>
                                <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                                    <w:body>
                                        <w:p>
                                            <w:pPr>
                                                <w:pStyle w:val="Heading1"/>
                                            </w:pPr>
                                            <w:r>
                                                <w:t>Table of Contents</w:t>
                                            </w:r>
                                        </w:p>
                                        <w:p>
                                            <w:r>
                                                <w:fldChar w:fldCharType="begin"/>
                                            </w:r>
                                            <w:r>
                                                <w:instrText xml:space="preserve"> TOC \\o "${headingLevels}" \\h \\z \\u </w:instrText>
                                            </w:r>
                                            <w:r>
                                                <w:fldChar w:fldCharType="separate"/>
                                            </w:r>
                                            <w:r>
                                                <w:t>Update this field (F9) to see table of contents</w:t>
                                            </w:r>
                                            <w:r>
                                                <w:fldChar w:fldCharType="end"/>
                                            </w:r>
                                        </w:p>
                                    </w:body>
                                </w:document>
                            </pkg:xmlData>
                        </pkg:part>
                    </pkg:package>`;
                
                console.log('[TOC Fallback] Inserting simpler OOXML...');
                range.insertOoxml(simpleTocOoxml, Word.InsertLocation.end);
                await context.sync();
                console.log('[TOC Fallback] Success!');
                toast('TOC inserted! Press F9 to populate.', 'success', 5000);
            });
        }
        
        async function updateToc() {
            try {
                await Word.run(async (context) => {
                    // Get all fields in the document body
                    const body = context.document.body;
                    const fields = body.fields;
                    fields.load('items');
                    await context.sync();
                    
                    if (fields.items.length === 0) {
                        toast('No fields found in document. Insert a TOC first.', 'warning');
                        return;
                    }
                    
                    // Update all fields (includes TOC, page numbers, cross-refs, etc.)
                    let updatedCount = 0;
                    for (const field of fields.items) {
                        try {
                            field.updateResult();
                            updatedCount++;
                        } catch (fieldErr) {
                            // Some fields may not support update, skip them
                            console.warn('Could not update field:', fieldErr);
                        }
                    }
                    
                    await context.sync();
                    
                    if (updatedCount > 0) {
                        toast(`Updated ${updatedCount} field(s)`, 'success');
                    } else {
                        // Fallback message if API method didn't work
                        toast('Select TOC and press F9 to update', 'info', 5000);
                    }
                });
            } catch (err) {
                console.error('TOC update failed:', err);
                // Fallback for older Word versions or API limitations
                if (err.code === 'GeneralException' || err.code === 'ItemNotFound') {
                    toast('Select TOC and press F9 to update, or right-click → Update Field', 'info', 5000);
                } else {
                    toast('Could not update fields: ' + err.message, 'error');
                }
            }
        }
        // Generate Documents
        async function generateLetter() {
            const date = document.getElementById('letter-date').value;
            const recipient = document.getElementById('letter-recipient').value;
            const address = document.getElementById('letter-address').value;
            const subject = document.getElementById('letter-subject').value;
            const closing = document.getElementById('letter-closing').value;
            const delivery = document.getElementById('letter-delivery').value;
            const enclosures = document.getElementById('letter-enclosures').value;
            const signer = document.getElementById('letter-signer').value;
            
            // Get job title based on option
            const titleOption = document.getElementById('letter-title-option').value;
            let jobTitle = '';
            if (titleOption === 'yes') {
                jobTitle = getSelectedAuthorTitle('letter-signer');
            } else if (titleOption === 'custom') {
                jobTitle = document.getElementById('letter-title-custom').value;
            }
            
            let text = `${formatDate(date)}

${recipient}
${address}`;

            if (delivery) text += `\n\n${delivery}`;

            text += `

RE: ${subject}

Dear ${formatSalutation(recipient)}:

[Letter body here]

${closing},


${signer}`;

            if (jobTitle) text += `\n${jobTitle}`;

            if (enclosures) text += `\n\n${enclosures}`;
            
            await insertText(text);
            hideTemplate();
        }
        
        async function generateMemo() {
            const date = document.getElementById('memo-date').value;
            const to = document.getElementById('memo-to').value;
            const from = document.getElementById('memo-from').value;
            const subject = document.getElementById('memo-subject').value;
            const cc = document.getElementById('memo-cc').value;
            
            let text = `MEMORANDUM

DATE:    ${formatDate(date)}
TO:      ${to}
FROM:    ${from}
RE:      ${subject}`;
            
            if (cc) text += `\nCC:      ${cc}`;
            
            text += `\n\n${'─'.repeat(50)}\n\n[Memo body here]`;
            
            await insertText(text);
            hideTemplate();
        }
        
        async function generateFax() {
            const date = document.getElementById('fax-date').value;
            const to = document.getElementById('fax-to').value;
            const faxNum = document.getElementById('fax-number').value;
            const from = document.getElementById('fax-from').value;
            const phone = document.getElementById('fax-phone').value;
            const pages = document.getElementById('fax-pages').value;
            const subject = document.getElementById('fax-subject').value;
            
            const text = `FAX COVER SHEET

DATE:     ${formatDate(date)}
TO:       ${to}
FAX:      ${faxNum}
FROM:     ${from}
PHONE:    ${phone}
PAGES:    ${pages} (including cover)
RE:       ${subject}

${'─'.repeat(50)}

COMMENTS:

[Comments here]`;
            
            await insertText(text);
            hideTemplate();
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '';
            const d = new Date(dateStr + 'T00:00:00');
            return d.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
        }
        
        async function insertText(text) {
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.insertText(text, Word.InsertLocation.replace);
                    await context.sync();
                });
                toast('Inserted!', 'success');
            } catch (err) {
                console.error('Insert failed:', err);
                toast(friendlyError(err, 'Failed to insert. Click in your document and try again.'), 'error');
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // SAVE CLAUSE TO LIBRARY
        // ═══════════════════════════════════════════════════════════════
        
        let pendingSaveText = '';
        let selectedSaveCategory = 'contracts';

        async function startSaveClause() {
            try {
                let selectedText = '';
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.load('text');
                    await context.sync();
                    selectedText = selection.text.trim();
                });

                if (!selectedText) {
                    toast('Please highlight text in your document first', 'error');
                    return;
                }

                if (selectedText.length < 20) {
                    toast('Please select more text (at least 20 characters)', 'error');
                    return;
                }

                pendingSaveText = selectedText;
                
                // Preview (truncated)
                document.getElementById('save-preview').textContent = 
                    selectedText.length > 300 ? selectedText.substring(0, 300) + '...' : selectedText;
                
                // Generate suggested title
                document.getElementById('save-title').value = generateSaveTitle(selectedText);
                
                // Reset category selection
                selectedSaveCategory = 'contracts';
                document.querySelectorAll('.category-btn').forEach(btn => {
                    btn.classList.toggle('selected', btn.dataset.cat === 'contracts');
                });
                
                // Switch views - hide settings main, show save form
                document.querySelector('#panel-admin > .content').style.display = 'none';
                document.getElementById('save-clause-form').style.display = 'block';
                document.getElementById('save-title').focus();
                
            } catch (err) {
                console.error('Error getting selection:', err);
                toast('Could not read document selection', 'error');
            }
        }

        function generateSaveTitle(text) {
            const firstLine = text.split('\n')[0].trim();
            if (firstLine.length <= 50) return firstLine;
            return firstLine.substring(0, 47) + '...';
        }

        function selectSaveCategory(category) {
            selectedSaveCategory = category;
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.cat === category);
            });
        }

        function cancelSaveClause() {
            pendingSaveText = '';
            document.getElementById('save-title').value = '';
            document.getElementById('save-preview').textContent = '';
            document.querySelector('#panel-admin > .content').style.display = 'block';
            document.getElementById('save-clause-form').style.display = 'none';
        }

        async function confirmSaveClause() {
            const rawTitle = document.getElementById('save-title').value.trim();
            
            if (!rawTitle) {
                toast('Please enter a title', 'error');
                document.getElementById('save-title').focus();
                return;
            }
            
            if (!pendingSaveText) {
                toast('No text to save. Select some text in your document first.', 'error');
                cancelSaveClause();
                return;
            }
            
            // Sanitize all inputs before sending to server (defense in depth)
            const title = sanitizeShortText(rawTitle, 200);
            const content = sanitizeInput(pendingSaveText, 50000);
            const category = sanitizeShortText(selectedSaveCategory || 'contracts', 50);
            
            // Check if sanitization significantly altered the input (possible injection attempt)
            if (title.length < rawTitle.trim().length * 0.5) {
                toast('Title contains invalid characters. Please use letters, numbers, and basic punctuation.', 'error');
                console.warn('Possible injection attempt in title:', rawTitle);
                return;
            }
            
            await withButtonLock('confirm-save-btn', async () => {
                try {
                    const resp = await fetch(`${API}/firms/${FIRM}/clauses`, {
                        method: 'POST',
                        headers: apiHeaders(),
                        body: JSON.stringify({
                            title,
                            content,
                            category,
                            tags: [],
                            createdBy: 'user'
                        })
                    });

                    if (!resp.ok) {
                        if (resp.status === 401 || resp.status === 403) {
                            throw new Error('Not authorized. Please sign in again.');
                        } else if (resp.status === 413) {
                            throw new Error('Clause is too long. Try selecting less text.');
                        }
                        throw new Error(`Server error (${resp.status})`);
                    }

                    const newClause = await resp.json();
                    allClauses.unshift(newClause);
                    renderClauses();
                    
                    // Return to main settings view
                    cancelSaveClause();
                    
                    // Show success toast
                    toast(`Saved to library: ${title}`, 'success');
                    
                    // Switch to Library tab to show the new clause
                    switchPanel('library');
                    
                } catch (err) {
                    console.error('Save failed:', err);
                    toast(friendlyError(err, 'Could not save clause'), 'error');
                }
            }, 'Saving...');
        }

        // Built-in Smart Clause Library (fallback/samples)
        const BUILT_IN_CLAUSES = [
            {
                clauseId: 'builtin-mtd-1',
                title: 'Motion to Dismiss - 12(b)(6)',
                category: 'litigation',
                content: 'COMES NOW Defendant, {{defendant.name}}, by and through undersigned counsel, and pursuant to Federal Rule of Civil Procedure 12(b)(6), moves this Honorable Court to dismiss Plaintiff\'s Complaint for failure to state a claim upon which relief can be granted. In support of this Motion, Defendant states as follows:\n\nI. INTRODUCTION\n\nPlaintiff\'s Complaint fails to state a plausible claim for relief and should be dismissed with prejudice.\n\nII. LEGAL STANDARD\n\nTo survive a motion to dismiss under Rule 12(b)(6), a complaint must contain "enough facts to state a claim to relief that is plausible on its face." Bell Atl. Corp. v. Twombly, 550 U.S. 544, 570 (2007).',
                tags: ['motion', 'dismiss', 'federal', '12b6']
            },
            {
                clauseId: 'builtin-demand-1',
                title: 'Demand Letter - General',
                category: 'litigation',
                content: 'RE: Demand for Payment\n\nDear {{opposing.party}}:\n\nThis firm represents {{client.name}} regarding the above-referenced matter. Please be advised that our client demands immediate payment of ${{amount}} representing {{description}}.\n\nYour failure to satisfy this demand within {{deadline.days}} days of the date of this letter will result in our client pursuing all available legal remedies, including but not limited to commencing litigation, seeking all costs and attorney\'s fees permitted by law.\n\nPlease govern yourself accordingly.',
                tags: ['demand', 'letter', 'payment', 'collection']
            },
            {
                clauseId: 'builtin-indem-1',
                title: 'Indemnification Clause',
                category: 'contracts',
                content: 'INDEMNIFICATION. {{indemnitor}} (the "Indemnitor") shall indemnify, defend, and hold harmless {{indemnitee}} (the "Indemnitee"), its officers, directors, employees, agents, and affiliates, from and against any and all claims, damages, losses, costs, and expenses (including reasonable attorneys\' fees) arising out of or relating to:\n\n(a) any breach of this Agreement by Indemnitor;\n(b) any negligent or wrongful act or omission of Indemnitor;\n(c) any violation of applicable law by Indemnitor.\n\nThis indemnification shall survive the termination or expiration of this Agreement.',
                tags: ['indemnification', 'hold harmless', 'liability']
            },
            {
                clauseId: 'builtin-conf-1',
                title: 'Confidentiality Clause',
                category: 'contracts',
                content: 'CONFIDENTIALITY. Each party agrees to hold in strict confidence all Confidential Information disclosed by the other party. "Confidential Information" means any non-public information, technical data, trade secrets, or know-how, including but not limited to research, product plans, products, services, customers, markets, software, developments, inventions, processes, formulas, technology, designs, drawings, engineering, and business information.\n\nThe receiving party shall:\n(a) Use the same degree of care to protect Confidential Information as it uses to protect its own confidential information, but no less than reasonable care;\n(b) Not disclose Confidential Information to any third party without prior written consent;\n(c) Limit disclosure to employees and agents who have a need to know.',
                tags: ['confidentiality', 'nda', 'trade secrets']
            },
            {
                clauseId: 'builtin-force-1',
                title: 'Force Majeure',
                category: 'contracts',
                content: 'FORCE MAJEURE. Neither party shall be liable for any failure or delay in performing their obligations under this Agreement if such failure or delay results from circumstances beyond the reasonable control of that party, including but not limited to: acts of God, natural disasters, war, terrorism, riots, embargoes, acts of civil or military authorities, fire, floods, accidents, strikes, or shortages of transportation, facilities, fuel, energy, labor, or materials.\n\nThe affected party shall give prompt written notice to the other party and shall use commercially reasonable efforts to mitigate the effects of such event.',
                tags: ['force majeure', 'acts of god', 'excuse']
            },
            {
                clauseId: 'builtin-arb-1',
                title: 'Arbitration Clause',
                category: 'contracts',
                content: 'DISPUTE RESOLUTION. Any dispute, controversy, or claim arising out of or relating to this Agreement, or the breach, termination, or invalidity thereof, shall be settled by binding arbitration administered by the American Arbitration Association in accordance with its Commercial Arbitration Rules.\n\nThe arbitration shall be conducted by a single arbitrator mutually agreed upon by the parties, or if no agreement can be reached within {{days}} days, appointed by the AAA. The place of arbitration shall be {{city}}, {{state}}. The arbitrator\'s decision shall be final and binding, and judgment upon the award may be entered in any court having jurisdiction thereof.\n\nEach party shall bear its own costs and expenses, and the parties shall share equally the fees and expenses of the arbitrator.',
                tags: ['arbitration', 'dispute', 'aaa']
            },
            {
                clauseId: 'builtin-gov-1',
                title: 'Governing Law',
                category: 'contracts',
                content: 'GOVERNING LAW AND JURISDICTION. This Agreement shall be governed by and construed in accordance with the laws of the State of {{state}}, without giving effect to any choice or conflict of law provision or rule. Any legal action or proceeding arising out of or relating to this Agreement shall be brought exclusively in the federal or state courts located in {{county}} County, {{state}}, and each party irrevocably consents to the jurisdiction of such courts.',
                tags: ['governing law', 'jurisdiction', 'choice of law']
            },
            {
                clauseId: 'builtin-entire-1',
                title: 'Entire Agreement / Integration',
                category: 'contracts',
                content: 'ENTIRE AGREEMENT. This Agreement, together with all exhibits and schedules attached hereto, constitutes the entire agreement between the parties with respect to the subject matter hereof and supersedes all prior and contemporaneous agreements, representations, warranties, and understandings, whether written or oral, relating to such subject matter. No modification, amendment, or waiver of any provision of this Agreement shall be effective unless in writing and signed by both parties.',
                tags: ['entire agreement', 'integration', 'merger']
            },
            {
                clauseId: 'builtin-noc-1',
                title: 'Notice Provision',
                category: 'corporate',
                content: 'NOTICES. All notices, requests, demands, and other communications under this Agreement shall be in writing and shall be deemed to have been duly given:\n\n(a) on the date of delivery if delivered personally;\n(b) on the date of transmission if sent via facsimile or email with confirmation of receipt;\n(c) on the business day after dispatch if sent by nationally recognized overnight courier;\n(d) on the fifth business day after mailing if sent by registered or certified mail, return receipt requested, postage prepaid.\n\nNotices shall be sent to the addresses set forth in the signature block, or to such other address as either party may designate in writing.',
                tags: ['notice', 'communications', 'service']
            },
            {
                clauseId: 'builtin-assign-1',
                title: 'Assignment Clause',
                category: 'corporate',
                content: 'ASSIGNMENT. Neither party may assign, transfer, or delegate any of its rights or obligations under this Agreement without the prior written consent of the other party, which consent shall not be unreasonably withheld, conditioned, or delayed. Notwithstanding the foregoing, either party may assign this Agreement without consent to (a) an affiliate, or (b) a successor in interest in connection with a merger, acquisition, or sale of all or substantially all of its assets. Any purported assignment in violation of this section shall be null and void.',
                tags: ['assignment', 'transfer', 'delegation']
            }
        ];

        // Library Functions
        async function loadClauses() {
            const statusEl = document.getElementById('library-status');

            try {
                statusEl.textContent = 'Fetching clauses...';
                
                const response = await fetch(`${API}/firms/${FIRM}/clauses`, {
                    headers: apiHeaders()
                });
                if (!response.ok) throw new Error('Failed to fetch');
                
                const data = await response.json();
                
                // Validate response is an array
                if (!Array.isArray(data)) {
                    throw new Error('Invalid response format');
                }
                
                // Validate each clause has required fields, filter malformed ones
                allClauses = data.filter(clause => 
                    clause && 
                    typeof clause.clauseId === 'string' &&
                    typeof clause.title === 'string' &&
                    typeof clause.content === 'string'
                );
                
                // If no clauses from API, use built-in library
                if (allClauses.length === 0) {
                    allClauses = [...BUILT_IN_CLAUSES];
                    statusEl.textContent = `${allClauses.length} sample clauses loaded`;
                } else {
                    statusEl.textContent = `${allClauses.length} clauses loaded`;
                }
                statusEl.classList.remove('error');

                renderClauses();

            } catch (err) {
                console.error('Load failed:', err);
                // Fallback to built-in clauses on error
                allClauses = [...BUILT_IN_CLAUSES];
                statusEl.textContent = `${allClauses.length} sample clauses (offline mode)`;
                statusEl.classList.remove('error');
                renderClauses();
            }
        }

        function setCategory(category) {
            currentCategory = category;
            document.querySelectorAll('.filter-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.filter === category);
            });
            filterClauses();
        }

        function filterClauses() {
            const searchTerm = document.getElementById('search').value.toLowerCase();
            
            const filtered = allClauses.filter(clause => {
                const matchesCategory = currentCategory === 'all' || clause.category === currentCategory;
                const matchesSearch = !searchTerm || 
                    clause.title.toLowerCase().includes(searchTerm) ||
                    clause.content.toLowerCase().includes(searchTerm) ||
                    (clause.tags || []).some(tag => tag.toLowerCase().includes(searchTerm));
                return matchesCategory && matchesSearch;
            });
            
            renderClauses(filtered);
            
            const statusEl = document.getElementById('library-status');
            if (searchTerm || currentCategory !== 'all') {
                statusEl.textContent = `${filtered.length} of ${allClauses.length} clauses`;
            } else {
                statusEl.textContent = `${allClauses.length} clauses loaded`;
            }
        }

        // Virtualized clause rendering - only render visible items
        const CLAUSES_PER_PAGE = 20;
        let currentClauseList = [];
        let renderedCount = 0;

        function renderClauses(clauses = allClauses) {
            const clausesEl = document.getElementById('clauses');
            currentClauseList = clauses;
            renderedCount = 0;
            
            if (clauses.length === 0) {
                const searchTerm = document.getElementById('search').value.trim();
                const isFiltered = currentCategory !== 'all';
                const hasAnyClauses = allClauses.length > 0;

                let emptyTitle, emptyDesc, emptyAction;

                if (searchTerm && isFiltered) {
                    // Searching within a category
                    emptyTitle = 'No matching clauses';
                    emptyDesc = `No ${currentCategory} clauses match "${searchTerm}". Try a broader search or switch categories.`;
                    emptyAction = `<button class="btn btn-sm" onclick="document.getElementById('search').value='';setCategory('all')">Clear filters</button>`;
                } else if (searchTerm) {
                    // Searching across all categories
                    emptyTitle = 'No results found';
                    emptyDesc = `No clauses match "${searchTerm}". Try different keywords or check spelling.`;
                    emptyAction = `<button class="btn btn-sm" onclick="document.getElementById('search').value='';filterClauses()">Clear search</button>`;
                } else if (isFiltered) {
                    // Category filter with no results
                    emptyTitle = `No ${currentCategory} clauses`;
                    emptyDesc = `Your library doesn't have any ${currentCategory} clauses yet. Save highlighted text from a document or switch categories.`;
                    emptyAction = `<button class="btn btn-sm" onclick="setCategory('all')">Show all clauses</button>`;
                } else if (!hasAnyClauses) {
                    // Completely empty library
                    emptyTitle = 'Your clause library is empty';
                    emptyDesc = 'Highlight text in your document, then use Settings > Save Highlighted Text to build your library.';
                    emptyAction = `<button class="btn btn-sm" onclick="switchPanel('admin')">Go to Settings</button>`;
                } else {
                    emptyTitle = 'No clauses found';
                    emptyDesc = 'Try adjusting your search or filters.';
                    emptyAction = '';
                }

                clausesEl.innerHTML = `
                    <div class="empty-state empty-state--centered">
                        <div class="empty-title">${emptyTitle}</div>
                        <div class="empty-desc">${emptyDesc}</div>
                        ${emptyAction}
                    </div>
                `;
                return;
            }

            // Clear and render first batch
            clausesEl.innerHTML = '';
            renderMoreClauses();
            
            // Setup scroll listener for lazy loading
            clausesEl.onscroll = () => {
                if (clausesEl.scrollTop + clausesEl.clientHeight >= clausesEl.scrollHeight - 100) {
                    renderMoreClauses();
                }
            };
        }

        function renderMoreClauses() {
            if (renderedCount >= currentClauseList.length) return;
            
            const clausesEl = document.getElementById('clauses');
            const batch = currentClauseList.slice(renderedCount, renderedCount + CLAUSES_PER_PAGE);
            
            const fragment = document.createDocumentFragment();
            batch.forEach(clause => {
                const div = document.createElement('div');
                div.className = 'clause';
                div.innerHTML = `
                    <div class="clause-header">
                        <div class="clause-title">${escapeHtml(clause.title)}</div>
                        <span class="clause-category ${escapeHtml(clause.category || 'contracts')}">${escapeHtml(clause.category || 'contracts')}</span>
                    </div>
                    <div class="clause-content">${escapeHtml(clause.content)}</div>
                    <button class="btn" data-clause-id="${escapeHtml(clause.clauseId)}">Insert</button>
                `;
                // Add click handler (safer than inline onclick)
                const btn = div.querySelector('button');
                btn.addEventListener('click', function() {
                    insertClause(clause.clauseId, this);
                });
                fragment.appendChild(div);
            });
            
            clausesEl.appendChild(fragment);
            renderedCount += batch.length;
            
            // Show load more indicator if there are more
            if (renderedCount < currentClauseList.length) {
                const existing = clausesEl.querySelector('.load-more-indicator');
                if (!existing) {
                    const indicator = document.createElement('div');
                    indicator.className = 'load-more-indicator';
                    indicator.textContent = `Scroll for more (${currentClauseList.length - renderedCount} remaining)`;
                    indicator.style.cssText = 'text-align:center;padding:12px;color:#888;font-size:12px;';
                    clausesEl.appendChild(indicator);
                }
            } else {
                const indicator = clausesEl.querySelector('.load-more-indicator');
                if (indicator) indicator.remove();
            }
        }

        async function insertClause(clauseId, btn) {
            const clause = allClauses.find(c => c.clauseId === clauseId);
            if (!clause) {
                toast('Clause not found. Try refreshing the library.', 'error');
                return;
            }
            
            if (btn.disabled) return; // Prevent double-clicks
            
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.style.opacity = '0.7';
            btn.textContent = 'Inserting...';

            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.insertText(clause.content, Word.InsertLocation.replace);
                    await context.sync();
                });

                btn.textContent = 'Done!';
                btn.classList.add('success');
                btn.style.opacity = '';
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('success');
                    btn.disabled = false;
                }, 1500);

            } catch (err) {
                console.error('Insert failed:', err);
                btn.textContent = 'Error';
                btn.style.opacity = '';
                toast(friendlyError(err, 'Could not insert clause. Click in your document and try again.'), 'error');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // ENCRYPTION - AES-256-GCM (Military Grade)
        // ═══════════════════════════════════════════════════════════════
        
        function showEncryptModal() {
            document.getElementById('encrypt-password').value = '';
            document.getElementById('encrypt-password-confirm').value = '';
            document.getElementById('encrypt-modal').classList.remove('hidden');
        }
        
        function hideEncryptModal() {
            document.getElementById('encrypt-modal').classList.add('hidden');
        }
        
        function showDecryptModal() {
            document.getElementById('decrypt-password').value = '';
            document.getElementById('decrypt-file').value = '';
            document.getElementById('decrypt-modal').classList.remove('hidden');
        }
        
        function hideDecryptModal() {
            document.getElementById('decrypt-modal').classList.add('hidden');
        }
        
        // Derive AES-256 key from password using PBKDF2
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000, // High iteration count for security
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 }, // AES-256
                false,
                ['encrypt', 'decrypt']
            );
        }
        
        // Encrypt data with AES-256-GCM
        async function encryptData(plaintext, password) {
            const encoder = new TextEncoder();
            const salt = crypto.getRandomValues(new Uint8Array(16)); // 128-bit salt
            const iv = crypto.getRandomValues(new Uint8Array(12));   // 96-bit IV for GCM
            
            const key = await deriveKey(password, salt);
            
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                encoder.encode(plaintext)
            );
            
            // Combine: salt (16) + iv (12) + ciphertext
            const combined = new Uint8Array(salt.length + iv.length + encrypted.byteLength);
            combined.set(salt, 0);
            combined.set(iv, salt.length);
            combined.set(new Uint8Array(encrypted), salt.length + iv.length);
            
            return combined;
        }
        
        // Decrypt data with AES-256-GCM
        async function decryptData(encryptedData, password) {
            const salt = encryptedData.slice(0, 16);
            const iv = encryptedData.slice(16, 28);
            const ciphertext = encryptedData.slice(28);
            
            const key = await deriveKey(password, salt);
            
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                ciphertext
            );
            
            return new TextDecoder().decode(decrypted);
        }
        
        // Export encrypted document
        async function encryptAndExport() {
            const password = document.getElementById('encrypt-password').value;
            const confirm = document.getElementById('encrypt-password-confirm').value;
            
            if (!password) {
                toast('Please enter a password', 'error');
                return;
            }
            
            if (password !== confirm) {
                toast('Passwords do not match', 'error');
                return;
            }
            
            if (password.length < 8) {
                toast('Password must be at least 8 characters', 'error');
                return;
            }
            
            // Find the encrypt button and lock it
            const btn = document.querySelector('#encrypt-modal .btn:not(.secondary)');
            
            await withButtonLock(btn, async () => {
                toast('Encrypting document...', 'info');
                
                try {
                    await Word.run(async (context) => {
                        // Get document content
                        const body = context.document.body;
                        body.load('text');
                        await context.sync();
                        
                        const content = body.text;
                        
                        if (!content || content.trim().length === 0) {
                            throw new Error('Document is empty. Add some content before encrypting.');
                        }
                        
                        // Create document package with metadata
                        const docPackage = JSON.stringify({
                            version: 1,
                            type: 'draftbridge-encrypted',
                            timestamp: new Date().toISOString(),
                            content: content
                        });
                        
                        // Encrypt with AES-256-GCM
                        const encrypted = await encryptData(docPackage, password);
                        
                        // Create downloadable file
                        const blob = new Blob([encrypted], { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        
                        // Generate filename
                        const filename = `document_${Date.now()}.docx.enc`;
                        
                        // Trigger download
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        hideEncryptModal();
                        toast('Encrypted document downloaded', 'success');
                    });
                } catch (err) {
                    console.error('Encryption error:', err);
                    toast(friendlyError(err, 'Encryption failed'), 'error');
                }
            }, 'Encrypting...');
        }
        
        // Decrypt and insert document
        async function decryptAndOpen() {
            const fileInput = document.getElementById('decrypt-file');
            const password = document.getElementById('decrypt-password').value;
            
            if (!fileInput.files || !fileInput.files[0]) {
                toast('Please select an encrypted file', 'error');
                return;
            }
            
            if (!password) {
                toast('Please enter the password', 'error');
                return;
            }
            
            // Find the decrypt button and lock it
            const btn = document.querySelector('#decrypt-modal .btn:not(.secondary)');
            
            await withButtonLock(btn, async () => {
                toast('Decrypting...', 'info');
                
                try {
                    const file = fileInput.files[0];
                    const arrayBuffer = await file.arrayBuffer();
                    const encryptedData = new Uint8Array(arrayBuffer);
                    
                    // Decrypt
                    const decrypted = await decryptData(encryptedData, password);
                    const docPackage = JSON.parse(decrypted);
                    
                    // Verify it's a DraftBridge encrypted file
                    if (docPackage.type !== 'draftbridge-encrypted') {
                        throw new Error('This doesn\'t look like a DraftBridge encrypted file. Make sure you selected the right .enc file.');
                    }
                    
                    // Insert into document (safe: only clear after validating content)
                    await Word.run(async (context) => {
                        const body = context.document.body;
                        const content = docPackage.content;
                        
                        // Validate content exists before clearing
                        if (!content || typeof content !== 'string') {
                            throw new Error('The decrypted file appears to be empty.');
                        }
                        
                        // Save current content in case we need to warn user
                        body.load('text');
                        await context.sync();
                        const hadContent = body.text.trim().length > 0;
                        
                        // Only clear and insert if we have valid content to insert
                        body.clear();
                        body.insertText(content, Word.InsertLocation.start);
                        await context.sync();
                        
                        // If we get here, insert succeeded
                        if (hadContent) {
                            // Document content replaced with decrypted content
                        }
                    });
                    
                    hideDecryptModal();
                    toast('Document decrypted and loaded', 'success');
                    
                } catch (err) {
                    console.error('Decryption error:', err);
                    toast(friendlyError(err, 'Decryption failed'), 'error');
                }
            }, 'Decrypting...');
        }

        // ═══════════════════════════════════════════════════════════════
        // VOICE CONTROL
        // ═══════════════════════════════════════════════════════════════
        
        let recognition = null;
        let isListening = false;
        let favoriteClausesCache = [];
        
        // Initialize speech recognition
        function initVoiceControl() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                // Speech recognition not supported in this environment
                // Hide voice control option if not supported
                const voiceCards = document.querySelectorAll('[onclick*="Voice"]');
                voiceCards.forEach(card => card.style.display = 'none');
                return;
            }
            
            // Check if we're in Word add-in context
            const isWordAddin = typeof Office !== 'undefined' && Office.context;
            // Voice control initialized
            
            try {
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                isListening = true;
                document.getElementById('voice-icon').classList.add('listening');
                document.getElementById('voice-text').textContent = 'Listening...';
                document.getElementById('voice-btn').textContent = 'Stop';
            };
            
            recognition.onend = () => {
                isListening = false;
                document.getElementById('voice-icon').classList.remove('listening');
                document.getElementById('voice-text').textContent = 'Press to speak...';
                document.getElementById('voice-btn').textContent = 'Start Listening';
            };
            
            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // Show transcript
                const transcriptEl = document.getElementById('voice-transcript');
                transcriptEl.classList.add('active');
                transcriptEl.textContent = finalTranscript || interimTranscript;
                
                // Process final transcript
                if (finalTranscript) {
                    processVoiceCommand(finalTranscript.toLowerCase().trim());
                }
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                let errorMsg = 'Error: ' + event.error;
                
                if (event.error === 'not-allowed') {
                    errorMsg = 'Microphone access denied. Check Word permissions.';
                } else if (event.error === 'no-speech') {
                    errorMsg = 'No speech detected. Try again.';
                } else if (event.error === 'network') {
                    errorMsg = 'Network error. Speech may require internet.';
                } else if (event.error === 'service-not-allowed') {
                    errorMsg = 'Speech service not available in this Office version.';
                }
                
                showVoiceAction(errorMsg, true);
            };
            
            } catch (initError) {
                console.error('Failed to initialize speech recognition:', initError);
                return;
            }
            
            // Keyboard shortcut: Ctrl+Shift+V
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'V') {
                    e.preventDefault();
                    toggleVoiceWindow();
                }
            });
            
            // Cache favorite clauses for voice commands
            loadFavoriteClauses();
        }
        
        function loadFavoriteClauses() {
            // Get favorites from localStorage or use sample
            const favorites = localStorage.getItem('draftbridge_favorites');
            if (favorites) {
                try {
                    favoriteClausesCache = JSON.parse(favorites);
                } catch (e) {
                    console.error('Failed to parse favorites:', e);
                    favoriteClausesCache = [];
                }
            } else {
                // Demo favorites
                favoriteClausesCache = [
                    { id: 1, title: 'Indemnification', content: 'Party A shall indemnify and hold harmless Party B...' },
                    { id: 2, title: 'Confidentiality', content: 'All information shared between the parties shall remain confidential...' },
                    { id: 3, title: 'Force Majeure', content: 'Neither party shall be liable for any failure or delay...' },
                    { id: 4, title: 'Governing Law', content: 'This Agreement shall be governed by the laws of the State of California...' },
                    { id: 5, title: 'Severability', content: 'If any provision of this Agreement is held to be invalid...' }
                ];
            }
        }
        
        function toggleVoiceWindow() {
            const window = document.getElementById('voice-control');
            if (window.classList.contains('hidden')) {
                window.classList.remove('hidden');
                if (!isListening && recognition) {
                    recognition.start();
                }
            } else {
                closeVoiceControl();
            }
        }
        
        function closeVoiceControl() {
            document.getElementById('voice-control').classList.add('hidden');
            if (isListening && recognition) {
                recognition.stop();
            }
            // Clear displays
            document.getElementById('voice-transcript').classList.remove('active');
            document.getElementById('voice-action').classList.remove('active');
        }
        
        async function toggleVoiceListening() {
            if (!recognition) {
                showVoiceAction('Voice control not available. Requires Office 365/2021+ on Windows.', true);
                return;
            }
            
            if (isListening) {
                recognition.stop();
            } else {
                try {
                    // Request microphone permission explicitly first
                    // This triggers the browser/OS permission prompt
                    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            // Permission granted - stop the stream (SpeechRecognition will create its own)
                            stream.getTracks().forEach(track => track.stop());
                            // Microphone permission granted
                        } catch (permErr) {
                            console.error('Microphone permission denied:', permErr);
                            if (permErr.name === 'NotAllowedError') {
                                showVoiceAction('Microphone blocked. In Windows: Settings → Privacy → Microphone → Allow desktop apps', true);
                                return;
                            } else if (permErr.name === 'NotFoundError') {
                                showVoiceAction('No microphone found. Check your audio devices.', true);
                                return;
                            }
                        }
                    }
                    
                    recognition.start();
                } catch (err) {
                    console.error('Failed to start recognition:', err);
                    if (err.message.includes('already started')) {
                        recognition.stop();
                        setTimeout(() => recognition.start(), 100);
                    } else {
                        showVoiceAction('Could not start voice recognition. Try closing and reopening.', true);
                    }
                }
            }
        }
        
        function showVoiceAction(message, isError = false) {
            const actionEl = document.getElementById('voice-action');
            actionEl.textContent = message;
            actionEl.classList.add('active');
            actionEl.classList.toggle('error', isError);
            
            // Auto-hide success messages
            if (!isError) {
                setTimeout(() => {
                    actionEl.classList.remove('active');
                }, 3000);
            }
        }

        function showVoiceHelp() {
            const helpHtml = `
                <div style="font-size:12px;line-height:1.6;">
                    <strong>Voice Commands:</strong><br>
                    <br>
                    <strong>Create:</strong><br>
                    • "Letter to [name]"<br>
                    • "Memo to [name]"<br>
                    <br>
                    <strong>Insert:</strong><br>
                    • "Insert [clause name]"<br>
                    • "Add signature"<br>
                    • "Add closing"<br>
                    • "Today's date"<br>
                    <br>
                    <strong>Navigate:</strong><br>
                    • "Go to library"<br>
                    • "Go to generate"<br>
                    • "Go to numbering"<br>
                    <br>
                    <strong>Numbering:</strong><br>
                    • "Legal outline"<br>
                    • "Contract style"<br>
                    <br>
                    • "Close" to exit
                </div>
            `;
            const actionEl = document.getElementById('voice-action');
            actionEl.innerHTML = helpHtml;
            actionEl.classList.add('active');
            actionEl.classList.remove('error');
        }
        
        // Help dialog (Evvie UX fix - prominent help access)
        function showHelpDialog() {
            const helpContent = `
                <div class="modal-overlay" id="help-modal" onclick="if(event.target===this)this.remove()">
                    <div class="help-modal-content">
                        <h2>DraftBridge Help</h2>
                        <div class="help-sections">
                            <div class="help-section">
                                <h3>Quick Start</h3>
                                <ul>
                                    <li><strong>Generate Documents:</strong> Use the Generate tab to create letters, memos, and faxes</li>
                                    <li><strong>Insert Clauses:</strong> Browse the Library tab for pre-written legal clauses</li>
                                    <li><strong>Templates:</strong> Create reusable templates in Settings → Template Editor</li>
                                    <li><strong>Voice Control:</strong> Click Voice and speak commands like "Insert clause"</li>
                                </ul>
                            </div>
                            <div class="help-section">
                                <h3>Support</h3>
                                <p><strong>Email:</strong> support@draftbridge.com</p>
                                <p><strong>Phone:</strong> 1-800-DRAFTS (Mon-Fri 9am-5pm EST)</p>
                                <p><strong>Version:</strong> 0.5.2</p>
                            </div>
                            <div class="help-section">
                                <h3>Common Questions</h3>
                                <ul>
                                    <li><strong>Variables:</strong> Use {{ClientName}} syntax in templates - you'll be prompted to fill these in</li>
                                    <li><strong>Saving:</strong> Click "Save Template" when done — you'll see "Saved" confirmation</li>
                                    <li><strong>Numbering:</strong> Use the Numbering tab to apply legal outline formats</li>
                                </ul>
                            </div>
                        </div>
                        <button class="btn primary" onclick="document.getElementById('help-modal').remove()">Close</button>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', helpContent);
        }
        
        // Clean filler words from voice input
        function cleanVoiceInput(text) {
            // Comprehensive filler list (287 items) - sorted longest first for proper replacement
            const fillers = [
                // Compound/long phrases first
                "if it's not too much trouble", "i would appreciate if you", "i'd appreciate it if you",
                "i was wondering if you could", "i was hoping you could", "it would be great if you could",
                "hold on let me start again", "it's on the tip of my tongue", "you hear what i'm saying",
                "that's not what i meant", "or something like that", "and stuff like that",
                "and things like that", "know what i'm saying", "that came out wrong",
                "be so kind as to", "when you get a chance", "for your information",
                "here's the situation", "let me start over", "what i meant was",
                "to put it another way", "know what i mean", "see what i mean",
                "forget what i said", "here's what i need", "okay so basically",
                "first things first", "what i need is", "what i want is",
                "do me a favor and", "be a dear and", "i'm looking to",
                "let me try again", "that's not right", "in other words",
                "here's the thing", "the thing is", "that is to say",
                "for the most part", "i think that's it", "that should do it",
                "that will be all", "and that's it", "please and thank you",
                "thank you very much", "thanks so much", "much appreciated",
                "i appreciate it", "good morning", "good afternoon", "good evening",
                "wait wait wait", "no no no", "well well well", "boy oh boy",
                "man oh man", "oh my god", "oh my gosh", "good grief", "good lord",
                "bloody hell", "dear me", "my goodness", "i beg your pardon",
                "yadda yadda yadda", "yada yada yada", "blah blah blah",
                "and so forth", "and so on", "over and out",
                // Medium phrases
                "i would like to", "i'd like you to", "i would like you to", "i'd like to",
                "i want you to", "i need you to", "go ahead and", "let me see",
                "let me think", "let me check", "give me a second", "give me a sec",
                "gimme a sec", "one moment", "one second", "just a moment",
                "just a second", "just a sec", "hold on", "hang on",
                "wait a minute", "wait a second", "wait a sec", "bear with me",
                "what was it", "what is it", "what's it called", "how do i say this",
                "how should i put this", "how do i put this", "what's the word",
                "let me recall", "trying to remember", "oh what is it",
                "i'm thinking", "scratch that", "never mind", "nevermind",
                "forget that", "ignore that", "disregard that", "let me rephrase",
                "or rather", "actually no", "no wait", "wait wait", "no no",
                "sorry i meant", "not that", "the other one", "i mean",
                "okay thanks", "got it", "sounds good", "sure thing", "you bet",
                "copy that", "that's all", "that's it", "that'll do",
                "i see", "oh i see", "oh right", "oh okay", "oh yeah", "oh yes", "ah yes",
                "come again", "say again", "repeat that", "excuse me",
                "by the way", "oh by the way", "here's the deal",
                "i was like", "he was like", "she was like", "they were like",
                "and i was like", "and then like", "you know like", "like basically",
                "basically like", "well basically", "so basically", "so anyway",
                "but anyway", "anyway so", "so yeah", "but yeah", "and yeah",
                "yeah so", "yeah and", "yeah but", "i dunno", "i don't know",
                "who knows", "eh whatever", "i guess so", "if you say so",
                "if you want", "if you like", "as you wish", "as you please",
                "or whatever", "and whatnot", "and stuff", "and things",
                "type thing", "type of", "sorta like", "kinda like",
                "no worries", "no problem", "no prob", "no probs", "nae bother",
                "fair enough", "fair play", "you get me", "you feel me",
                "feel me", "ya dig", "got it right", "right mate",
                "you see", "d'you see", "you understand", "nah mean",
                // Short phrases
                "i want to", "i wanna", "i need to", "allow me to", "help me to",
                "help me", "i'm trying to", "i'm gonna", "i'm going to",
                "i am going to", "i wish to", "i intend to", "i plan to",
                "can i", "may i", "might i", "shall i", "should i",
                "can you", "could you", "would you", "will you", "would you mind",
                "do you mind", "if you could", "if you would", "if you don't mind",
                "if possible", "if you can", "i think", "i believe", "i feel like",
                "in my opinion", "as it were", "if you will", "so to speak",
                "more or less", "pretty much", "i guess", "i suppose", "i reckon",
                "right then", "now then", "okay so", "ok so", "right so",
                "well then", "and then", "after that", "following that",
                "let's see", "let's go", "here we go", "here goes",
                "to start", "to begin", "to begin with", "for starters",
                "first of all", "moving on", "um like", "uh like", "so like",
                "and like", "but like", "it's like",
                // Single/short words
                "um", "umm", "ummm", "uh", "uhh", "uhhh", "er", "err", "errr",
                "ah", "ahh", "ahhh", "eh", "ehh", "hm", "hmm", "hmmm",
                "mhm", "mm", "mmm", "erm", "ur", "like", "you know", "y'know",
                "ya know", "basically", "actually", "literally", "kind of", "kinda",
                "sort of", "sorta", "honestly", "frankly", "really", "truly",
                "essentially", "fundamentally", "obviously", "clearly", "apparently",
                "presumably", "supposedly", "technically", "virtually", "practically",
                "just", "simply", "maybe", "perhaps", "probably", "possibly",
                "definitely", "certainly", "surely", "right", "please", "thanks",
                "thank you", "cheers", "ta", "kindly", "so", "well", "okay", "ok", "k",
                "okey dokey", "okie dokie", "alright", "all right", "aight", "a'ight",
                "now", "anyway", "anyways", "anyhow", "anywho", "next", "first",
                "firstly", "then", "alrighty", "righty", "righty-ho", "righto",
                "thinking", "correction", "rather", "sorry", "oops", "my bad",
                "wrong", "whoops", "yeah", "yep", "yup", "ya", "yah", "uh huh",
                "uh-huh", "mm-hmm", "mmhmm", "cool", "great", "awesome", "perfect",
                "wonderful", "fantastic", "excellent", "good", "nice", "sweet",
                "brilliant", "lovely", "cheers mate", "thanks mate", "ta mate",
                "much obliged", "period", "full stop", "done", "end", "over",
                "roger", "understood", "affirmative", "sure", "absolutely",
                "hey", "hi", "hello", "hiya", "howdy", "yo", "sup", "what's up",
                "greetings", "hey there", "hi there", "hello there", "dear",
                "buddy", "pal", "friend", "mate", "dude", "bro", "man", "fam",
                "folks", "y'all", "you guys", "listen", "look", "see", "fyi",
                "btw", "incidentally", "innit", "ain't it", "isn't it",
                "comprende", "capisce", "get it", "dig", "reckon", "methinks",
                "fixin to", "fixing to", "about to", "boutta", "finna", "gonna",
                "gotta", "wanna", "hafta", "oughta", "shoulda", "coulda", "woulda",
                "mighta", "musta", "or something", "et cetera", "etc",
                "uh oh", "oh", "ohh", "ooh", "aah", "whoa", "wow", "gee", "gosh",
                "golly", "jeez", "geez", "crikey", "blimey", "goodness", "oh my",
                "omg", "heavens", "lord", "lordy", "huh", "what", "pardon",
                "whatever", "whatevs", "whatev", "meh", "idk", "ima", "imma", "lemme"
            ];
            
            let cleaned = text.toLowerCase().trim();
            
            // Remove fillers (longest first, with word boundaries)
            fillers.forEach(filler => {
                const escaped = filler.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp(`\\b${escaped}\\b`, 'gi');
                cleaned = cleaned.replace(regex, ' ');
            });
            
            // Clean up multiple spaces
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            
            // Remove leading/trailing articles
            cleaned = cleaned.replace(/^(the|a|an|this|that|my|your|our|their)\s+/i, '');
            cleaned = cleaned.replace(/\s+(the|a|an)$/i, '');
            
            // Voice input cleaned
            return cleaned;
        }
        
        // Command aliases for flexibility
        const VOICE_ALIASES = {
            'add': 'insert', 'put in': 'insert', 'include': 'insert',
            'provision': 'clause', 'section': 'clause',
            'correspondence': 'letter', 'mail': 'letter',
            'memorandum': 'memo', 'internal memo': 'memo',
            'clauses': 'library', 'saved clauses': 'library',
            'create': 'generate', 'new document': 'generate', 'templates': 'generate',
            'sign': 'signature', 'my name': 'signature',
            'today': 'date', 'current date': 'date', 'todays date': 'date',
            'sincerely': 'closing', 'regards': 'closing'
        };

        function applyAliases(cmd) {
            let result = cmd;
            for (const [alias, canonical] of Object.entries(VOICE_ALIASES)) {
                if (result.includes(alias)) {
                    result = result.replace(alias, canonical);
                }
            }
            return result;
        }

        // Process voice commands
        function processVoiceCommand(rawCommand) {
            let command = cleanVoiceInput(rawCommand);
            command = applyAliases(command);
            // Voice command processed

            // Help command
            if (command === 'help' || command === 'commands' || command === 'what can i say') {
                showVoiceHelp();
                return;
            }
            
            // Letter commands
            if (command.includes('letter to') || command.includes('begin a letter') || command.includes('start a letter')) {
                const clientMatch = command.match(/letter to (.+)/);
                const clientName = clientMatch ? clientMatch[1] : null;
                createLetterFromVoice(clientName);
                return;
            }
            
            // Memo commands
            if (command.includes('memo to') || command.includes('start a memo') || command.includes('begin a memo')) {
                const recipientMatch = command.match(/memo to (.+)/);
                const recipient = recipientMatch ? recipientMatch[1] : null;
                createMemoFromVoice(recipient);
                return;
            }
            
            // Clause insertion with placement options
            if (command.includes('insert') && (command.includes('clause') || command.includes('at cursor') || command.includes('at end') || command.includes('at beginning'))) {
                let placement = 'cursor'; // default
                if (command.includes('at end') || command.includes('at the end')) placement = 'end';
                if (command.includes('at beginning') || command.includes('at the beginning') || command.includes('at start')) placement = 'start';
                
                const clauseMatch = command.match(/insert (.+?)(?:\s+at\s+(?:cursor|end|beginning|start|the))?$/);
                let clauseName = clauseMatch ? clauseMatch[1] : null;
                // Clean up clause name
                if (clauseName) {
                    clauseName = clauseName.replace(/\s*(clause|at cursor|at end|at beginning|at start|at the)$/gi, '').trim();
                }
                insertClauseFromVoice(clauseName, placement);
                return;
            }
            
            // Simple insert without "clause" keyword
            if (command.startsWith('insert ')) {
                const clauseName = command.replace('insert ', '').trim();
                insertClauseFromVoice(clauseName, 'cursor');
                return;
            }
            
            // Numbering commands
            if (command.includes('numbering') || command.includes('number style') || command.includes('outline')) {
                // Apply specific scheme
                if (command.includes('legal outline') || command.includes('legal numbering')) {
                    applyNumberingFromVoice('legal-outline');
                    return;
                }
                if (command.includes('contract') || command.includes('contract style')) {
                    applyNumberingFromVoice('contract-sections');
                    return;
                }
                if (command.includes('pleading') || command.includes('pleading style')) {
                    applyNumberingFromVoice('pleading-format');
                    return;
                }
                if (command.includes('heading') || command.includes('heading style')) {
                    applyNumberingFromVoice('heading-style');
                    return;
                }
                
                // Swap/change numbering
                if (command.includes('swap') || command.includes('change') || command.includes('switch')) {
                    showVoiceAction('Say a style: "legal outline", "contract", "pleading", or "heading"');
                    return;
                }
                
                // Go to numbering panel
                switchPanel('numbering');
                showVoiceAction('Opened Numbering panel');
                return;
            }
            
            // Quick actions
            if (command.includes('add closing') || command.includes('closing phrase')) {
                insertClosingFromVoice();
                return;
            }
            
            if (command.includes('add signature') || command.includes('signature block')) {
                insertSignatureFromVoice();
                return;
            }
            
            if (command.includes('today') || command.includes('date')) {
                insertDateFromVoice();
                return;
            }
            
            // Navigation
            if (command.includes('go to library') || command.includes('open library')) {
                switchPanel('library');
                showVoiceAction('Switched to Library');
                return;
            }
            
            if (command.includes('go to generate') || command.includes('open generate')) {
                switchPanel('generate');
                showVoiceAction('Switched to Generate');
                return;
            }
            
            if (command.includes('go to numbering') || command.includes('open numbering')) {
                switchPanel('numbering');
                showVoiceAction('Switched to Numbering');
                return;
            }
            
            if (command.includes('close') || command.includes('cancel') || command.includes('stop')) {
                closeVoiceControl();
                return;
            }
            
            // Unknown command
            showVoiceAction('Try: "insert [clause] at cursor", "legal outline", or "letter to [client]"', true);
        }
        
        async function createLetterFromVoice(clientName) {
            showVoiceAction('Creating letter' + (clientName ? ' for ' + clientName : ''));
            
            // Switch to generate panel and show letter form
            switchPanel('generate');
            showTemplate('letter');
            
            // If client name provided, try to fill it
            if (clientName) {
                setTimeout(() => {
                    const recipientField = document.getElementById('letter-recipient');
                    if (recipientField) {
                        recipientField.value = clientName;
                    }
                }, 100);
            }
            
            // Auto-close voice after successful action (paralegal feedback)
            setTimeout(() => closeVoiceControl(), 1500);
        }
        
        async function createMemoFromVoice(recipient) {
            showVoiceAction('Creating memo' + (recipient ? ' to ' + recipient : ''));
            
            switchPanel('generate');
            showTemplate('memo');
            
            // Auto-close voice after successful action
            setTimeout(() => closeVoiceControl(), 1500);
            
            if (recipient) {
                setTimeout(() => {
                    const toField = document.getElementById('memo-to');
                    if (toField) {
                        toField.value = recipient;
                    }
                }, 100);
            }
        }
        
        async function insertClauseFromVoice(clauseName, placement = 'cursor') {
            if (!clauseName) {
                showVoiceAction('Please specify a clause name', true);
                return;
            }
            
            // Fuzzy search favorites
            const matches = favoriteClausesCache.filter(c => 
                c.title.toLowerCase().includes(clauseName) ||
                clauseName.includes(c.title.toLowerCase())
            );
            
            if (matches.length === 0) {
                showVoiceAction('No matching clause found in favorites', true);
                return;
            }
            
            const clause = matches[0];
            
            try {
                await Word.run(async (context) => {
                    let target;
                    let location;
                    
                    if (placement === 'end') {
                        target = context.document.body;
                        location = Word.InsertLocation.end;
                    } else if (placement === 'start') {
                        target = context.document.body;
                        location = Word.InsertLocation.start;
                    } else {
                        // At cursor (default)
                        target = context.document.getSelection();
                        location = Word.InsertLocation.replace;
                    }
                    
                    target.insertText(clause.content, location);
                    await context.sync();
                });
                
                const placementText = placement === 'cursor' ? 'at cursor' : `at ${placement}`;
                showVoiceAction(`Inserted "${clause.title}" ${placementText}`);
                // Auto-close voice after successful insertion (paralegal feedback)
                setTimeout(() => closeVoiceControl(), 1500);
            } catch (err) {
                showVoiceAction('Failed to insert clause', true);
            }
        }
        
        // Apply numbering scheme from voice
        async function applyNumberingFromVoice(schemeId) {
            const schemeNames = {
                'legal-outline': 'Legal Outline',
                'contract-sections': 'Contract Sections',
                'pleading-format': 'Pleading Format',
                'heading-style': 'Heading Style'
            };
            
            const schemeName = schemeNames[schemeId] || schemeId;
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const paragraphs = selection.paragraphs;
                    paragraphs.load('items');
                    await context.sync();
                    
                    // Apply list formatting based on scheme
                    // Note: Full implementation would use Word's listItem API
                    // This is a simplified version that shows the concept
                    
                    if (paragraphs.items.length > 0) {
                        // For now, we'll switch to the numbering panel and select the scheme
                        // Full implementation would apply the actual Word list template
                    }
                    
                    await context.sync();
                });
                
                // Switch to numbering panel and select the scheme
                switchPanel('numbering');
                
                // Select the scheme card
                setTimeout(() => {
                    const card = document.querySelector(`[onclick*="${schemeId}"]`);
                    if (card) {
                        card.click();
                    }
                }, 100);
                
                showVoiceAction(`Applied: ${schemeName}`);
            } catch (err) {
                console.error('Numbering error:', err);
                showVoiceAction('Failed to apply numbering', true);
            }
        }
        
        async function insertClosingFromVoice() {
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.insertText('\n\nSincerely,\n\n', Word.InsertLocation.end);
                    await context.sync();
                });
                showVoiceAction('Closing phrase added');
                setTimeout(() => closeVoiceControl(), 1500);
            } catch (err) {
                showVoiceAction('Failed to insert closing', true);
            }
        }
        
        async function insertSignatureFromVoice() {
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.insertText('\n\n/s/ [Name]\n[Name]\n[Title]', Word.InsertLocation.end);
                    await context.sync();
                });
                showVoiceAction('Signature block added');
                setTimeout(() => closeVoiceControl(), 1500);
            } catch (err) {
                showVoiceAction('Failed to insert signature', true);
            }
        }
        
        async function insertDateFromVoice() {
            const today = new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.insertText(today, Word.InsertLocation.replace);
                    await context.sync();
                });
                showVoiceAction('Date inserted: ' + today);
                setTimeout(() => closeVoiceControl(), 1500);
            } catch (err) {
                showVoiceAction('Failed to insert date', true);
            }
        }
        
        // Initialize on load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initVoiceControl);
        } else {
            initVoiceControl();
        }
        
        // ========== OCR FUNCTIONS ==========
        
        let ocrResultText = null;
        const OCR_API = 'https://YOUR_OCR_API.execute-api.us-east-1.amazonaws.com/prod'; // TODO: Update after deployment
        
        function showOcrTool() {
            document.getElementById('ocr-modal').classList.remove('hidden');
            // Reset state
            document.getElementById('ocr-step-upload').style.display = 'block';
            document.getElementById('ocr-step-processing').style.display = 'none';
            document.getElementById('ocr-step-complete').style.display = 'none';
            document.getElementById('ocr-footer').style.display = 'flex';
            document.getElementById('ocr-file').value = '';
            document.getElementById('ocr-check-result').style.display = 'none';
            document.getElementById('ocr-process-btn').disabled = true;
            ocrResultUrl = null;
        }
        
        function hideOcrModal() {
            document.getElementById('ocr-modal').classList.add('hidden');
        }
        
        // Check if uploaded PDF is already searchable
        async function checkPdfSearchable() {
            const fileInput = document.getElementById('ocr-file');
            const resultDiv = document.getElementById('ocr-check-result');
            const processBtn = document.getElementById('ocr-process-btn');
            
            if (!fileInput.files || !fileInput.files[0]) {
                resultDiv.style.display = 'none';
                processBtn.disabled = true;
                return;
            }
            
            const file = fileInput.files[0];
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = '<div style="color: #666;">Checking if searchable...</div>';
            
            try {
                // Use pdf.js to check for text content
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                const page = await pdf.getPage(1);
                const textContent = await page.getTextContent();
                const text = textContent.items.map(item => item.str).join('').trim();
                
                if (text.length > 50) {
                    // Already searchable
                    resultDiv.innerHTML = `
                        <div style="background: #e8f5e9; padding: 12px; border-radius: 8px;">
                            <strong style="color: #2e7d32;">Already Searchable!</strong>
                            <p style="font-size: 12px; color: #666; margin-top: 4px;">
                                This PDF already has text content. No OCR needed.
                            </p>
                        </div>
                    `;
                    processBtn.disabled = true;
                } else {
                    // Needs OCR
                    resultDiv.innerHTML = `
                        <div style="background: #fff3e0; padding: 12px; border-radius: 8px;">
                            <strong style="color: #e65100;">Scanned Document Detected</strong>
                            <p style="font-size: 12px; color: #666; margin-top: 4px;">
                                This PDF appears to be scanned images. OCR will extract the text.
                            </p>
                            <p style="font-size: 11px; color: #999; margin-top: 8px;">
                                ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)
                            </p>
                        </div>
                    `;
                    processBtn.disabled = false;
                }
            } catch (err) {
                console.error('PDF check error:', err);
                // Assume it needs OCR if we can't check
                resultDiv.innerHTML = `
                    <div style="background: #fff3e0; padding: 12px; border-radius: 8px;">
                        <strong style="color: #e65100;">Could not analyze PDF</strong>
                        <p style="font-size: 12px; color: #666; margin-top: 4px;">
                            We'll try OCR processing.
                        </p>
                    </div>
                `;
                processBtn.disabled = false;
            }
        }
        
        // Process PDF with AWS Textract
        async function processOcr() {
            const fileInput = document.getElementById('ocr-file');
            if (!fileInput.files || !fileInput.files[0]) {
                toast('Please select a PDF file', 'error');
                return;
            }
            
            const file = fileInput.files[0];
            
            // Validate file size (max 10MB for now)
            if (file.size > 10 * 1024 * 1024) {
                toast('File too large. Max 10MB.', 'error');
                return;
            }
            
            // Show processing state
            document.getElementById('ocr-step-upload').style.display = 'none';
            document.getElementById('ocr-step-processing').style.display = 'block';
            document.getElementById('ocr-footer').style.display = 'none';
            
            const progressDiv = document.getElementById('ocr-progress');
            
            try {
                // Step 1: Get presigned URL for upload
                progressDiv.textContent = 'Getting upload URL...';
                const presignedResponse = await fetch(`${OCR_API}/ocr/presign`, {
                    method: 'POST',
                    headers: apiHeaders(),
                    body: JSON.stringify({
                        filename: file.name,
                        contentType: 'application/pdf',
                        firm: FIRM
                    })
                });
                
                if (!presignedResponse.ok) throw new Error('Failed to get upload URL');
                const { uploadUrl, key, jobId: uploadJobId } = await presignedResponse.json();
                
                // Step 2: Upload PDF to S3
                progressDiv.textContent = 'Uploading PDF...';
                const uploadResponse = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/pdf' },
                    body: file
                });
                
                if (!uploadResponse.ok) throw new Error('Failed to upload PDF');
                
                // Step 3: Start Textract processing
                progressDiv.textContent = 'Starting OCR processing...';
                const processResponse = await fetch(`${OCR_API}/ocr/process`, {
                    method: 'POST',
                    headers: apiHeaders(),
                    body: JSON.stringify({ key, firm: FIRM })
                });
                
                if (!processResponse.ok) throw new Error('Failed to start OCR');
                const { jobId } = await processResponse.json();
                
                // Step 4: Poll for completion
                progressDiv.textContent = 'Extracting text (this may take a minute)...';
                let status = 'IN_PROGRESS';
                let attempts = 0;
                const maxAttempts = 60; // 5 minutes max
                
                while (status === 'IN_PROGRESS' && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3 seconds
                    
                    const statusResponse = await fetch(`${OCR_API}/ocr/status?jobId=${jobId}`, {
                        headers: apiHeaders()
                    });
                    if (!statusResponse.ok) throw new Error('Failed to check status');
                    
                    const statusData = await statusResponse.json();
                    status = statusData.status;
                    
                    if (statusData.pages) {
                        progressDiv.textContent = `Processing ${statusData.pages} pages...`;
                    }
                    
                    attempts++;
                }
                
                if (status !== 'SUCCEEDED') {
                    throw new Error('OCR processing failed or timed out');
                }
                
                // Step 5: Get extracted text
                progressDiv.textContent = 'Retrieving extracted text...';
                const resultResponse = await fetch(`${OCR_API}/ocr/result?jobId=${jobId}`, {
                    headers: apiHeaders()
                });
                if (!resultResponse.ok) throw new Error('Failed to get result');
                
                const result = await resultResponse.json();
                ocrResultText = result.text;
                
                // Show stats
                document.getElementById('ocr-stats').textContent = 
                    `${result.pages} pages • ${result.lineCount} lines • ${result.confidence}% confidence`;
                
                // Show preview (first 1000 chars)
                const preview = result.text.length > 1000 
                    ? result.text.substring(0, 1000) + '\n\n... (truncated)'
                    : result.text;
                document.getElementById('ocr-text-preview').textContent = preview;
                
                // Show complete state
                document.getElementById('ocr-step-processing').style.display = 'none';
                document.getElementById('ocr-step-complete').style.display = 'block';
                
                toast('Text extracted successfully!', 'success');
                
            } catch (err) {
                console.error('OCR error:', err);
                toast('OCR failed: ' + err.message, 'error');
                
                // Reset to upload state
                document.getElementById('ocr-step-processing').style.display = 'none';
                document.getElementById('ocr-step-upload').style.display = 'block';
                document.getElementById('ocr-footer').style.display = 'flex';
            }
        }
        
        // Copy extracted text to clipboard
        function copyOcrText() {
            if (!ocrResultText) {
                toast('No text available', 'error');
                return;
            }
            navigator.clipboard.writeText(ocrResultText).then(() => {
                toast('Text copied to clipboard!', 'success');
            }).catch(err => {
                toast('Failed to copy: ' + err.message, 'error');
            });
        }
        
        // Insert extracted text into Word document
        async function insertOcrText() {
            if (!ocrResultText) {
                toast('No text available', 'error');
                return;
            }
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    selection.insertText(ocrResultText, Word.InsertLocation.replace);
                    await context.sync();
                });
                
                toast('Text inserted into document!', 'success');
                hideOcrModal();
            } catch (err) {
                toast('Insert failed: ' + err.message, 'error');
            }
        }
        
        // ========== FIX NUMBERING FUNCTIONS ==========
        
        // Store detected issues
        let numberingIssues = [];
        
        // Health badge state tracking
        let healthScanPending = false;
        let lastHealthScanTime = 0;
        const HEALTH_SCAN_DEBOUNCE = 3000; // 3 seconds minimum between auto-scans
        
        // Update the health badge UI based on current issues
        function updateHealthBadge(state, issueCount = 0) {
            const badge = document.getElementById('numbering-health-badge');
            const dot = document.getElementById('health-dot');
            const label = document.getElementById('health-label');
            
            if (!badge || !dot || !label) return;
            
            // Remove all state classes
            dot.classList.remove('healthy', 'issues', 'broken', 'scanning');
            label.classList.remove('healthy', 'issues', 'broken');
            
            switch (state) {
                case 'scanning':
                    dot.classList.add('scanning');
                    label.textContent = 'Scanning...';
                    badge.removeAttribute('data-tooltip');
                    break;
                    
                case 'healthy':
                    dot.classList.add('healthy');
                    label.classList.add('healthy');
                    label.textContent = 'Healthy';
                    badge.setAttribute('data-tooltip', 'All numbering looks good!');
                    break;
                    
                case 'issues':
                    dot.classList.add('issues');
                    label.classList.add('issues');
                    label.textContent = `${issueCount} Issue${issueCount !== 1 ? 's' : ''}`;
                    badge.setAttribute('data-tooltip', `Found ${issueCount} minor issue${issueCount !== 1 ? 's' : ''} — click to fix`);
                    break;
                    
                case 'broken':
                    dot.classList.add('broken');
                    label.classList.add('broken');
                    label.textContent = `${issueCount} Critical`;
                    badge.setAttribute('data-tooltip', `${issueCount} critical issue${issueCount !== 1 ? 's' : ''} need attention!`);
                    break;
                    
                default:
                    label.textContent = '—';
                    badge.removeAttribute('data-tooltip');
            }
        }
        
        // Handle health badge click - switch to Fix panel
        function onHealthBadgeClick() {
            // Find and click the Fix sub-nav button
            const fixBtn = document.querySelector('.sub-nav-btn:nth-child(2)');
            if (fixBtn) {
                // Update sub-nav buttons active state
                document.querySelectorAll('.sub-nav-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                fixBtn.classList.add('active');
                
                // Switch to fix panel
                document.getElementById('numbering-browse').classList.remove('active');
                document.getElementById('toc-browse').classList.remove('active');
                document.getElementById('fix-numbering').classList.add('active');
                document.getElementById('numbering-editor').classList.remove('active');
            }
            
            // If we have issues, they're already displayed
            // If not scanned yet, trigger a scan
            if (numberingIssues.length === 0 && document.getElementById('fix-initial').style.display !== 'none') {
                scanForNumberingIssues();
            }
        }
        
        // Auto-scan when entering the Numbering panel
        async function triggerHealthScan() {
            const now = Date.now();
            
            // Debounce: don't scan if we just did
            if (now - lastHealthScanTime < HEALTH_SCAN_DEBOUNCE) {
                return;
            }
            
            // Don't interrupt an active scan
            if (healthScanPending) return;
            
            healthScanPending = true;
            lastHealthScanTime = now;
            
            // Update badge to scanning state
            updateHealthBadge('scanning');
            
            try {
                await Word.run(async (context) => {
                    // Quick scan - similar to scanForNumberingIssues but lighter
                    const body = context.document.body;
                    const paragraphs = body.paragraphs;
                    paragraphs.load('items');
                    await context.sync();
                    
                    let issueCount = 0;
                    let criticalCount = 0;
                    let prevListLevel = -1;
                    let prevListNumber = 0;
                    
                    for (let i = 0; i < Math.min(paragraphs.items.length, 200); i++) { // Limit for speed
                        const para = paragraphs.items[i];
                        para.load(['text', 'listItemOrNullObject']);
                    }
                    await context.sync();
                    
                    for (let i = 0; i < Math.min(paragraphs.items.length, 200); i++) {
                        const para = paragraphs.items[i];
                        
                        if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                            const listItem = para.listItemOrNullObject;
                            listItem.load(['level', 'siblingIndex']);
                            await context.sync();
                            
                            const level = listItem.level;
                            const siblingIndex = listItem.siblingIndex;
                            
                            // Detect unexpected restarts
                            if (siblingIndex === 0 && prevListLevel === level && prevListNumber > 0) {
                                issueCount++;
                            }
                            
                            prevListLevel = level;
                            prevListNumber = siblingIndex;
                        } else {
                            // Check for manual numbering (orphaned)
                            const text = para.text.trim();
                            const manualPattern = /^(\d+\.|[a-z]\.|[A-Z]\.|[ivxIVX]+\.|\(\d+\)|\([a-z]\))\s/;
                            if (manualPattern.test(text)) {
                                issueCount++;
                            }
                            prevListLevel = -1;
                            prevListNumber = 0;
                        }
                    }
                    
                    // Update badge based on results
                    if (issueCount === 0) {
                        updateHealthBadge('healthy');
                    } else if (issueCount <= 3) {
                        updateHealthBadge('issues', issueCount);
                    } else {
                        updateHealthBadge('broken', issueCount);
                    }
                });
            } catch (err) {
                console.warn('Health scan failed:', err);
                updateHealthBadge('unknown');
            } finally {
                healthScanPending = false;
            }
        }
        
        // Scan document for numbering issues
        async function scanForNumberingIssues() {
            const scanBtn = document.getElementById('btn-scan');
            if (scanBtn.disabled) return; // Prevent double-clicks
            
            // Show scanning state in UI and health badge
            document.getElementById('fix-initial').style.display = 'none';
            document.getElementById('fix-scanning').style.display = 'block';
            document.getElementById('fix-clean').style.display = 'none';
            document.getElementById('fix-issues').style.display = 'none';
            document.getElementById('btn-fix-all').style.display = 'none';
            updateHealthBadge('scanning');
            
            scanBtn.disabled = true;
            scanBtn.style.opacity = '0.7';
            
            numberingIssues = [];
            
            try {
                await Word.run(async (context) => {
                    // Get all paragraphs in document
                    const body = context.document.body;
                    const paragraphs = body.paragraphs;
                    paragraphs.load('items');
                    await context.sync();
                    
                    // Track lists and their sequences
                    const listTracking = new Map(); // listId -> { lastNumber, items }
                    let prevListLevel = -1;
                    let prevListNumber = 0;
                    let prevListId = null;
                    let unexpectedRestarts = [];
                    let fragmentedLists = [];
                    let orphanedItems = [];
                    
                    for (let i = 0; i < paragraphs.items.length; i++) {
                        const para = paragraphs.items[i];
                        para.load(['text', 'style', 'listItem', 'listItemOrNullObject']);
                    }
                    await context.sync();
                    
                    // Analyze each paragraph
                    for (let i = 0; i < paragraphs.items.length; i++) {
                        const para = paragraphs.items[i];
                        
                        // Check if paragraph is in a list
                        if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                            const listItem = para.listItemOrNullObject;
                            listItem.load(['level', 'listString', 'siblingIndex']);
                            await context.sync();
                            
                            const level = listItem.level;
                            const listString = listItem.listString || '';
                            const siblingIndex = listItem.siblingIndex;
                            
                            // Detect unexpected restarts
                            // If siblingIndex is 0 and we had a previous item at same level with higher index
                            if (siblingIndex === 0 && prevListLevel === level && prevListNumber > 0) {
                                unexpectedRestarts.push({
                                    type: 'restart',
                                    index: i,
                                    text: para.text.substring(0, 50) + (para.text.length > 50 ? '...' : ''),
                                    level: level,
                                    listString: listString,
                                    prevNumber: prevListNumber
                                });
                            }
                            
                            prevListLevel = level;
                            prevListNumber = siblingIndex;
                        } else {
                            // Not a list item - check for orphaned numbering (manual numbers)
                            const text = para.text.trim();
                            const manualNumberPattern = /^(\d+\.|[a-z]\.|[A-Z]\.|[ivxIVX]+\.|\(\d+\)|\([a-z]\))\s/;
                            if (manualNumberPattern.test(text)) {
                                orphanedItems.push({
                                    type: 'orphaned',
                                    index: i,
                                    text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
                                    pattern: text.match(manualNumberPattern)[1]
                                });
                            }
                            
                            // Reset tracking when we hit non-list content
                            if (prevListLevel >= 0) {
                                fragmentedLists.push({
                                    endIndex: i - 1,
                                    level: prevListLevel
                                });
                            }
                            prevListLevel = -1;
                            prevListNumber = 0;
                        }
                    }
                    
                    // Build issues array
                    unexpectedRestarts.forEach((restart, idx) => {
                        numberingIssues.push({
                            id: 'restart-' + idx,
                            type: 'restart',
                            title: 'Unexpected Restart',
                            description: `Numbering restarts at "${restart.listString}" instead of continuing`,
                            location: `Near: "${restart.text}"`,
                            data: restart,
                            severity: 'warning'
                        });
                    });
                    
                    // Check for too many fragments (suggests broken list)
                    if (fragmentedLists.length > 3) {
                        numberingIssues.push({
                            id: 'fragmented',
                            type: 'fragmented',
                            title: 'Fragmented Lists',
                            description: `Found ${fragmentedLists.length} separate list fragments that may should be continuous`,
                            location: 'Throughout document',
                            data: fragmentedLists,
                            severity: 'info'
                        });
                    }
                    
                    orphanedItems.forEach((orphan, idx) => {
                        numberingIssues.push({
                            id: 'orphan-' + idx,
                            type: 'orphaned',
                            title: 'Manual Numbering Detected',
                            description: `"${orphan.pattern}" is typed manually, not using Word's list feature`,
                            location: `"${orphan.text}"`,
                            data: orphan,
                            severity: 'info'
                        });
                    });
                });
                
                // Display results
                displayScanResults();
                
            } catch (err) {
                console.error('Scan failed:', err);
                toast(friendlyError(err, 'Scan failed'), 'error');
                
                // Reset to initial state
                document.getElementById('fix-scanning').style.display = 'none';
                document.getElementById('fix-initial').style.display = 'block';
                
                // Reset health badge
                updateHealthBadge('unknown');
            } finally {
                // Re-enable scan button
                const scanBtn = document.getElementById('btn-scan');
                scanBtn.disabled = false;
                scanBtn.style.opacity = '';
            }
        }
        
        // Display scan results
        function displayScanResults() {
            document.getElementById('fix-scanning').style.display = 'none';
            
            if (numberingIssues.length === 0) {
                document.getElementById('fix-clean').style.display = 'block';
                document.getElementById('btn-scan').textContent = 'Scan Again';
                // Update health badge to healthy
                updateHealthBadge('healthy');
                return;
            }
            
            // Show issues
            document.getElementById('fix-issues').style.display = 'block';
            document.getElementById('fix-count').textContent = `Found ${numberingIssues.length} Issue${numberingIssues.length > 1 ? 's' : ''}`;
            document.getElementById('btn-fix-all').style.display = 'inline-flex';
            document.getElementById('btn-scan').textContent = 'Scan Again';
            
            // Update health badge based on issue count/severity
            const criticalIssues = numberingIssues.filter(i => i.type === 'restart').length;
            if (criticalIssues > 2 || numberingIssues.length > 5) {
                updateHealthBadge('broken', numberingIssues.length);
            } else {
                updateHealthBadge('issues', numberingIssues.length);
            }
            
            // Build issues HTML
            const issuesList = document.getElementById('fix-issues-list');
            issuesList.innerHTML = '';
            
            numberingIssues.forEach((issue, idx) => {
                const iconMap = {
                    'restart': '•',
                    'fragmented': '•',
                    'orphaned': '•'
                };
                
                const html = `
                    <div class="fix-issue" id="issue-${issue.id}">
                        <div class="fix-issue-header">
                            <span class="fix-issue-icon">${iconMap[issue.type] || '!'}</span>
                            <div class="fix-issue-content">
                                <div class="fix-issue-title">${escapeHtml(issue.title)}</div>
                                <div class="fix-issue-desc">${escapeHtml(issue.description)}</div>
                                <div class="fix-issue-location">${escapeHtml(issue.location)}</div>
                            </div>
                        </div>
                        <div class="fix-issue-actions">
                            ${getIssueActions(issue)}
                        </div>
                    </div>
                `;
                issuesList.innerHTML += html;
            });
        }
        
        // Get action buttons for each issue type (using data attributes for XSS safety)
        function getIssueActions(issue) {
            const safeId = escapeHtml(issue.id);
            switch (issue.type) {
                case 'restart':
                    return `
                        <button class="btn small fix-action" data-issue-id="${safeId}" data-action="continue">Continue Numbering</button>
                        <button class="btn small secondary ignore-action" data-issue-id="${safeId}">Ignore</button>
                    `;
                case 'fragmented':
                    return `
                        <button class="btn small fix-action" data-issue-id="${safeId}" data-action="merge">Merge Lists</button>
                        <button class="btn small secondary ignore-action" data-issue-id="${safeId}">Ignore</button>
                    `;
                case 'orphaned':
                    return `
                        <button class="btn small fix-action" data-issue-id="${safeId}" data-action="convert">Convert to List</button>
                        <button class="btn small secondary ignore-action" data-issue-id="${safeId}">Ignore</button>
                    `;
                default:
                    return `<button class="btn small secondary ignore-action" data-issue-id="${safeId}">Ignore</button>`;
            }
        }
        
        // Event delegation for fix/ignore buttons (XSS-safe)
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('fix-action')) {
                const issueId = e.target.dataset.issueId;
                const action = e.target.dataset.action;
                fixIssue(issueId, action);
            } else if (e.target.classList.contains('ignore-action')) {
                const issueId = e.target.dataset.issueId;
                ignoreIssue(issueId);
            }
        });
        
        // Fix a single issue
        async function fixIssue(issueId, action) {
            const issue = numberingIssues.find(i => i.id === issueId);
            if (!issue) return;
            
            let fixed = false;
            
            try {
                await Word.run(async (context) => {
                    const paragraphs = context.document.body.paragraphs;
                    paragraphs.load('items');
                    await context.sync();
                    
                    if (issue.type === 'restart' && action === 'continue') {
                        // FIX: Continue numbering from previous list
                        if (issue.data.index < paragraphs.items.length && issue.data.index > 0) {
                            const currentPara = paragraphs.items[issue.data.index];
                            const prevPara = paragraphs.items[issue.data.index - 1];
                            
                            // Load list info from both paragraphs
                            prevPara.load('listItemOrNullObject');
                            currentPara.load('listItemOrNullObject');
                            await context.sync();
                            
                            // Get the previous paragraph's list
                            if (prevPara.listItemOrNullObject && !prevPara.listItemOrNullObject.isNullObject) {
                                const prevListItem = prevPara.listItemOrNullObject;
                                prevListItem.load('level');
                                await context.sync();
                                
                                const level = issue.data.level || prevListItem.level || 0;
                                
                                // Get the list from the previous item
                                const prevList = prevListItem.getAncestor();
                                prevList.load('id');
                                await context.sync();
                                
                                // First, detach current paragraph from its (broken) list
                                if (currentPara.listItemOrNullObject && !currentPara.listItemOrNullObject.isNullObject) {
                                    currentPara.detachFromList();
                                    await context.sync();
                                }
                                
                                // Now attach to the SAME list as the previous paragraph
                                // This continues numbering instead of starting new
                                currentPara.attachToList(prevList, level);
                                await context.sync();
                                
                                fixed = true;
                            }
                        }
                    } else if (issue.type === 'fragmented' && action === 'merge') {
                        // FIX: Merge fragmented lists into one continuous list
                        const fragments = issue.data;
                        if (fragments && fragments.length > 0) {
                            // Find the first list to use as the target
                            let targetList = null;
                            let targetLevel = 0;
                            
                            // Get the first fragment's ending paragraph to find the list
                            const firstFragmentEnd = fragments[0].endIndex;
                            if (firstFragmentEnd >= 0 && firstFragmentEnd < paragraphs.items.length) {
                                const firstPara = paragraphs.items[firstFragmentEnd];
                                firstPara.load('listItemOrNullObject');
                                await context.sync();
                                
                                if (firstPara.listItemOrNullObject && !firstPara.listItemOrNullObject.isNullObject) {
                                    const listItem = firstPara.listItemOrNullObject;
                                    listItem.load('level');
                                    targetList = listItem.getAncestor();
                                    targetList.load('id');
                                    await context.sync();
                                    targetLevel = listItem.level;
                                }
                            }
                            
                            if (targetList) {
                                // Go through all paragraphs and merge orphaned list items into target list
                                for (let i = 0; i < paragraphs.items.length; i++) {
                                    const para = paragraphs.items[i];
                                    para.load('listItemOrNullObject');
                                    await context.sync();
                                    
                                    if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                                        const listItem = para.listItemOrNullObject;
                                        const currentList = listItem.getAncestorOrNullObject();
                                        currentList.load('id');
                                        await context.sync();
                                        
                                        // If this is a different list, merge it
                                        if (!currentList.isNullObject && currentList.id !== targetList.id) {
                                            listItem.load('level');
                                            await context.sync();
                                            const level = listItem.level;
                                            
                                            para.detachFromList();
                                            await context.sync();
                                            para.attachToList(targetList, level);
                                            await context.sync();
                                        }
                                    }
                                }
                                fixed = true;
                            } else {
                                // Fallback: couldn't find target list
                                toast('Could not find a list to merge into. Try fixing individual issues.', 'warning');
                            }
                        }
                    } else if (issue.type === 'orphaned' && action === 'convert') {
                        // FIX: Convert manual numbering to Word list
                        if (issue.data.index < paragraphs.items.length) {
                            const para = paragraphs.items[issue.data.index];
                            para.load('text');
                            await context.sync();
                            
                            // Remove the manual number prefix
                            const text = para.text;
                            const pattern = issue.data.pattern;
                            const cleanText = text.replace(new RegExp('^' + escapeRegex(pattern) + '\\s*'), '');
                            
                            // Replace text and apply list formatting
                            para.clear();
                            para.insertText(cleanText, Word.InsertLocation.start);
                            
                            // Apply list formatting based on detected pattern
                            const listLevel = detectListLevel(pattern);
                            para.startNewList();
                            
                            await context.sync();
                            
                            // Set the list level if needed
                            if (listLevel > 0 && para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                                const listItem = para.listItemOrNullObject;
                                for (let i = 0; i < listLevel; i++) {
                                    listItem.levelDown();
                                }
                                await context.sync();
                            }
                            
                            fixed = true;
                        }
                    }
                    
                    await context.sync();
                });
                
                if (fixed) {
                    // Remove from issues and update UI
                    numberingIssues = numberingIssues.filter(i => i.id !== issueId);
                    document.getElementById('issue-' + issueId)?.remove();
                    
                    if (numberingIssues.length === 0) {
                        displayScanResults();
                    } else {
                        document.getElementById('fix-count').textContent = `Found ${numberingIssues.length} Issue${numberingIssues.length > 1 ? 's' : ''}`;
                    }
                    
                    toast('Issue fixed!', 'success');
                } else {
                    toast('Could not automatically fix. Try manual adjustment.', 'warning');
                }
                
            } catch (err) {
                console.error('Fix failed:', err);
                toast('Fix failed: ' + err.message, 'error');
            }
        }
        
        // Escape special regex characters
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // Detect list level from manual number pattern
        function detectListLevel(pattern) {
            // Patterns typically used at different levels:
            // Level 0: 1. I. A.
            // Level 1: a. i. (1)
            // Level 2: (a) (i) 
            if (/^\(\d+\)$/.test(pattern) || /^\([a-z]\)$/.test(pattern)) return 2;
            if (/^[a-z]\.$/.test(pattern) || /^[ivx]+\.$/.test(pattern)) return 1;
            return 0;
        }
        
        // Ignore an issue (remove from list)
        function ignoreIssue(issueId) {
            numberingIssues = numberingIssues.filter(i => i.id !== issueId);
            document.getElementById('issue-' + issueId)?.remove();
            
            if (numberingIssues.length === 0) {
                displayScanResults();
            } else {
                document.getElementById('fix-count').textContent = `Found ${numberingIssues.length} Issue${numberingIssues.length > 1 ? 's' : ''}`;
            }
        }
        
        // ========== FIX ALL ENHANCED ==========
        
        // Store for undo capability
        let lastFixUndoState = null;
        
        // Show/hide Fix All modal
        function showFixAllModal() {
            document.getElementById('fix-all-modal').classList.remove('hidden');
        }
        
        function hideFixAllModal() {
            document.getElementById('fix-all-modal').classList.add('hidden');
        }
        
        // Get human-readable description for an issue
        function getIssueDescription(issue) {
            switch(issue.type) {
                case 'restart':
                    return `Line ${issue.data.index + 1}: Numbering restarts unexpectedly → will continue from previous`;
                case 'orphaned':
                    return `Line ${issue.data.index + 1}: Manual number "${issue.data.pattern}" → will convert to auto-numbering`;
                case 'fragmented':
                    return `${issue.data.length} fragmented list sections → will merge into one list`;
                default:
                    return issue.type + ' issue';
            }
        }
        
        // Get icon for issue type
        function getIssueIcon(type) {
            // V2 Design: No emoji icons
            return '';
        }
        
        // Show preview of what Fix All will do
        function fixAllNumberingIssues() {
            const issues = [...numberingIssues];
            const fixableIssues = issues.filter(i => i.type === 'restart' || i.type === 'orphaned' || i.type === 'fragmented');
            const infoOnlyIssues = issues.filter(i => i.type !== 'restart' && i.type !== 'orphaned' && i.type !== 'fragmented');
            
            if (fixableIssues.length === 0) {
                toast('No fixable issues found', 'info');
                return;
            }
            
            // Build preview HTML
            let html = `
                <div style="margin-bottom: 12px; color: #666;">
                    Review the changes before applying:
                </div>
                <div style="max-height: 250px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 6px;">
            `;
            
            fixableIssues.forEach((issue, idx) => {
                html += `
                    <div style="padding: 10px 12px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: flex-start; gap: 10px;">
                        <span style="font-size: 16px;">${getIssueIcon(issue.type)}</span>
                        <div style="flex: 1; font-size: 13px; color: #333;">
                            ${getIssueDescription(issue)}
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            
            if (infoOnlyIssues.length > 0) {
                html += `
                    <div style="margin-top: 12px; font-size: 12px; color: #888;">
                        + ${infoOnlyIssues.length} informational issue${infoOnlyIssues.length > 1 ? 's' : ''} (will be dismissed)
                    </div>
                `;
            }
            
            document.getElementById('fix-all-modal-title').textContent = `Fix ${fixableIssues.length} Issue${fixableIssues.length > 1 ? 's' : ''}?`;
            document.getElementById('fix-all-modal-body').innerHTML = html;
            document.getElementById('fix-all-modal-footer').innerHTML = `
                <button class="btn secondary" onclick="hideFixAllModal()">Cancel</button>
                <button class="btn" onclick="executeFixAll()">Apply Fixes</button>
            `;
            
            showFixAllModal();
        }
        
        // Execute the fixes with undo support
        async function executeFixAll() {
            hideFixAllModal();
            
            const issues = [...numberingIssues];
            const fixableIssues = issues.filter(i => i.type === 'restart' || i.type === 'orphaned' || i.type === 'fragmented');
            
            toast(`Saving document state for undo...`, 'info');
            
            // Save document state for undo using OOXML
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    const ooxml = body.getOoxml();
                    await context.sync();
                    lastFixUndoState = {
                        ooxml: ooxml.value,
                        timestamp: Date.now(),
                        issueCount: fixableIssues.length
                    };
                });
            } catch (err) {
                console.warn('Could not save undo state:', err);
                lastFixUndoState = null;
            }
            
            toast(`Fixing ${fixableIssues.length} issues...`, 'info');
            
            const results = [];
            
            // Process each fixable issue
            for (const issue of fixableIssues) {
                try {
                    if (issue.type === 'restart') {
                        await fixIssue(issue.id, 'continue');
                        results.push({ issue, success: true, action: 'Continued numbering' });
                    } else if (issue.type === 'orphaned') {
                        await fixIssue(issue.id, 'convert');
                        results.push({ issue, success: true, action: 'Converted to auto-numbering' });
                    } else if (issue.type === 'fragmented') {
                        await fixIssue(issue.id, 'merge');
                        results.push({ issue, success: true, action: 'Merged fragments' });
                    }
                } catch (err) {
                    console.error('Fix failed for issue:', issue, err);
                    results.push({ issue, success: false, action: err.message });
                }
            }
            
            // Dismiss info-only issues
            const infoOnlyIssues = issues.filter(i => i.type !== 'restart' && i.type !== 'orphaned' && i.type !== 'fragmented');
            infoOnlyIssues.forEach(issue => ignoreIssue(issue.id));
            
            // Show results
            showFixAllResults(results);
        }
        
        // Show results after fixing
        function showFixAllResults(results) {
            const successful = results.filter(r => r.success);
            const failed = results.filter(r => !r.success);
            
            let html = '';
            
            if (successful.length > 0) {
                html += `
                    <div style="margin-bottom: 12px;">
                        <div style="color: #22863a; font-weight: 600; margin-bottom: 8px;">
                            Fixed ${successful.length} issue${successful.length > 1 ? 's' : ''}
                        </div>
                        <div style="max-height: 150px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 6px; background: #f6fff6;">
                `;
                successful.forEach(r => {
                    html += `
                        <div style="padding: 8px 12px; border-bottom: 1px solid #e8f5e8; font-size: 13px;">
                            ${getIssueIcon(r.issue.type)} ${r.action}
                        </div>
                    `;
                });
                html += '</div></div>';
            }
            
            if (failed.length > 0) {
                html += `
                    <div style="margin-bottom: 12px;">
                        <div style="color: #cb2431; font-weight: 600; margin-bottom: 8px;">
                            Failed: ${failed.length}
                        </div>
                        <div style="max-height: 100px; overflow-y: auto; border: 1px solid #ffd0d0; border-radius: 6px; background: #fff6f6;">
                `;
                failed.forEach(r => {
                    html += `
                        <div style="padding: 8px 12px; border-bottom: 1px solid #ffe8e8; font-size: 13px; color: #666;">
                            ${getIssueIcon(r.issue.type)} ${r.action}
                        </div>
                    `;
                });
                html += '</div></div>';
            }
            
            document.getElementById('fix-all-modal-title').textContent = 'Fix Complete';
            document.getElementById('fix-all-modal-body').innerHTML = html;
            
            // Footer with undo option
            let footerHtml = '';
            if (lastFixUndoState) {
                footerHtml = `
                    <button class="btn secondary" onclick="undoFixAll()">Undo All</button>
                    <button class="btn" onclick="hideFixAllModal()">Done</button>
                `;
            } else {
                footerHtml = `
                    <div style="font-size: 12px; color: #888; margin-right: auto;">Use Ctrl+Z to undo</div>
                    <button class="btn" onclick="hideFixAllModal()">Done</button>
                `;
            }
            document.getElementById('fix-all-modal-footer').innerHTML = footerHtml;
            
            showFixAllModal();
        }
        
        // Undo all fixes by restoring saved OOXML
        async function undoFixAll() {
            if (!lastFixUndoState) {
                toast('No undo state available', 'warning');
                hideFixAllModal();
                return;
            }
            
            toast('Undoing all fixes...', 'info');
            
            try {
                await Word.run(async (context) => {
                    const body = context.document.body;
                    // Clear and restore from OOXML
                    body.clear();
                    await context.sync();
                    body.insertOoxml(lastFixUndoState.ooxml, Word.InsertLocation.replace);
                    await context.sync();
                });
                
                toast(`Reverted ${lastFixUndoState.issueCount} fixes`, 'success');
                lastFixUndoState = null;
                hideFixAllModal();
                
                // Re-scan to show issues again
                await scanForNumberingIssues();
                
            } catch (err) {
                console.error('Undo failed:', err);
                toast('Undo failed: ' + err.message, 'error');
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // LIST CONTROLS (Continue/Restart/New List)
        // ═══════════════════════════════════════════════════════════════
        
        // Track current list context
        let currentListContext = null;
        let listControlsPolling = null;
        
        // Initialize list controls polling when Fix panel is shown
        function initListControls() {
            // Poll for selection changes when on the Fix/Numbering panel
            if (listControlsPolling) {
                clearInterval(listControlsPolling);
            }
            
            // Check selection every 500ms when panel is active
            listControlsPolling = setInterval(() => {
                const fixPanel = document.getElementById('fix-numbering');
                if (fixPanel && fixPanel.classList.contains('active')) {
                    checkListContext();
                }
            }, 500);
            
            // Also check immediately
            checkListContext();
        }
        
        // Stop polling when leaving the panel
        function stopListControlsPolling() {
            if (listControlsPolling) {
                clearInterval(listControlsPolling);
                listControlsPolling = null;
            }
        }
        
        // Check if current selection is in a numbered list
        async function checkListContext() {
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const para = selection.paragraphs.getFirst();
                    para.load(['text', 'style', 'listItemOrNullObject']);
                    await context.sync();
                    
                    // Check if paragraph has list item
                    if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                        const listItem = para.listItemOrNullObject;
                        listItem.load(['level', 'listString', 'siblingIndex']);
                        await context.sync();
                        
                        // Get the parent list to check for restart capability
                        const list = listItem.getAncestor();
                        list.load('id');
                        await context.sync();
                        
                        currentListContext = {
                            isInList: true,
                            level: listItem.level,
                            listString: listItem.listString,
                            siblingIndex: listItem.siblingIndex,
                            listId: list.id,
                            paragraphText: para.text.substring(0, 40) + (para.text.length > 40 ? '...' : '')
                        };
                        
                        updateListControlsUI(currentListContext);
                    } else {
                        currentListContext = { isInList: false };
                        updateListControlsUI(currentListContext);
                    }
                });
            } catch (err) {
                // Selection check failed - likely no selection or API issue
                // List context check failed - cursor not in list
                currentListContext = { isInList: false };
                updateListControlsUI(currentListContext);
            }
        }
        
        // Update the UI based on list context
        function updateListControlsUI(ctx) {
            const controlsSection = document.getElementById('list-controls');
            const statusEl = document.getElementById('list-status');
            const infoEl = document.getElementById('list-info');
            const currentItemEl = document.getElementById('list-current-item');
            const hintEl = document.getElementById('list-hint');
            
            const btnContinue = document.getElementById('btn-continue-list');
            const btnRestart = document.getElementById('btn-restart-list');
            const btnNewList = document.getElementById('btn-new-list');
            
            if (ctx && ctx.isInList) {
                // Cursor is in a numbered list
                controlsSection.classList.add('active');
                controlsSection.classList.remove('inactive');
                
                statusEl.textContent = `Level ${ctx.level + 1}`;
                statusEl.classList.add('in-list');
                
                infoEl.style.display = 'block';
                currentItemEl.textContent = `${ctx.listString} ${ctx.paragraphText}`;
                
                hintEl.innerHTML = '<strong>Tip:</strong> You are in a numbered list. Use the controls above to manage this item.';
                
                // Enable buttons
                btnContinue.disabled = false;
                btnRestart.disabled = false;
                btnNewList.disabled = false;
                
                // Adjust Continue button - only useful if not first item
                if (ctx.siblingIndex === 0) {
                    btnContinue.querySelector('.list-control-btn-desc').textContent = 'Already at start of this list';
                } else {
                    btnContinue.querySelector('.list-control-btn-desc').textContent = 'Join with the list above';
                }
            } else {
                // Cursor is NOT in a numbered list
                controlsSection.classList.remove('active');
                controlsSection.classList.add('inactive');
                
                statusEl.textContent = 'Not in a list';
                statusEl.classList.remove('in-list');
                
                infoEl.style.display = 'none';
                hintEl.innerHTML = '<strong>Tip:</strong> Click in a numbered paragraph to enable these controls.';
                
                // Disable buttons
                btnContinue.disabled = true;
                btnRestart.disabled = true;
                btnNewList.disabled = true;
            }
        }
        
        // Continue numbering from the previous list
        async function continueFromPrevious() {
            if (!currentListContext || !currentListContext.isInList) {
                toast('Place cursor in a numbered paragraph first', 'warning');
                return;
            }
            
            toast('Continuing from previous list...', 'info');
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const para = selection.paragraphs.getFirst();
                    para.load('listItemOrNullObject');
                    await context.sync();
                    
                    if (!para.listItemOrNullObject || para.listItemOrNullObject.isNullObject) {
                        throw new Error('Paragraph is no longer in a list');
                    }
                    
                    const listItem = para.listItemOrNullObject;
                    listItem.load('level');
                    await context.sync();
                    
                    const level = listItem.level;
                    
                    // Get all paragraphs to find previous list
                    const body = context.document.body;
                    const paragraphs = body.paragraphs;
                    paragraphs.load('items');
                    await context.sync();
                    
                    // Find current paragraph index
                    let currentIndex = -1;
                    for (let i = 0; i < paragraphs.items.length; i++) {
                        paragraphs.items[i].load(['text', 'listItemOrNullObject']);
                    }
                    await context.sync();
                    
                    // Find our paragraph and the previous list
                    const paraText = para.text;
                    let prevListPara = null;
                    let foundCurrent = false;
                    
                    for (let i = 0; i < paragraphs.items.length; i++) {
                        const p = paragraphs.items[i];
                        
                        // Found our paragraph
                        if (p.text === paraText && !foundCurrent) {
                            foundCurrent = true;
                            currentIndex = i;
                            break;
                        }
                        
                        // Track last list paragraph before current
                        if (p.listItemOrNullObject && !p.listItemOrNullObject.isNullObject) {
                            prevListPara = p;
                        }
                    }
                    
                    if (currentIndex <= 0 || !prevListPara) {
                        toast('No previous list found to continue from', 'warning');
                        return;
                    }
                    
                    // Get the previous list
                    prevListPara.load('listItemOrNullObject');
                    await context.sync();
                    
                    const prevListItem = prevListPara.listItemOrNullObject;
                    prevListItem.load('level');
                    const prevList = prevListItem.getAncestor();
                    prevList.load('id');
                    await context.sync();
                    
                    // Detach from current list
                    para.detachFromList();
                    await context.sync();
                    
                    // Attach to previous list at same level
                    para.attachToList(prevList, level);
                    await context.sync();
                });
                
                toast('Now continuing from previous list', 'success');
                checkListContext(); // Refresh UI
                
            } catch (err) {
                console.error('Continue failed:', err);
                toast('Could not continue: ' + err.message, 'error');
            }
        }
        
        // Restart numbering at 1 for current list item
        async function restartAtOne() {
            if (!currentListContext || !currentListContext.isInList) {
                toast('Place cursor in a numbered paragraph first', 'warning');
                return;
            }
            
            toast('Restarting numbering...', 'info');
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const para = selection.paragraphs.getFirst();
                    para.load('listItemOrNullObject');
                    await context.sync();
                    
                    if (!para.listItemOrNullObject || para.listItemOrNullObject.isNullObject) {
                        throw new Error('Paragraph is no longer in a list');
                    }
                    
                    const listItem = para.listItemOrNullObject;
                    listItem.load('level');
                    await context.sync();
                    
                    const level = listItem.level;
                    
                    // Start a new list from this paragraph (this restarts numbering)
                    para.detachFromList();
                    await context.sync();
                    
                    // Start fresh list
                    para.startNewList();
                    await context.sync();
                    
                    // Set level if not at top level
                    if (level > 0) {
                        para.load('listItemOrNullObject');
                        await context.sync();
                        
                        if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                            const newListItem = para.listItemOrNullObject;
                            for (let i = 0; i < level; i++) {
                                newListItem.levelDown();
                            }
                            await context.sync();
                        }
                    }
                });
                
                toast('Numbering restarted at 1', 'success');
                checkListContext(); // Refresh UI
                
            } catch (err) {
                console.error('Restart failed:', err);
                toast('Could not restart: ' + err.message, 'error');
            }
        }
        
        // Start a completely new independent list
        async function startNewList() {
            if (!currentListContext || !currentListContext.isInList) {
                toast('Place cursor in a numbered paragraph first', 'warning');
                return;
            }
            
            toast('Creating new independent list...', 'info');
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const para = selection.paragraphs.getFirst();
                    para.load(['listItemOrNullObject', 'text']);
                    await context.sync();
                    
                    if (!para.listItemOrNullObject || para.listItemOrNullObject.isNullObject) {
                        throw new Error('Paragraph is no longer in a list');
                    }
                    
                    const listItem = para.listItemOrNullObject;
                    listItem.load('level');
                    await context.sync();
                    
                    const level = listItem.level;
                    const originalText = para.text;
                    
                    // Detach from current list
                    para.detachFromList();
                    await context.sync();
                    
                    // Create a brand new list - this creates an independent list
                    // that won't interfere with other lists using the same style
                    para.startNewList();
                    await context.sync();
                    
                    // Preserve the level structure if needed
                    if (level > 0) {
                        para.load('listItemOrNullObject');
                        await context.sync();
                        
                        if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                            const newListItem = para.listItemOrNullObject;
                            for (let i = 0; i < level; i++) {
                                newListItem.levelDown();
                            }
                            await context.sync();
                        }
                    }
                });
                
                toast('New independent list created', 'success');
                checkListContext(); // Refresh UI
                
            } catch (err) {
                console.error('New list failed:', err);
                toast('Could not create new list: ' + err.message, 'error');
            }
        }
        
        // Initialize list controls when switching to Fix mode
        function switchNumberingMode(mode) {
            const subNavBtns = document.querySelectorAll('#panel-numbering .sub-nav-btn');
            const numberingBrowse = document.getElementById('numbering-browse');
            const tocBrowse = document.getElementById('toc-browse');
            const fixNumbering = document.getElementById('fix-numbering');
            const numberingEditor = document.getElementById('numbering-editor');
            
            // Update tab active state
            subNavBtns.forEach((btn, idx) => {
                btn.classList.toggle('active', 
                    (mode === 'numbering' && idx === 0) ||
                    (mode === 'fix' && idx === 1) ||
                    (mode === 'toc' && idx === 2)
                );
            });
            
            // Hide all sub-panels first
            numberingBrowse.classList.remove('active');
            tocBrowse.classList.remove('active');
            fixNumbering.classList.remove('active');
            if (numberingEditor) numberingEditor.classList.remove('active');
            
            // Show appropriate panel
            if (mode === 'numbering') {
                numberingBrowse.classList.add('active');
            } else if (mode === 'fix') {
                fixNumbering.classList.add('active');
            } else if (mode === 'toc') {
                tocBrowse.classList.add('active');
            }
            
            // Initialize list controls when entering Fix mode
            if (mode === 'fix') {
                initListControls();
            } else {
                stopListControlsPolling();
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // PARAGRAPH LOCATION INDICATOR
        // Shows current paragraph position without modifying document
        // ═══════════════════════════════════════════════════════════════
        
        let locationIndicatorEnabled = false;
        let locationPollingInterval = null;
        let locationDebounceTimer = null;
        let lastLocationParaText = null; // Track to avoid redundant updates
        const LOCATION_DEBOUNCE_MS = 300;
        const LOCATION_POLL_MS = 400;
        
        // Toggle location indicator on/off
        function toggleLocationIndicator() {
            locationIndicatorEnabled = !locationIndicatorEnabled;
            
            const toggleBtn = document.getElementById('location-toggle');
            const statusBar = document.getElementById('location-status-bar');
            
            if (locationIndicatorEnabled) {
                toggleBtn.classList.add('active');
                statusBar.classList.add('visible');
                startLocationTracking();
                toast('Location tracking enabled', 'info', 2000);
            } else {
                toggleBtn.classList.remove('active');
                statusBar.classList.remove('visible');
                stopLocationTracking();
                resetLocationDisplay();
                toast('Location tracking disabled', 'info', 2000);
            }
            
            // Persist preference
            localStorage.setItem('draftbridge_location_indicator', locationIndicatorEnabled ? 'on' : 'off');
        }
        
        // Initialize location indicator from saved preference
        function initLocationIndicator() {
            const saved = localStorage.getItem('draftbridge_location_indicator');
            if (saved === 'on') {
                locationIndicatorEnabled = true;
                const toggleBtn = document.getElementById('location-toggle');
                const statusBar = document.getElementById('location-status-bar');
                if (toggleBtn) toggleBtn.classList.add('active');
                if (statusBar) statusBar.classList.add('visible');
                startLocationTracking();
            }
            
            // Add keyboard shortcut listener (Ctrl+Shift+L)
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'L') {
                    e.preventDefault();
                    toggleLocationIndicator();
                }
            });
        }
        
        // Start tracking cursor position
        function startLocationTracking() {
            if (locationPollingInterval) {
                clearInterval(locationPollingInterval);
            }
            
            // Poll for cursor position changes
            locationPollingInterval = setInterval(() => {
                if (locationIndicatorEnabled) {
                    debouncedLocationUpdate();
                }
            }, LOCATION_POLL_MS);
            
            // Initial check
            updateParagraphLocation();
        }
        
        // Stop tracking
        function stopLocationTracking() {
            if (locationPollingInterval) {
                clearInterval(locationPollingInterval);
                locationPollingInterval = null;
            }
            if (locationDebounceTimer) {
                clearTimeout(locationDebounceTimer);
                locationDebounceTimer = null;
            }
        }
        
        // Debounced update to prevent flicker
        function debouncedLocationUpdate() {
            if (locationDebounceTimer) {
                clearTimeout(locationDebounceTimer);
            }
            locationDebounceTimer = setTimeout(() => {
                updateParagraphLocation();
            }, LOCATION_DEBOUNCE_MS);
        }
        
        // Reset the display when disabled
        function resetLocationDisplay() {
            lastLocationParaText = null;
            const numberEl = document.getElementById('location-para-number');
            const textEl = document.getElementById('location-para-text');
            if (numberEl) numberEl.textContent = '—';
            if (textEl) textEl.textContent = '';
        }
        
        // Update the location indicator with current paragraph info
        async function updateParagraphLocation() {
            if (!locationIndicatorEnabled) return;
            
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    const para = selection.paragraphs.getFirst();
                    
                    // Load paragraph properties
                    para.load(['text', 'style', 'listItemOrNullObject']);
                    await context.sync();
                    
                    // Skip update if paragraph hasn't changed (optimization)
                    const currentParaText = para.text;
                    if (currentParaText === lastLocationParaText) {
                        return;
                    }
                    lastLocationParaText = currentParaText;
                    
                    // Get paragraph number info
                    let paraNumber = '';
                    let levelInfo = '';
                    
                    if (para.listItemOrNullObject && !para.listItemOrNullObject.isNullObject) {
                        // In a numbered/bulleted list
                        const listItem = para.listItemOrNullObject;
                        listItem.load(['listString', 'level', 'siblingIndex']);
                        await context.sync();
                        
                        // Format as ¶ followed by the list string (e.g., "¶ 4.2.1")
                        const listStr = listItem.listString || '';
                        paraNumber = '¶ ' + listStr.replace(/[\.\)\s]+$/, ''); // Clean trailing punctuation
                        levelInfo = `L${listItem.level + 1}`;
                    } else {
                        // Not in a list - count paragraph position
                        const body = context.document.body;
                        const paragraphs = body.paragraphs;
                        paragraphs.load('items');
                        await context.sync();
                        
                        // Find paragraph index by comparing text (more reliable than references)
                        let paraIndex = 0;
                        let nonEmptyCount = 0;
                        
                        for (let i = 0; i < paragraphs.items.length; i++) {
                            paragraphs.items[i].load('text');
                        }
                        await context.sync();
                        
                        for (let i = 0; i < paragraphs.items.length; i++) {
                            const pText = paragraphs.items[i].text.trim();
                            if (pText.length > 0) nonEmptyCount++;
                            if (paragraphs.items[i].text === currentParaText) {
                                paraIndex = i + 1;
                                break;
                            }
                        }
                        
                        paraNumber = '¶ ' + paraIndex;
                        levelInfo = nonEmptyCount + ' paras';
                    }
                    
                    // Get truncated paragraph text for display
                    const cleanText = currentParaText.trim();
                    const displayText = cleanText.length > 45 
                        ? cleanText.substring(0, 45) + '…' 
                        : cleanText;
                    
                    // Update UI with animation
                    const numberEl = document.getElementById('location-para-number');
                    const textEl = document.getElementById('location-para-text');
                    
                    if (numberEl) {
                        numberEl.textContent = paraNumber;
                        numberEl.title = levelInfo;
                    }
                    if (textEl) {
                        textEl.textContent = displayText || '(empty)';
                    }
                });
            } catch (err) {
                // Silent fail - selection may have changed during operation
                // Only log in debug mode
                if (localStorage.getItem('draftbridge_debug') === 'true') {
                    // Location update skipped
                }
            }
        }
        
        // Call init when app loads (handled in Office.onReady)
        
        // ═══════════════════════════════════════════════════════════════
        // TEMPLATE EDITOR
        // ═══════════════════════════════════════════════════════════════
        
        let savedTemplates = [];
        let currentTemplate = {
            name: '',
            blocks: []
        };
        let editingTemplateId = null;
        let draggedBlockType = null;
        let draggedBlockIndex = null;
        let lastFocusedTextarea = null; // Track last focused textarea for variable insertion
        
        // Default firm data for preview
        const previewData = {
            date: new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }),
            firm: {
                name: 'Smith & Associates LLP',
                address: '123 Main Street\nSuite 500\nNew York, NY 10001'
            },
            attorney: {
                name: 'John Smith',
                title: 'Partner',
                email: 'jsmith@smithlaw.com'
            },
            client: {
                name: '[Client Name]',
                address: '[Client Address]'
            },
            matter: {
                name: '[Matter Name]',
                caseNumber: '[Case Number]'
            },
            court: {
                type: 'federal',
                district: 'Southern District of New York',
                state: 'New York',
                county: 'New York County'
            }
        };
        
        // Show template list
        function showTemplateList() {
            // Hide main content, show template list
            document.querySelector('#panel-admin > .content').style.display = 'none';
            document.querySelectorAll('#panel-admin .sub-panel').forEach(p => p.classList.remove('active'));
            document.getElementById('template-list').classList.add('active');
            loadSavedTemplates();
        }
        
        function hideTemplateList() {
            document.getElementById('template-list').classList.remove('active');
            document.querySelector('#panel-admin > .content').style.display = 'block';
        }
        
        // Show template editor
        function showTemplateEditor(templateId = null) {
            // Hide main content, show editor
            document.querySelector('#panel-admin > .content').style.display = 'none';
            document.querySelectorAll('#panel-admin .sub-panel').forEach(p => p.classList.remove('active'));
            document.getElementById('template-editor').classList.add('active');
            
            if (templateId) {
                // Editing existing template
                const template = savedTemplates.find(t => t.id === templateId);
                if (template) {
                    editingTemplateId = templateId;
                    document.getElementById('template-name').value = template.name;
                    currentTemplate = JSON.parse(JSON.stringify(template));
                    renderTemplateBlocks();
                }
            } else {
                // New template
                editingTemplateId = null;
                document.getElementById('template-name').value = '';
                currentTemplate = { name: '', blocks: [] };
                renderTemplateBlocks();
            }
            
            initDragAndDrop();
        }
        
        function hideTemplateEditor() {
            document.getElementById('template-editor').classList.remove('active');
            document.querySelector('#panel-admin > .content').style.display = 'block';
            currentTemplate = { name: '', blocks: [] };
            editingTemplateId = null;
        }
        
        // Contacts Panel functions
        function showContactsPanel() {
            document.querySelector('#panel-admin > .content').style.display = 'none';
            document.querySelectorAll('#panel-admin .sub-panel').forEach(p => p.classList.remove('active'));
            document.getElementById('contacts-panel').classList.add('active');
            
            // Initialize SmartVariables contacts manager if available
            if (typeof SmartVariables !== 'undefined') {
                SmartVariables.showContactsManager('contacts-panel-content');
            }
        }
        
        function hideContactsPanel() {
            document.getElementById('contacts-panel').classList.remove('active');
            document.querySelector('#panel-admin > .content').style.display = 'block';
        }
        
        // Initialize drag and drop
        function initDragAndDrop() {
            const palette = document.querySelectorAll('.palette-item');
            const canvas = document.getElementById('template-canvas');
            
            // Palette items (drag to create new blocks)
            palette.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedBlockType = item.dataset.blockType;
                    draggedBlockIndex = null;
                    item.classList.add('dragging');
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('dragging');
                    draggedBlockType = null;
                });
            });
            
            // Variable chips (click to insert at cursor, or copy if no textarea focused)
            document.querySelectorAll('.var-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    const varName = chip.dataset.var;
                    const varText = `{{${varName}}}`;
                    
                    // Helper to flash the textarea on insert
                    const flashInsert = (textarea) => {
                        textarea.classList.remove('var-inserted');
                        void textarea.offsetWidth; // Force reflow
                        textarea.classList.add('var-inserted');
                    };
                    
                    // If a textarea in template editor is focused, insert at cursor
                    if (lastFocusedTextarea && document.activeElement === lastFocusedTextarea) {
                        const start = lastFocusedTextarea.selectionStart;
                        const end = lastFocusedTextarea.selectionEnd;
                        const before = lastFocusedTextarea.value.substring(0, start);
                        const after = lastFocusedTextarea.value.substring(end);
                        
                        lastFocusedTextarea.value = before + varText + after;
                        
                        // Update cursor position after inserted text
                        const newPos = start + varText.length;
                        lastFocusedTextarea.setSelectionRange(newPos, newPos);
                        
                        // Trigger change event to update block content
                        lastFocusedTextarea.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        flashInsert(lastFocusedTextarea);
                        toast(`Inserted ${varText}`, 'success', 2000);
                    } else if (lastFocusedTextarea) {
                        // Textarea was focused but lost focus - still insert at last position
                        const start = lastFocusedTextarea.selectionStart;
                        const before = lastFocusedTextarea.value.substring(0, start);
                        const after = lastFocusedTextarea.value.substring(start);
                        
                        lastFocusedTextarea.value = before + varText + after;
                        lastFocusedTextarea.focus();
                        
                        // Update cursor position
                        const newPos = start + varText.length;
                        lastFocusedTextarea.setSelectionRange(newPos, newPos);
                        
                        // Trigger change event
                        lastFocusedTextarea.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        flashInsert(lastFocusedTextarea);
                        toast(`Inserted ${varText}`, 'success', 2000);
                    } else {
                        // No textarea context - copy to clipboard as fallback
                        navigator.clipboard.writeText(varText);
                        toast(`Copied ${varText} to clipboard`, 'success', 2000);
                    }
                });
            });
            
            // Canvas drop zone
            canvas.addEventListener('dragover', (e) => {
                e.preventDefault();
                canvas.classList.add('drag-over');
                
                // Show drop indicator
                updateDropIndicator(canvas, e.clientY);
            });
            
            canvas.addEventListener('dragleave', (e) => {
                // Only remove if leaving canvas entirely (not entering a child)
                if (!canvas.contains(e.relatedTarget)) {
                    canvas.classList.remove('drag-over');
                    removeDropIndicator(canvas);
                }
            });
            
            canvas.addEventListener('drop', (e) => {
                e.preventDefault();
                canvas.classList.remove('drag-over');
                removeDropIndicator(canvas);
                
                if (draggedBlockType) {
                    // Creating new block from palette - insert at indicator position
                    const insertIdx = getDropIndex(canvas, e.clientY);
                    addBlockAt(draggedBlockType, insertIdx);
                } else if (draggedBlockIndex !== null) {
                    // Reordering existing block
                    const insertIndex = getDropIndex(canvas, e.clientY);
                    
                    // Move block
                    if (insertIndex !== draggedBlockIndex && insertIndex !== draggedBlockIndex + 1) {
                        const [movedBlock] = currentTemplate.blocks.splice(draggedBlockIndex, 1);
                        const adjustedIndex = insertIndex > draggedBlockIndex ? insertIndex - 1 : insertIndex;
                        currentTemplate.blocks.splice(adjustedIndex, 0, movedBlock);
                        renderTemplateBlocks();
                    }
                }
                
                draggedBlockType = null;
                draggedBlockIndex = null;
            });
        }
        
        // Drop indicator helpers
        function getDropIndex(canvas, clientY) {
            const blocks = canvas.querySelectorAll('.template-block');
            let insertIndex = currentTemplate.blocks.length;
            
            blocks.forEach((block, idx) => {
                const rect = block.getBoundingClientRect();
                if (clientY < rect.top + rect.height / 2) {
                    if (insertIndex > idx) insertIndex = idx;
                }
            });
            
            return insertIndex;
        }
        
        function updateDropIndicator(canvas, clientY) {
            removeDropIndicator(canvas);
            
            const blocks = canvas.querySelectorAll('.template-block');
            const indicator = document.createElement('div');
            indicator.className = 'drop-indicator';
            
            if (blocks.length === 0) {
                canvas.appendChild(indicator);
                return;
            }
            
            const insertIndex = getDropIndex(canvas, clientY);
            
            if (insertIndex >= blocks.length) {
                // Insert after last block
                canvas.appendChild(indicator);
            } else {
                // Insert before the target block
                blocks[insertIndex].parentNode.insertBefore(indicator, blocks[insertIndex]);
            }
        }
        
        function removeDropIndicator(canvas) {
            const existing = canvas.querySelector('.drop-indicator');
            if (existing) existing.remove();
        }
        
        // Add a new block at specific index
        function addBlockAt(type, index) {
            const block = createBlockOfType(type);
            currentTemplate.blocks.splice(index, 0, block);
            renderTemplateBlocks();
            updateTemplatePreview();
        }
        
        // Add a new block (at end)
        function addBlock(type) {
            const block = createBlockOfType(type);
            currentTemplate.blocks.push(block);
            renderTemplateBlocks();
            updateTemplatePreview();
        }
        
        // Create a block with default values based on type
        function createBlockOfType(type) {
            const block = {
                id: 'blk_' + Date.now(),
                type: type,
                content: ''
            };
            
            if (type === 'text') {
                block.content = 'Enter your text here...\n\nUse {{variable}} syntax for dynamic content.';
                // Default paragraph formatting: widow control on, others off
                block.keepTogether = false;
                block.keepWithNext = false;
                block.widowControl = true;
            } else if (type === 'variable') {
                block.variable = 'date';
                block.format = 'MMMM D, YYYY';
            } else if (type === 'separator') {
                block.content = '─'.repeat(40);
            } else if (type === 'table') {
                // OOXML Table configuration
                block.rowCount = 3;
                block.colCount = 2;
                block.hasHeaderRow = true;
                block.borderStyle = 'all'; // 'all', 'none', 'outside'
                block.headerStyle = 'bold-shaded'; // 'bold', 'shaded', 'bold-shaded', 'none'
                block.columnWidths = 'equal'; // 'equal', 'auto', 'custom'
                block.cells = [
                    ['Header 1', 'Header 2'],
                    ['{{client.name}}', 'Value 1'],
                    ['Row 2 Col 1', 'Row 2 Col 2']
                ];
                // Tables: keep together by default (signature blocks, etc.)
                block.keepTogether = true;
                block.keepWithNext = false;
                block.widowControl = true;
            } else if (type === 'conditional') {
                // Initialize conditional block with default condition
                block.conditions = [{
                    id: 'cond_' + Date.now(),
                    variable: 'court.type',
                    operator: '==',
                    value: 'federal'
                }];
                block.conditionLogic = 'AND'; // 'AND' or 'OR'
                block.nestedBlocks = []; // Blocks inside the conditional
            }
            
            return block;
        }
        
        // Render blocks on canvas
        function renderTemplateBlocks() {
            const canvas = document.getElementById('template-canvas');
            
            if (currentTemplate.blocks.length === 0) {
                canvas.innerHTML = '<div class="canvas-placeholder">Click "+ Add" or drag sections here to build your template</div>';
                return;
            }
            
            let html = '';
            currentTemplate.blocks.forEach((block, index) => {
                html += renderBlock(block, index);
            });
            
            canvas.innerHTML = html;
            
            // Add drag handlers to rendered blocks
            canvas.querySelectorAll('.template-block').forEach((el, idx) => {
                el.addEventListener('dragstart', (e) => {
                    draggedBlockIndex = idx;
                    draggedBlockType = null;
                    el.classList.add('dragging');
                });
                
                el.addEventListener('dragend', () => {
                    el.classList.remove('dragging');
                    draggedBlockIndex = null;
                });
            });
            
            // Track textarea focus for variable chip insertion
            canvas.querySelectorAll('.template-block-content textarea').forEach(textarea => {
                textarea.addEventListener('focus', () => {
                    lastFocusedTextarea = textarea;
                });
            });
        }
        
        // Render a single block
        function renderBlock(block, index) {
            const icons = { text: 'T', variable: 'V', separator: '—', conditional: '?', table: '#' };
            const labels = { text: 'Text', variable: 'Variable', separator: 'Separator', conditional: 'Conditional', table: 'Table (Grouped)' };
            
            let contentHtml = '';
            let formatOptionsHtml = '';
            
            if (block.type === 'text') {
                contentHtml = `<textarea onchange="updateBlockContent(${index}, this.value)" 
                    placeholder="Enter text with {{variables}}">${escapeHtml(block.content)}</textarea>`;
                
                // Add formatting options for text blocks
                formatOptionsHtml = renderBlockFormatOptions(block, index);
            } else if (block.type === 'variable') {
                contentHtml = `
                    <select onchange="updateBlockVariable(${index}, this.value)">
                        <option value="date" ${block.variable === 'date' ? 'selected' : ''}>Date</option>
                        <option value="firm.name" ${block.variable === 'firm.name' ? 'selected' : ''}>Firm Name</option>
                        <option value="firm.address" ${block.variable === 'firm.address' ? 'selected' : ''}>Firm Address</option>
                        <option value="attorney.name" ${block.variable === 'attorney.name' ? 'selected' : ''}>Attorney Name</option>
                        <option value="attorney.title" ${block.variable === 'attorney.title' ? 'selected' : ''}>Attorney Title</option>
                        <option value="client.name" ${block.variable === 'client.name' ? 'selected' : ''}>Client Name</option>
                        <option value="client.address" ${block.variable === 'client.address' ? 'selected' : ''}>Client Address</option>
                        <option value="matter.name" ${block.variable === 'matter.name' ? 'selected' : ''}>Matter Name</option>
                        <option value="matter.caseNumber" ${block.variable === 'matter.caseNumber' ? 'selected' : ''}>Case Number</option>
                    </select>
                `;
            } else if (block.type === 'separator') {
                contentHtml = '<div style="text-align:center;color:#999;font-size:11px;">── Separator Line ──</div>';
            } else if (block.type === 'table') {
                contentHtml = renderTableEditor(block, index);
                // Add formatting options for table blocks
                formatOptionsHtml = renderBlockFormatOptions(block, index);
            } else if (block.type === 'conditional') {
                // Render conditional block with its own special structure
                return renderConditionalBlock(block, index);
            }
            
            return `
                <div class="template-block" draggable="true" data-index="${index}">
                    <div class="template-block-header">
                        <span class="template-block-type">
                            <span>${icons[block.type] || ''}</span>
                            <span>${labels[block.type] || block.type}</span>
                        </span>
                        <span class="template-block-actions">
                            <button onclick="moveBlockUp(${index})" title="Move up">↑</button>
                            <button onclick="moveBlockDown(${index})" title="Move down">↓</button>
                            <button onclick="deleteBlock(${index})" title="Delete">×</button>
                        </span>
                    </div>
                    <div class="template-block-content">
                        ${contentHtml}
                        ${formatOptionsHtml}
                    </div>
                </div>
            `;
        }
        
        // ============ CONDITIONAL BLOCKS ============
        
        // Available variables for condition builder
        const conditionalVariables = [
            { value: 'court.type', label: 'Court Type', options: ['federal', 'state', 'bankruptcy', 'appellate'] },
            { value: 'court.state', label: 'Court State', options: [] },
            { value: 'matter.type', label: 'Matter Type', options: ['litigation', 'transactional', 'advisory', 'regulatory'] },
            { value: 'client.type', label: 'Client Type', options: ['individual', 'corporation', 'llc', 'partnership', 'government'] },
            { value: 'party.role', label: 'Party Role', options: ['plaintiff', 'defendant', 'petitioner', 'respondent'] },
            { value: 'document.type', label: 'Document Type', options: ['motion', 'brief', 'letter', 'memorandum', 'contract'] },
            { value: 'attorney.barState', label: 'Attorney Bar State', options: [] },
            { value: 'includeExhibits', label: 'Include Exhibits', options: ['true', 'false'] },
            { value: 'juryDemand', label: 'Jury Demand', options: ['true', 'false'] }
        ];
        
        // Operators for conditions
        const conditionalOperators = [
            { value: '==', label: 'equals' },
            { value: '!=', label: 'not equals' },
            { value: 'contains', label: 'contains' },
            { value: 'isEmpty', label: 'is empty' },
            { value: 'isNotEmpty', label: 'is not empty' }
        ];
        
        // Render a conditional block
        function renderConditionalBlock(block, index) {
            const conditions = block.conditions || [];
            const logic = block.conditionLogic || 'AND';
            const nestedBlocks = block.nestedBlocks || [];
            
            // Evaluate condition for preview badge
            const isShowing = evaluateConditions(conditions, logic, previewData);
            const previewBadgeClass = isShowing ? 'showing' : 'hidden';
            const previewBadgeText = isShowing ? 'Showing' : 'Hidden';
            
            // Build condition rows HTML
            let conditionsHtml = conditions.map((cond, condIndex) => {
                const varOptions = conditionalVariables.map(v => 
                    `<option value="${v.value}" ${cond.variable === v.value ? 'selected' : ''}>${v.label}</option>`
                ).join('');
                
                const opOptions = conditionalOperators.map(o =>
                    `<option value="${o.value}" ${cond.operator === o.value ? 'selected' : ''}>${o.label}</option>`
                ).join('');
                
                // Get value options for selected variable
                const selectedVar = conditionalVariables.find(v => v.value === cond.variable);
                const valueOptions = selectedVar && selectedVar.options.length > 0 
                    ? selectedVar.options.map(opt => `<option value="${opt}" ${cond.value === opt ? 'selected' : ''}>${opt}</option>`).join('')
                    : '';
                
                const needsValueInput = !['isEmpty', 'isNotEmpty'].includes(cond.operator);
                const valueInputHtml = needsValueInput ? (
                    valueOptions 
                        ? `<select class="condition-value" onchange="updateConditionValue(${index}, ${condIndex}, this.value)">
                             <option value="">Select value...</option>
                             ${valueOptions}
                           </select>`
                        : `<input type="text" class="condition-value" placeholder="Value..." 
                             value="${escapeHtml(cond.value || '')}"
                             onchange="updateConditionValue(${index}, ${condIndex}, this.value)">`
                ) : '';
                
                // Show AND/OR connector before condition (except first)
                const connectorHtml = condIndex > 0 ? `
                    <button class="condition-connector ${logic === 'AND' ? 'active' : ''}" 
                            onclick="toggleConditionLogic(${index})" title="Click to toggle AND/OR">
                        ${logic}
                    </button>
                ` : '';
                
                return `
                    <div class="condition-row" data-cond-index="${condIndex}">
                        ${connectorHtml}
                        <select class="condition-variable" onchange="updateConditionVariable(${index}, ${condIndex}, this.value)">
                            ${varOptions}
                        </select>
                        <select class="condition-operator" onchange="updateConditionOperator(${index}, ${condIndex}, this.value)">
                            ${opOptions}
                        </select>
                        ${valueInputHtml}
                        ${conditions.length > 1 ? `
                            <button class="condition-remove" onclick="removeCondition(${index}, ${condIndex})" title="Remove condition">×</button>
                        ` : ''}
                    </div>
                `;
            }).join('');
            
            // Build nested blocks HTML
            let nestedBlocksHtml = '';
            if (nestedBlocks.length > 0) {
                nestedBlocksHtml = nestedBlocks.map((nestedBlock, nestedIndex) => 
                    renderNestedBlock(nestedBlock, index, nestedIndex)
                ).join('');
            } else {
                nestedBlocksHtml = `<div class="conditional-content-placeholder">
                    Drag blocks here or <button onclick="addNestedBlock(${index}, 'text')" 
                    style="background:none;border:none;color:#8B7355;cursor:pointer;text-decoration:underline;font-size:inherit;">add text block</button>
                </div>`;
            }
            
            // Generate syntax preview
            const syntaxPreview = generateConditionSyntax(conditions, logic);
            
            return `
                <div class="template-block conditional-block" draggable="true" data-index="${index}">
                    <div class="conditional-block-header">
                        <span class="conditional-block-type">
                            <span>IF</span>
                            <span>Conditional Block</span>
                            <span class="condition-preview-badge ${previewBadgeClass}">${previewBadgeText}</span>
                        </span>
                        <span class="conditional-block-actions">
                            <button onclick="moveBlockUp(${index})" title="Move up">↑</button>
                            <button onclick="moveBlockDown(${index})" title="Move down">↓</button>
                            <button onclick="deleteBlock(${index})" title="Delete">×</button>
                        </span>
                    </div>
                    <div class="condition-builder">
                        <div style="font-size:11px;font-weight:600;color:#666;margin-bottom:8px;">IF condition is true:</div>
                        ${conditionsHtml}
                        <button class="add-condition-btn" onclick="addCondition(${index})">
                            + Add condition
                        </button>
                    </div>
                    <div class="condition-syntax">${escapeHtml(syntaxPreview)}</div>
                    <div class="conditional-content" 
                         id="conditional-content-${index}"
                         ondragover="handleConditionalDragOver(event, ${index})"
                         ondragleave="handleConditionalDragLeave(event, ${index})"
                         ondrop="handleConditionalDrop(event, ${index})">
                        ${nestedBlocksHtml}
                    </div>
                </div>
            `;
        }
        
        // Render a nested block inside a conditional
        function renderNestedBlock(block, parentIndex, nestedIndex) {
            const icons = { text: 'T', variable: 'V', separator: '—', table: '#' };
            let contentHtml = '';
            
            if (block.type === 'text') {
                contentHtml = `<textarea onchange="updateNestedBlockContent(${parentIndex}, ${nestedIndex}, this.value)" 
                    placeholder="Enter text with {{variables}}" style="min-height:40px;">${escapeHtml(block.content)}</textarea>`;
            } else if (block.type === 'variable') {
                contentHtml = `
                    <select onchange="updateNestedBlockVariable(${parentIndex}, ${nestedIndex}, this.value)" style="width:100%;">
                        <option value="date" ${block.variable === 'date' ? 'selected' : ''}>Date</option>
                        <option value="firm.name" ${block.variable === 'firm.name' ? 'selected' : ''}>Firm Name</option>
                        <option value="attorney.name" ${block.variable === 'attorney.name' ? 'selected' : ''}>Attorney Name</option>
                        <option value="client.name" ${block.variable === 'client.name' ? 'selected' : ''}>Client Name</option>
                        <option value="matter.caseNumber" ${block.variable === 'matter.caseNumber' ? 'selected' : ''}>Case Number</option>
                    </select>
                `;
            } else if (block.type === 'separator') {
                contentHtml = '<div style="text-align:center;color:#999;font-size:10px;">── Separator ──</div>';
            }
            
            return `
                <div class="template-block" data-nested-index="${nestedIndex}" style="cursor:default;">
                    <div class="template-block-header" style="padding:6px 8px;">
                        <span class="template-block-type">
                            <span>${icons[block.type] || ''}</span>
                            <span style="font-size:10px;">${block.type}</span>
                        </span>
                        <span class="template-block-actions">
                            <button onclick="moveNestedBlockUp(${parentIndex}, ${nestedIndex})" title="Move up" style="font-size:10px;">↑</button>
                            <button onclick="moveNestedBlockDown(${parentIndex}, ${nestedIndex})" title="Move down" style="font-size:10px;">↓</button>
                            <button onclick="deleteNestedBlock(${parentIndex}, ${nestedIndex})" title="Delete" style="font-size:10px;">×</button>
                        </span>
                    </div>
                    <div class="template-block-content" style="padding:8px;">
                        ${contentHtml}
                    </div>
                </div>
            `;
        }
        
        // Generate Handlebars-style syntax for display
        function generateConditionSyntax(conditions, logic) {
            if (conditions.length === 0) return '{{#if ...}}';
            
            const parts = conditions.map(cond => {
                if (cond.operator === 'isEmpty') {
                    return `!${cond.variable}`;
                } else if (cond.operator === 'isNotEmpty') {
                    return cond.variable;
                } else if (cond.operator === 'contains') {
                    return `${cond.variable} contains "${cond.value || ''}"`;
                } else {
                    return `${cond.variable} ${cond.operator} "${cond.value || ''}"`;
                }
            });
            
            const connector = logic === 'AND' ? ' && ' : ' || ';
            return `{{#if ${parts.join(connector)}}}...{{/if}}`;
        }
        
        // Evaluate conditions against data
        function evaluateConditions(conditions, logic, data) {
            if (!conditions || conditions.length === 0) return true;
            
            const results = conditions.map(cond => {
                const value = getNestedValue(data, cond.variable);
                
                switch (cond.operator) {
                    case '==':
                        return String(value).toLowerCase() === String(cond.value).toLowerCase();
                    case '!=':
                        return String(value).toLowerCase() !== String(cond.value).toLowerCase();
                    case 'contains':
                        return String(value).toLowerCase().includes(String(cond.value).toLowerCase());
                    case 'isEmpty':
                        return !value || value === '';
                    case 'isNotEmpty':
                        return value && value !== '';
                    default:
                        return false;
                }
            });
            
            if (logic === 'AND') {
                return results.every(r => r);
            } else {
                return results.some(r => r);
            }
        }
        
        // Condition manipulation functions
        function addCondition(blockIndex) {
            const block = currentTemplate.blocks[blockIndex];
            if (!block.conditions) block.conditions = [];
            
            block.conditions.push({
                id: 'cond_' + Date.now(),
                variable: 'court.type',
                operator: '==',
                value: ''
            });
            
            renderTemplateBlocks();
            updateTemplatePreview();
        }
        
        function removeCondition(blockIndex, condIndex) {
            const block = currentTemplate.blocks[blockIndex];
            if (block.conditions && block.conditions.length > 1) {
                block.conditions.splice(condIndex, 1);
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        function updateConditionVariable(blockIndex, condIndex, value) {
            const block = currentTemplate.blocks[blockIndex];
            if (block.conditions && block.conditions[condIndex]) {
                block.conditions[condIndex].variable = sanitizeShortText(value);
                block.conditions[condIndex].value = ''; // Reset value when variable changes
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        function updateConditionOperator(blockIndex, condIndex, value) {
            const block = currentTemplate.blocks[blockIndex];
            if (block.conditions && block.conditions[condIndex]) {
                block.conditions[condIndex].operator = sanitizeShortText(value);
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        function updateConditionValue(blockIndex, condIndex, value) {
            const block = currentTemplate.blocks[blockIndex];
            if (block.conditions && block.conditions[condIndex]) {
                block.conditions[condIndex].value = sanitizeInput(value);
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        function toggleConditionLogic(blockIndex) {
            const block = currentTemplate.blocks[blockIndex];
            block.conditionLogic = block.conditionLogic === 'AND' ? 'OR' : 'AND';
            renderTemplateBlocks();
            updateTemplatePreview();
        }
        
        // Nested block functions
        function addNestedBlock(parentIndex, type) {
            const block = currentTemplate.blocks[parentIndex];
            if (!block.nestedBlocks) block.nestedBlocks = [];
            
            const nestedBlock = createBlockOfType(type);
            // Simplify content for nested blocks
            if (type === 'text') {
                nestedBlock.content = 'Conditional content here...';
            }
            
            block.nestedBlocks.push(nestedBlock);
            renderTemplateBlocks();
            updateTemplatePreview();
        }
        
        function updateNestedBlockContent(parentIndex, nestedIndex, value) {
            const block = currentTemplate.blocks[parentIndex];
            if (block.nestedBlocks && block.nestedBlocks[nestedIndex]) {
                block.nestedBlocks[nestedIndex].content = sanitizeInput(value);
                updateTemplatePreview();
            }
        }
        
        function updateNestedBlockVariable(parentIndex, nestedIndex, value) {
            const block = currentTemplate.blocks[parentIndex];
            if (block.nestedBlocks && block.nestedBlocks[nestedIndex]) {
                block.nestedBlocks[nestedIndex].variable = sanitizeShortText(value);
                updateTemplatePreview();
            }
        }
        
        function moveNestedBlockUp(parentIndex, nestedIndex) {
            const block = currentTemplate.blocks[parentIndex];
            if (block.nestedBlocks && nestedIndex > 0) {
                const temp = block.nestedBlocks[nestedIndex];
                block.nestedBlocks[nestedIndex] = block.nestedBlocks[nestedIndex - 1];
                block.nestedBlocks[nestedIndex - 1] = temp;
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        function moveNestedBlockDown(parentIndex, nestedIndex) {
            const block = currentTemplate.blocks[parentIndex];
            if (block.nestedBlocks && nestedIndex < block.nestedBlocks.length - 1) {
                const temp = block.nestedBlocks[nestedIndex];
                block.nestedBlocks[nestedIndex] = block.nestedBlocks[nestedIndex + 1];
                block.nestedBlocks[nestedIndex + 1] = temp;
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        function deleteNestedBlock(parentIndex, nestedIndex) {
            const block = currentTemplate.blocks[parentIndex];
            if (block.nestedBlocks) {
                block.nestedBlocks.splice(nestedIndex, 1);
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        // Drag and drop for nested blocks
        function handleConditionalDragOver(event, parentIndex) {
            event.preventDefault();
            event.stopPropagation();
            const content = document.getElementById(`conditional-content-${parentIndex}`);
            if (content) content.classList.add('drag-over');
        }
        
        function handleConditionalDragLeave(event, parentIndex) {
            event.stopPropagation();
            const content = document.getElementById(`conditional-content-${parentIndex}`);
            if (content && !content.contains(event.relatedTarget)) {
                content.classList.remove('drag-over');
            }
        }
        
        function handleConditionalDrop(event, parentIndex) {
            event.preventDefault();
            event.stopPropagation();
            
            const content = document.getElementById(`conditional-content-${parentIndex}`);
            if (content) content.classList.remove('drag-over');
            
            // Check if dropping from palette
            if (draggedBlockType && draggedBlockType !== 'conditional') {
                addNestedBlock(parentIndex, draggedBlockType);
            }
            
            draggedBlockType = null;
            draggedBlockIndex = null;
        }
        
        // ============ END CONDITIONAL BLOCKS ============
        
        // Render paragraph formatting options for a block
        function renderBlockFormatOptions(block, index) {
            const keepTogether = block.keepTogether || false;
            const keepWithNext = block.keepWithNext || false;
            const widowControl = block.widowControl !== false; // Default true
            
            return `
                <div class="block-format-options">
                    <div class="block-format-header">Page Break Control</div>
                    <div class="block-format-row">
                        <input type="checkbox" id="keep-together-${index}" 
                            ${keepTogether ? 'checked' : ''} 
                            onchange="updateBlockFormat(${index}, 'keepTogether', this.checked)">
                        <label for="keep-together-${index}">Keep lines together</label>
                        <span class="format-hint">Won't split across pages</span>
                    </div>
                    <div class="block-format-row">
                        <input type="checkbox" id="keep-with-next-${index}" 
                            ${keepWithNext ? 'checked' : ''} 
                            onchange="updateBlockFormat(${index}, 'keepWithNext', this.checked)">
                        <label for="keep-with-next-${index}">Keep with next</label>
                        <span class="format-hint">Stays with following block</span>
                    </div>
                    <div class="block-format-row">
                        <input type="checkbox" id="widow-control-${index}" 
                            ${widowControl ? 'checked' : ''} 
                            onchange="updateBlockFormat(${index}, 'widowControl', this.checked)">
                        <label for="widow-control-${index}">Widow/orphan control</label>
                        <span class="format-hint">No single lines at page edges</span>
                    </div>
                </div>
            `;
        }
        
        // Update block formatting option
        function updateBlockFormat(index, property, value) {
            currentTemplate.blocks[index][property] = value;
            updateTemplatePreview();
        }
        
        // ============ OOXML TABLE EDITOR ============
        
        // Render the table editor UI
        function renderTableEditor(block, index) {
            const rowCount = block.rowCount || 3;
            const colCount = block.colCount || 2;
            const hasHeaderRow = block.hasHeaderRow !== false;
            const borderStyle = block.borderStyle || 'all';
            const headerStyle = block.headerStyle || 'bold-shaded';
            const columnWidths = block.columnWidths || 'equal';
            
            // Ensure cells array exists and has correct dimensions
            if (!block.cells || block.cells.length !== rowCount || (block.cells[0] && block.cells[0].length !== colCount)) {
                block.cells = [];
                for (let r = 0; r < rowCount; r++) {
                    block.cells[r] = [];
                    for (let c = 0; c < colCount; c++) {
                        block.cells[r][c] = (r === 0 && hasHeaderRow) ? `Header ${c + 1}` : '';
                    }
                }
            }
            
            // Build table grid HTML
            let gridHtml = '';
            for (let r = 0; r < rowCount; r++) {
                const isHeader = hasHeaderRow && r === 0;
                gridHtml += `<div class="table-row ${isHeader ? 'header-row' : ''}">`;
                for (let c = 0; c < colCount; c++) {
                    const cellValue = block.cells[r] && block.cells[r][c] ? escapeHtml(block.cells[r][c]) : '';
                    gridHtml += `
                        <div class="table-cell">
                            <input type="text" class="table-cell-input" 
                                value="${cellValue}"
                                placeholder="${isHeader ? 'Header' : 'Cell content or {{var}}'}"
                                onchange="updateTableCell(${index}, ${r}, ${c}, this.value)">
                        </div>
                    `;
                }
                gridHtml += '</div>';
            }
            
            return `
                <div class="table-editor">
                    <div class="table-controls">
                        <div class="table-control-group">
                            <label>Rows</label>
                            <input type="number" min="1" max="20" value="${rowCount}"
                                onchange="updateTableDimensions(${index}, 'rowCount', parseInt(this.value))">
                        </div>
                        <div class="table-control-group">
                            <label>Columns</label>
                            <input type="number" min="1" max="10" value="${colCount}"
                                onchange="updateTableDimensions(${index}, 'colCount', parseInt(this.value))">
                        </div>
                        <div class="table-control-group">
                            <label>Borders</label>
                            <select onchange="updateTableOption(${index}, 'borderStyle', this.value)">
                                <option value="all" ${borderStyle === 'all' ? 'selected' : ''}>All borders</option>
                                <option value="outside" ${borderStyle === 'outside' ? 'selected' : ''}>Outside only</option>
                                <option value="none" ${borderStyle === 'none' ? 'selected' : ''}>No borders</option>
                            </select>
                        </div>
                        <div class="table-control-group">
                            <label>Header Style</label>
                            <select onchange="updateTableOption(${index}, 'headerStyle', this.value)">
                                <option value="bold-shaded" ${headerStyle === 'bold-shaded' ? 'selected' : ''}>Bold + Shaded</option>
                                <option value="bold" ${headerStyle === 'bold' ? 'selected' : ''}>Bold only</option>
                                <option value="shaded" ${headerStyle === 'shaded' ? 'selected' : ''}>Shaded only</option>
                                <option value="none" ${headerStyle === 'none' ? 'selected' : ''}>Plain</option>
                            </select>
                        </div>
                        <div class="table-control-group">
                            <label>Column Width</label>
                            <select onchange="updateTableOption(${index}, 'columnWidths', this.value)">
                                <option value="equal" ${columnWidths === 'equal' ? 'selected' : ''}>Equal</option>
                                <option value="auto" ${columnWidths === 'auto' ? 'selected' : ''}>Auto-fit</option>
                            </select>
                        </div>
                        <div class="table-control-group">
                            <div class="table-control-inline">
                                <input type="checkbox" id="header-row-${index}" 
                                    ${hasHeaderRow ? 'checked' : ''} 
                                    onchange="updateTableOption(${index}, 'hasHeaderRow', this.checked)">
                                <label for="header-row-${index}">Header row</label>
                            </div>
                        </div>
                    </div>
                    <div class="table-grid-editor">
                        ${gridHtml}
                    </div>
                    <div class="table-style-preview">
                        Inserts as a real Word table with <code>${borderStyle}</code> borders
                        ${hasHeaderRow ? '• Header row will repeat on each page' : ''}
                    </div>
                </div>
            `;
        }
        
        // Update table cell content
        function updateTableCell(blockIndex, row, col, value) {
            const block = currentTemplate.blocks[blockIndex];
            if (!block.cells[row]) block.cells[row] = [];
            block.cells[row][col] = sanitizeInput(value);
            updateTemplatePreview();
        }
        
        // Update table dimensions (row/col count)
        function updateTableDimensions(blockIndex, prop, value) {
            const block = currentTemplate.blocks[blockIndex];
            const oldRows = block.rowCount || 3;
            const oldCols = block.colCount || 2;
            
            block[prop] = Math.max(1, Math.min(prop === 'rowCount' ? 20 : 10, value));
            
            const newRows = block.rowCount;
            const newCols = block.colCount;
            
            // Resize cells array, preserving existing content
            const newCells = [];
            for (let r = 0; r < newRows; r++) {
                newCells[r] = [];
                for (let c = 0; c < newCols; c++) {
                    if (block.cells && block.cells[r] && block.cells[r][c] !== undefined) {
                        newCells[r][c] = block.cells[r][c];
                    } else {
                        newCells[r][c] = (r === 0 && block.hasHeaderRow) ? `Header ${c + 1}` : '';
                    }
                }
            }
            block.cells = newCells;
            
            renderTemplateBlocks();
            updateTemplatePreview();
        }
        
        // Update table styling options
        function updateTableOption(blockIndex, prop, value) {
            currentTemplate.blocks[blockIndex][prop] = value;
            renderTemplateBlocks();
            updateTemplatePreview();
        }
        
        // ============ OOXML TABLE GENERATION ============
        
        // Generate OOXML for a Word table
        function generateTableOoxml(block, variables) {
            const rowCount = block.rowCount || 3;
            const colCount = block.colCount || 2;
            const hasHeaderRow = block.hasHeaderRow !== false;
            const borderStyle = block.borderStyle || 'all';
            const headerStyle = block.headerStyle || 'bold-shaded';
            const columnWidths = block.columnWidths || 'equal';
            
            // Calculate column widths (in twentieths of a point, 1440 twips = 1 inch)
            // Page width ~8.5", margins ~1.25" each = ~6" usable = ~8640 twips
            const totalWidth = 8640;
            const colWidth = Math.floor(totalWidth / colCount);
            
            // Build border properties
            let borderXml = '';
            if (borderStyle === 'all') {
                borderXml = `
                    <w:tblBorders>
                        <w:top w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:left w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:bottom w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:right w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:insideH w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:insideV w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                    </w:tblBorders>`;
            } else if (borderStyle === 'outside') {
                borderXml = `
                    <w:tblBorders>
                        <w:top w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:left w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:bottom w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:right w:val="single" w:sz="4" w:space="0" w:color="000000"/>
                        <w:insideH w:val="nil"/>
                        <w:insideV w:val="nil"/>
                    </w:tblBorders>`;
            } else {
                borderXml = `
                    <w:tblBorders>
                        <w:top w:val="nil"/>
                        <w:left w:val="nil"/>
                        <w:bottom w:val="nil"/>
                        <w:right w:val="nil"/>
                        <w:insideH w:val="nil"/>
                        <w:insideV w:val="nil"/>
                    </w:tblBorders>`;
            }
            
            // Build column definitions
            let gridColXml = '';
            for (let c = 0; c < colCount; c++) {
                gridColXml += `<w:gridCol w:w="${colWidth}"/>`;
            }
            
            // Build table rows
            let rowsXml = '';
            for (let r = 0; r < rowCount; r++) {
                const isHeader = hasHeaderRow && r === 0;
                let rowXml = '<w:tr>';
                
                // Header row properties
                if (isHeader) {
                    rowXml += `<w:trPr><w:tblHeader/></w:trPr>`;
                }
                
                // Build cells for this row
                for (let c = 0; c < colCount; c++) {
                    let cellContent = block.cells && block.cells[r] && block.cells[r][c] ? block.cells[r][c] : '';
                    
                    // Substitute variables
                    cellContent = substituteVariables(cellContent, variables);
                    
                    // Cell properties
                    let cellPropsXml = `<w:tcPr><w:tcW w:w="${colWidth}" w:type="dxa"/>`;
                    
                    // Header cell shading
                    if (isHeader && (headerStyle === 'shaded' || headerStyle === 'bold-shaded')) {
                        cellPropsXml += `<w:shd w:val="clear" w:color="auto" w:fill="E8E8E8"/>`;
                    }
                    cellPropsXml += '</w:tcPr>';
                    
                    // Run properties (bold for header)
                    let runPropsXml = '';
                    if (isHeader && (headerStyle === 'bold' || headerStyle === 'bold-shaded')) {
                        runPropsXml = '<w:rPr><w:b/></w:rPr>';
                    }
                    
                    rowXml += `
                        <w:tc>
                            ${cellPropsXml}
                            <w:p>
                                <w:r>
                                    ${runPropsXml}
                                    <w:t>${escapeXml(cellContent)}</w:t>
                                </w:r>
                            </w:p>
                        </w:tc>`;
                }
                
                rowXml += '</w:tr>';
                rowsXml += rowXml;
            }
            
            // Complete OOXML package with relationships
            const ooxml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
                <pkg:package xmlns:pkg="http://schemas.microsoft.com/office/2006/xmlPackage">
                    <pkg:part pkg:name="/_rels/.rels" pkg:contentType="application/vnd.openxmlformats-package.relationships+xml">
                        <pkg:xmlData>
                            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
                                <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
                            </Relationships>
                        </pkg:xmlData>
                    </pkg:part>
                    <pkg:part pkg:name="/word/document.xml" pkg:contentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml">
                        <pkg:xmlData>
                            <w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                                <w:body>
                                    <w:tbl>
                                        <w:tblPr>
                                            <w:tblStyle w:val="TableGrid"/>
                                            <w:tblW w:w="${totalWidth}" w:type="dxa"/>
                                            ${borderXml}
                                            <w:tblLook w:val="04A0" w:firstRow="1" w:lastRow="0" w:firstColumn="1" w:lastColumn="0" w:noHBand="0" w:noVBand="1"/>
                                        </w:tblPr>
                                        <w:tblGrid>
                                            ${gridColXml}
                                        </w:tblGrid>
                                        ${rowsXml}
                                    </w:tbl>
                                </w:body>
                            </w:document>
                        </pkg:xmlData>
                    </pkg:part>
                </pkg:package>`;
            
            return ooxml;
        }
        
        // Block manipulation functions
        function updateBlockContent(index, value) {
            // Sanitize content to prevent XSS (P0 fix)
            currentTemplate.blocks[index].content = sanitizeInput(value);
            updateTemplatePreview();
        }
        
        function updateBlockVariable(index, value) {
            // Sanitize variable name to prevent injection
            currentTemplate.blocks[index].variable = sanitizeShortText(value);
            updateTemplatePreview();
        }
        
        function updateTableRows(index, value) {
            // Convert newline-separated text back to rows array, sanitize each row
            currentTemplate.blocks[index].rows = value.split('\n').map(line => [sanitizeInput(line)]);
            updateTemplatePreview();
        }
        
        function moveBlockUp(index) {
            if (index > 0) {
                const temp = currentTemplate.blocks[index];
                currentTemplate.blocks[index] = currentTemplate.blocks[index - 1];
                currentTemplate.blocks[index - 1] = temp;
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        function moveBlockDown(index) {
            if (index < currentTemplate.blocks.length - 1) {
                const temp = currentTemplate.blocks[index];
                currentTemplate.blocks[index] = currentTemplate.blocks[index + 1];
                currentTemplate.blocks[index + 1] = temp;
                renderTemplateBlocks();
                updateTemplatePreview();
            }
        }
        
        let lastDeletedBlock = null;
        let lastDeletedIndex = null;
        
        function deleteBlock(index) {
            // Save for undo
            lastDeletedBlock = currentTemplate.blocks[index];
            lastDeletedIndex = index;
            
            currentTemplate.blocks.splice(index, 1);
            renderTemplateBlocks();
            updateTemplatePreview();
            
            // Show toast with undo
            showUndoToast('Block deleted', undoDeleteBlock);
        }
        
        function undoDeleteBlock() {
            if (lastDeletedBlock && lastDeletedIndex !== null) {
                currentTemplate.blocks.splice(lastDeletedIndex, 0, lastDeletedBlock);
                renderTemplateBlocks();
                updateTemplatePreview();
                lastDeletedBlock = null;
                lastDeletedIndex = null;
                toast('Block restored', 'success', 2000);
            }
        }
        
        function showUndoToast(message, undoCallback) {
            // Remove any existing toast
            const existing = document.querySelector('.toast-notification');
            if (existing) existing.remove();
            
            const toastEl = document.createElement('div');
            toastEl.className = 'toast-notification toast-info';
            toastEl.innerHTML = `
                ${message} 
                <button onclick="event.stopPropagation(); this.parentElement.remove(); (${undoCallback.toString()})();" 
                    style="margin-left: 12px; background: white; border: none; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-weight: 600;">
                    Undo
                </button>
            `;
            document.body.appendChild(toastEl);
            
            setTimeout(() => toastEl.classList.add('show'), 10);
            
            // Remove after 5 seconds (longer for undo toasts)
            setTimeout(() => {
                toastEl.classList.remove('show');
                setTimeout(() => toastEl.remove(), 300);
            }, 5000);
        }
        
        // Preview functions
        function toggleTemplatePreview() {
            const preview = document.getElementById('template-preview');
            const btn = document.getElementById('preview-toggle-btn');
            
            if (preview.style.display === 'none') {
                preview.style.display = 'block';
                btn.textContent = 'Hide Preview';
                updateTemplatePreview();
            } else {
                preview.style.display = 'none';
                btn.textContent = 'Show Preview';
            }
        }
        
        function updateTemplatePreview() {
            const previewEl = document.getElementById('preview-content');
            if (!previewEl || document.getElementById('template-preview').style.display === 'none') return;
            
            const courtType = document.getElementById('preview-court-type').value;
            previewData.court.type = courtType;
            
            let rendered = '';
            
            for (const block of currentTemplate.blocks) {
                rendered += renderBlockPreview(block, previewData) + '\n';
            }
            
            previewEl.textContent = rendered || '(Empty template)';
        }
        
        function renderBlockPreview(block, data) {
            if (block.type === 'text') {
                return substituteVariables(block.content, data);
            } else if (block.type === 'variable') {
                return getNestedValue(data, block.variable) || `{{${block.variable}}}`;
            } else if (block.type === 'separator') {
                return '────────────────────────────────────────';
            } else if (block.type === 'table') {
                // Render table preview as ASCII art
                if (!block.cells || !block.cells.length) return '[Empty Table]';
                
                const colCount = block.colCount || 2;
                const colWidth = 20;
                const separator = '+' + ('-'.repeat(colWidth) + '+').repeat(colCount);
                
                let lines = [separator];
                for (let r = 0; r < block.cells.length; r++) {
                    let row = '|';
                    for (let c = 0; c < colCount; c++) {
                        let cellContent = block.cells[r] && block.cells[r][c] ? block.cells[r][c] : '';
                        cellContent = substituteVariables(cellContent, data);
                        // Truncate and pad
                        if (cellContent.length > colWidth - 2) {
                            cellContent = cellContent.substring(0, colWidth - 5) + '...';
                        }
                        row += ' ' + cellContent.padEnd(colWidth - 2) + ' |';
                    }
                    lines.push(row);
                    lines.push(separator);
                }
                return lines.join('\n');
            } else if (block.type === 'conditional') {
                // Evaluate condition and render nested blocks if true
                const conditions = block.conditions || [];
                const logic = block.conditionLogic || 'AND';
                const isShowing = evaluateConditions(conditions, logic, data);
                
                if (isShowing && block.nestedBlocks && block.nestedBlocks.length > 0) {
                    // Render all nested blocks
                    return block.nestedBlocks.map(nestedBlock => 
                        renderBlockPreview(nestedBlock, data)
                    ).filter(content => content).join('\n');
                } else if (!isShowing) {
                    // Show placeholder when condition is false
                    return `[HIDDEN: ${generateConditionSyntax(conditions, logic)}]`;
                }
                return '';
            }
            return '';
        }
        
        function substituteVariables(text, data) {
            return text.replace(/\{\{([^}]+)\}\}/g, (match, varPath) => {
                const value = getNestedValue(data, varPath.trim());
                return value !== undefined ? value : match;
            });
        }
        
        function getNestedValue(obj, path) {
            return path.split('.').reduce((current, key) => {
                return current && current[key] !== undefined ? current[key] : undefined;
            }, obj);
        }
        
        // Update save status indicator
        function updateSaveStatus(status, message) {
            const el = document.getElementById('template-save-status');
            if (!el) return;
            el.className = 'save-status ' + status;
            el.textContent = message;
        }
        
        // ============ OFFLINE SYNC INFRASTRUCTURE ============
        
        // Track pending offline changes
        function getPendingTemplates() {
            try {
                return JSON.parse(localStorage.getItem('draftbridge_templates_pending') || '[]');
            } catch (e) {
                return [];
            }
        }
        
        function setPendingTemplates(pending) {
            localStorage.setItem('draftbridge_templates_pending', JSON.stringify(pending));
        }
        
        function addPendingChange(templateId, action, template = null) {
            const pending = getPendingTemplates();
            // Remove existing entry for same template (only keep latest)
            const filtered = pending.filter(p => p.templateId !== templateId);
            filtered.push({
                templateId,
                action, // 'save' | 'delete'
                template,
                timestamp: new Date().toISOString()
            });
            setPendingTemplates(filtered);
            updateSyncBadge();
        }
        
        function removePendingChange(templateId) {
            const pending = getPendingTemplates();
            setPendingTemplates(pending.filter(p => p.templateId !== templateId));
            updateSyncBadge();
        }
        
        // Update sync status badge
        function updateSyncBadge(status = null) {
            const badge = document.getElementById('templates-sync-status');
            if (!badge) return;
            
            const pending = getPendingTemplates();
            
            if (status === 'syncing') {
                badge.className = 'sync-badge syncing';
                badge.textContent = '⟳ Syncing...';
                badge.style.display = 'inline';
            } else if (pending.length > 0) {
                badge.className = 'sync-badge pending';
                badge.textContent = `${pending.length} pending`;
                badge.style.display = 'inline';
            } else if (status === 'synced') {
                badge.className = 'sync-badge synced';
                badge.textContent = 'Synced';
                badge.style.display = 'inline';
                // Hide after 3 seconds
                setTimeout(() => {
                    if (badge.classList.contains('synced')) {
                        badge.style.display = 'none';
                    }
                }, 3000);
            } else {
                badge.style.display = 'none';
            }
        }
        
        // Sync offline changes when reconnecting
        async function syncOfflineTemplates() {
            const pending = getPendingTemplates();
            if (pending.length === 0) {
                updateSyncBadge();
                return;
            }
            
            updateSyncBadge('syncing');
            // Syncing offline changes
            let synced = 0, conflicts = 0, errors = 0;
            
            for (const change of pending) {
                try {
                    if (change.action === 'delete') {
                        // Sync delete
                        const resp = await fetch(`${API}/templates/${change.templateId}`, {
                            method: 'DELETE',
                            headers: apiHeaders()
                        });
                        if (resp.ok || resp.status === 404) {
                            removePendingChange(change.templateId);
                            synced++;
                        } else {
                            errors++;
                        }
                    } else if (change.action === 'save' && change.template) {
                        // Check for conflicts
                        const cloudResp = await fetch(`${API}/templates/${change.templateId}`, { headers: apiHeaders() });
                        
                        if (cloudResp.ok) {
                            // Template exists in cloud - check for conflict
                            const cloudTemplate = await cloudResp.json();
                            const cloudTime = new Date(cloudTemplate.updatedAt || 0).getTime();
                            const localTime = new Date(change.template.updatedAt || 0).getTime();
                            
                            if (cloudTime > localTime) {
                                // Cloud is newer - conflict! Keep cloud version
                                console.warn(`[Sync] Conflict: ${change.templateId} - cloud is newer, keeping cloud version`);
                                conflicts++;
                                removePendingChange(change.templateId);
                                // Update local cache with cloud version
                                const templates = JSON.parse(localStorage.getItem('draftbridge_templates') || '[]');
                                const idx = templates.findIndex(t => t.id === change.templateId);
                                if (idx >= 0) templates[idx] = cloudTemplate;
                                else templates.push(cloudTemplate);
                                localStorage.setItem('draftbridge_templates', JSON.stringify(templates));
                            } else {
                                // Local is newer - push to cloud
                                const resp = await fetch(`${API}/templates/${change.templateId}`, {
                                    method: 'PUT',
                                    headers: apiHeaders(),
                                    body: JSON.stringify(change.template)
                                });
                                if (resp.ok) {
                                    removePendingChange(change.templateId);
                                    synced++;
                                } else {
                                    errors++;
                                }
                            }
                        } else if (cloudResp.status === 404) {
                            // New template - create it
                            const resp = await fetch(`${API}/templates`, {
                                method: 'POST',
                                headers: apiHeaders(),
                                body: JSON.stringify(change.template)
                            });
                            if (resp.ok) {
                                removePendingChange(change.templateId);
                                synced++;
                            } else {
                                errors++;
                            }
                        } else {
                            errors++;
                        }
                    }
                } catch (err) {
                    console.error(`[Sync] Failed to sync ${change.templateId}:`, err);
                    errors++;
                }
            }
            
            // Report results
            const remaining = getPendingTemplates().length;
            
            if (synced > 0 || conflicts > 0) {
                if (conflicts > 0) {
                    toast(`Synced ${synced} template(s), ${conflicts} conflict(s) resolved (cloud wins)`, 'warning');
                } else if (remaining === 0) {
                    toast(`${synced} offline template(s) synced to cloud`, 'success');
                } else {
                    toast(`Synced ${synced}, ${remaining} still pending`, 'warning');
                }
                // Refresh template list
                if (document.getElementById('templates-container')?.style.display !== 'none') {
                    loadSavedTemplates();
                }
            }
            
            // Update badge: show synced if complete, or pending count
            if (remaining === 0 && synced > 0) {
                updateSyncBadge('synced');
            } else {
                updateSyncBadge();
            }
        }
        
        // Listen for online event to trigger sync
        window.addEventListener('online', () => {
            // Back online, syncing offline changes
            setTimeout(syncOfflineTemplates, 1000); // Small delay to let network stabilize
        });
        
        // Also sync on page load if online
        document.addEventListener('DOMContentLoaded', () => {
            if (navigator.onLine) {
                setTimeout(syncOfflineTemplates, 2000);
            }
        });
        
        // ============ END OFFLINE SYNC INFRASTRUCTURE ============
        
        // Save template to API (with localStorage cache)
        async function saveTemplate() {
            const name = document.getElementById('template-name').value.trim();
            
            if (!name) {
                toast('Please enter a template name', 'error');
                document.getElementById('template-name').focus();
                return;
            }
            
            if (currentTemplate.blocks.length === 0) {
                toast('Add at least one section to your template', 'error');
                return;
            }
            
            currentTemplate.name = name;
            updateSaveStatus('saving', 'Saving...');
            
            try {
                let savedTemplate;
                
                if (editingTemplateId) {
                    // Update existing via API
                    const resp = await fetch(`${API}/templates/${editingTemplateId}`, {
                        method: 'PUT',
                        headers: apiHeaders(),
                        body: JSON.stringify({
                            name: currentTemplate.name,
                            blocks: currentTemplate.blocks,
                            firmId: 'default'
                        })
                    });
                    if (!resp.ok) throw new Error(`API error: ${resp.status}`);
                    savedTemplate = await resp.json();
                } else {
                    // Create new via API
                    // Generate ID with only alphanumeric + underscore (P0 fix - backend validation)
                    currentTemplate.id = 'tpl_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9).replace(/[^a-zA-Z0-9]/g, '');
                    const resp = await fetch(`${API}/templates`, {
                        method: 'POST',
                        headers: apiHeaders(),
                        body: JSON.stringify({
                            id: currentTemplate.id,
                            name: currentTemplate.name,
                            blocks: currentTemplate.blocks,
                            firmId: 'default'
                        })
                    });
                    if (!resp.ok) throw new Error(`API error: ${resp.status}`);
                    savedTemplate = await resp.json();
                }
                
                // Update localStorage cache
                const templates = JSON.parse(localStorage.getItem('draftbridge_templates') || '[]');
                const idx = templates.findIndex(t => t.id === savedTemplate.id);
                if (idx >= 0) {
                    templates[idx] = savedTemplate;
                } else {
                    templates.push(savedTemplate);
                }
                localStorage.setItem('draftbridge_templates', JSON.stringify(templates));
                
                // Clear any pending sync for this template (now synced)
                removePendingChange(savedTemplate.id);
                
                toast(`Template "${name}" saved!`, 'success');
                updateSaveStatus('saved', 'Saved at ' + new Date().toLocaleTimeString());
                hideTemplateEditor();
                showTemplateList();
            } catch (err) {
                console.error('Failed to save template to API:', err);
                
                // Fallback: save to localStorage only + track for sync
                const templates = JSON.parse(localStorage.getItem('draftbridge_templates') || '[]');
                let templateToSync;
                
                if (editingTemplateId) {
                    const idx = templates.findIndex(t => t.id === editingTemplateId);
                    templateToSync = { ...currentTemplate, id: editingTemplateId, updatedAt: new Date().toISOString(), firmId: 'default' };
                    if (idx >= 0) {
                        templates[idx] = templateToSync;
                    } else {
                        templates.push(templateToSync);
                    }
                } else {
                    // Consistent ID format with API version (P0 fix)
                    currentTemplate.id = 'tpl_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9).replace(/[^a-zA-Z0-9]/g, '');
                    currentTemplate.createdAt = new Date().toISOString();
                    currentTemplate.updatedAt = currentTemplate.createdAt;
                    currentTemplate.firmId = 'default';
                    templateToSync = { ...currentTemplate };
                    templates.push(templateToSync);
                }
                
                localStorage.setItem('draftbridge_templates', JSON.stringify(templates));
                
                // Track for sync when back online
                addPendingChange(templateToSync.id, 'save', templateToSync);
                
                toast(`Saved locally (will sync when online)`, 'warning');
                updateSaveStatus('saved', 'Saved locally at ' + new Date().toLocaleTimeString());
                hideTemplateEditor();
                showTemplateList();
            }
        }
        
        // Migrate local-only templates to cloud (one-time)
        async function migrateLocalTemplatesToCloud(cloudTemplates) {
            try {
                const localTemplates = JSON.parse(localStorage.getItem('draftbridge_templates') || '[]');
                const cloudIds = new Set(cloudTemplates.map(t => t.id));
                
                // Find templates that exist locally but not in cloud
                const localOnly = localTemplates.filter(t => 
                    t && t.id && !cloudIds.has(t.id) &&
                    typeof t.name === 'string' && Array.isArray(t.blocks)
                );
                
                if (localOnly.length === 0) return cloudTemplates;
                
                // Migrating local-only templates to cloud
                const migrated = [];
                
                for (const template of localOnly) {
                    try {
                        const resp = await fetch(`${API}/templates`, {
                            method: 'POST',
                            headers: apiHeaders(),
                            body: JSON.stringify({
                                id: template.id,
                                name: template.name,
                                blocks: template.blocks,
                                firmId: template.firmId || 'default',
                                description: template.description || '',
                                category: template.category || 'General'
                            })
                        });
                        
                        if (resp.ok) {
                            const saved = await resp.json();
                            migrated.push(saved);
                            // Template migrated to cloud
                        } else if (resp.status === 409) {
                            // Conflict - template exists with same ID, skip
                            // Template already exists, skipped
                        } else {
                            console.warn(`[Migration] Failed to migrate "${template.name}": ${resp.status}`);
                        }
                    } catch (err) {
                        console.warn(`[Migration] Error migrating "${template.name}":`, err);
                    }
                }
                
                if (migrated.length > 0) {
                    toast(`Migrated ${migrated.length} template(s) to cloud`, 'success');
                    // Mark migration as complete to avoid re-running
                    localStorage.setItem('draftbridge_templates_migrated', 'true');
                }
                
                // Merge: cloud templates + successfully migrated
                return [...cloudTemplates, ...migrated];
            } catch (err) {
                console.error('[Migration] Error:', err);
                return cloudTemplates;
            }
        }
        
        // Load saved templates from API (with localStorage fallback)
        async function loadSavedTemplates() {
            const container = document.getElementById('templates-container');
            const emptyState = document.getElementById('no-templates');
            
            // Show loading state
            container.innerHTML = '<div class="template-loading">Loading templates...</div>';
            container.style.display = 'block';
            emptyState.style.display = 'none';
            
            // Sync any pending offline changes first (if online)
            const pending = getPendingTemplates();
            if (pending.length > 0 && navigator.onLine) {
                await syncOfflineTemplates();
            }
            
            let rawTemplates = [];
            let fromApi = false;
            
            try {
                // Fetch from API
                const resp = await fetch(`${API}/templates?firmId=default`, { headers: apiHeaders() });
                if (resp.ok) {
                    const data = await resp.json();
                    rawTemplates = data.templates || [];
                    fromApi = true;
                    
                    // One-time migration: push local-only templates to cloud
                    if (!localStorage.getItem('draftbridge_templates_migrated')) {
                        rawTemplates = await migrateLocalTemplatesToCloud(rawTemplates);
                    }
                    
                    // Update localStorage cache
                    localStorage.setItem('draftbridge_templates', JSON.stringify(rawTemplates));
                } else {
                    throw new Error(`API error: ${resp.status}`);
                }
            } catch (err) {
                console.warn('Failed to fetch templates from API, using cache:', err);
                // Fallback to localStorage
                try {
                    rawTemplates = JSON.parse(localStorage.getItem('draftbridge_templates') || '[]');
                } catch (e) {
                    console.error('Invalid templates in localStorage:', e);
                    rawTemplates = [];
                }
            }
            
            // Validate template schema (defense in depth)
            savedTemplates = (Array.isArray(rawTemplates) ? rawTemplates : []).filter(t => 
                t && 
                typeof t.id === 'string' && /^[a-zA-Z0-9_]+$/.test(t.id) &&
                typeof t.name === 'string' && t.name.length <= 200 &&
                Array.isArray(t.blocks) && t.blocks.length <= 100
            );
            
            if (savedTemplates.length === 0) {
                container.style.display = 'none';
                emptyState.style.display = 'block';
                updateSyncBadge();
                return;
            }
            
            container.style.display = 'block';
            emptyState.style.display = 'none';
            
            container.innerHTML = savedTemplates.map(template => {
                // Validate template ID format (alphanumeric + underscore only)
                const safeId = /^[a-zA-Z0-9_]+$/.test(template.id) ? template.id : '';
                if (!safeId) return ''; // Skip templates with invalid IDs
                
                return `
                <div class="template-card" data-template-id="${safeId}">
                    <div class="template-card-info">
                        <div class="template-card-name">${escapeHtml(template.name)}</div>
                        <div class="template-card-desc">${template.blocks.length} block${template.blocks.length !== 1 ? 's' : ''}</div>
                    </div>
                    <div class="template-card-actions">
                        <button class="tpl-edit-btn" data-action="edit">Edit</button>
                        <button class="tpl-delete-btn" data-action="delete">Delete</button>
                        <button class="primary tpl-insert-btn" data-action="insert">Insert</button>
                    </div>
                </div>
            `}).join('');
            
            // Event delegation for template actions (XSS-safe)
            container.querySelectorAll('.template-card-actions button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = btn.closest('.template-card');
                    const templateId = card.dataset.templateId;
                    if (!templateId) return;
                    
                    const action = btn.dataset.action;
                    if (action === 'edit') showTemplateEditor(templateId);
                    else if (action === 'delete') deleteTemplate(templateId);
                    else if (action === 'insert') insertTemplate(templateId);
                });
            });
            
            // Update sync badge to show pending changes (if any)
            updateSyncBadge();
        }
        
        // Delete template from API (with localStorage sync)
        async function deleteTemplate(templateId) {
            // Find template name for better confirmation (Evvie UX fix)
            const template = savedTemplates.find(t => t.id === templateId);
            const templateName = template ? template.name : 'this template';
            
            const confirmed = await SmartVariables.showConfirm(`Are you sure you want to delete "${templateName}"? This cannot be undone.`, { destructive: true, confirmText: 'Delete' });
            if (!confirmed) return;
            
            try {
                // Delete from API
                const resp = await fetch(`${API}/templates/${templateId}`, {
                    method: 'DELETE',
                    headers: apiHeaders()
                });
                
                if (!resp.ok && resp.status !== 404) {
                    throw new Error(`API error: ${resp.status}`);
                }
                
                // Update localStorage cache
                let templates = JSON.parse(localStorage.getItem('draftbridge_templates') || '[]');
                templates = templates.filter(t => t.id !== templateId);
                localStorage.setItem('draftbridge_templates', JSON.stringify(templates));
                
                // Clear any pending sync for this template
                removePendingChange(templateId);
                
                toast('Template deleted', 'success');
                loadSavedTemplates();
            } catch (err) {
                console.error('Failed to delete template from API:', err);
                
                // Fallback: delete from localStorage only + track for sync
                let templates = JSON.parse(localStorage.getItem('draftbridge_templates') || '[]');
                templates = templates.filter(t => t.id !== templateId);
                localStorage.setItem('draftbridge_templates', JSON.stringify(templates));
                
                // Track for sync when back online
                addPendingChange(templateId, 'delete');
                
                toast('Deleted locally (will sync when online)', 'warning');
                loadSavedTemplates();
            }
        }
        
        // Insert template into document with paragraph formatting
        async function insertTemplate(templateId) {
            const template = savedTemplates.find(t => t.id === templateId);
            if (!template) {
                toast('Template not found', 'error');
                return;
            }
            
            // Gather variable values - for MVP, use prompts for missing required vars
            const variables = { ...previewData };
            
            // Prompt for client name if template uses it
            const usesClient = template.blocks.some(b => 
                (b.content && b.content.includes('{{client.')) ||
                (b.variable && b.variable.startsWith('client.'))
            );
            
            if (usesClient) {
                const clientName = await SmartVariables.showPrompt('Enter client name:', {
                    placeholder: 'e.g. Acme Corporation',
                    confirmText: 'Continue'
                });
                if (clientName) variables.client.name = clientName;
            }
            
            // Insert into document with proper paragraph formatting
            try {
                await Word.run(async (context) => {
                    const selection = context.document.getSelection();
                    let insertionPoint = selection;
                    
                    for (let i = 0; i < template.blocks.length; i++) {
                        const block = template.blocks[i];
                        const isLastBlock = (i === template.blocks.length - 1);
                        
                        // Render the block content with variable substitution
                        const blockContent = renderBlockPreview(block, variables);
                        
                        if (block.type === 'separator') {
                            // Insert separator line
                            const para = insertionPoint.insertParagraph(blockContent, Word.InsertLocation.after);
                            para.alignment = Word.Alignment.centered;
                            insertionPoint = para;
                        } else if (block.type === 'table' && block.cells) {
                            // Insert actual table using OOXML for proper table support
                            const tableOoxml = generateTableOoxml(block, variables);
                            insertionPoint.insertOoxml(tableOoxml, Word.InsertLocation.after);
                            // Move insertion point after table
                            await context.sync();
                            insertionPoint = selection.getRange(Word.RangeLocation.end);
                        } else {
                            // Text blocks - insert paragraph by paragraph for proper formatting
                            const lines = blockContent.split('\n');
                            
                            for (let j = 0; j < lines.length; j++) {
                                const line = lines[j];
                                const isLastLine = (j === lines.length - 1) && isLastBlock;
                                
                                // Insert the paragraph
                                const para = insertionPoint.insertParagraph(line, Word.InsertLocation.after);
                                
                                // Apply paragraph formatting if block has formatting options
                                if (block.keepTogether) {
                                    para.keepTogether = true;
                                }
                                if (block.keepWithNext && !isLastLine) {
                                    para.keepWithNext = true;
                                }
                                if (block.widowControl !== false) {
                                    para.widowControl = true;
                                }
                                
                                insertionPoint = para;
                            }
                        }
                    }
                    
                    await context.sync();
                });
                
                toast(`Inserted "${template.name}"`, 'success');
                hideTemplateList();
            } catch (err) {
                console.error('Insert failed:', err);
                // Fallback to simple text insertion if paragraph formatting fails
                try {
                    await insertTemplateSimple(template, variables);
                    toast(`Inserted "${template.name}" (basic mode)`, 'success');
                    hideTemplateList();
                } catch (fallbackErr) {
                    console.error('Fallback insert also failed:', fallbackErr);
                    toast(friendlyError(err, 'Could not insert template'), 'error');
                }
            }
        }
        
        // Simple text insertion fallback (no paragraph formatting)
        async function insertTemplateSimple(template, variables) {
            let rendered = '';
            for (const block of template.blocks) {
                rendered += renderBlockPreview(block, variables) + '\n';
            }
            
            await Word.run(async (context) => {
                const selection = context.document.getSelection();
                selection.insertText(rendered, Word.InsertLocation.replace);
                await context.sync();
            });
        }
        
        // ============================================================
        // SMART TEMPLATES INTEGRATION
        // ============================================================
        
        let smartTemplatesInitialized = false;
        
        function initSmartTemplates() {
            if (smartTemplatesInitialized) return;
            smartTemplatesInitialized = true;
            
            // Show template selector
            if (typeof SmartVariables !== 'undefined') {
                SmartVariables.showTemplateSelector('smart-templates-root');
            }
        }
        
        // Hook into panel switching
        const originalSwitchPanel = switchPanel;
        switchPanel = function(panelId) {
            originalSwitchPanel(panelId);
            
            // Initialize smart templates when panel is shown
            if (panelId === 'smart') {
                initSmartTemplates();
            }
        };
    </script>

    <!-- Smart Variables JS (modular) -->
    <script src="src/taskpane/sv-state.js"></script>
    <script src="src/taskpane/sv-courts.js"></script>
    <script src="src/taskpane/sv-contacts.js"></script>
    <script src="src/taskpane/sv-templates.js"></script>
    <script src="src/taskpane/sv-profile.js"></script>
    <script src="src/taskpane/sv-form-renderer.js"></script>
    <script src="src/taskpane/sv-validation.js"></script>
    <script src="src/taskpane/sv-document-generator.js"></script>

    <!-- Quick-Insert Snippet FAB (Design D) -->
    <button class="db-snippet-fab" id="db-snippet-fab" onclick="SmartVariables.toggleSnippetPalette()" title="Quick-Insert Snippets">+</button>
</body>
</html>
